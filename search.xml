<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java内部类四大作用 和 Android Handler内存泄漏原因</title>
      <link href="/2020/11/27/java-inner-class-action-and-android-handler-memory-leak/"/>
      <url>/2020/11/27/java-inner-class-action-and-android-handler-memory-leak/</url>
      
        <content type="html"><![CDATA[<h1 id="Java内部类四大作用-和-Android-Handler内存泄漏原因"><a href="#Java内部类四大作用-和-Android-Handler内存泄漏原因" class="headerlink" title="Java内部类四大作用 和 Android Handler内存泄漏原因"></a>Java内部类四大作用 和 Android Handler内存泄漏原因</h1><p>定义在类中的类</p><h2 id="内部类的作用"><a href="#内部类的作用" class="headerlink" title="内部类的作用"></a>内部类的作用</h2><p>需求/存在原因：</p><ul><li>内部类方法可以访问该类定义所在作用域中的数据，包括被 private 修饰的私有数据</li><li>内部类可以对同一包中的其他类隐藏起来</li><li>内部类可以解决 java 单继承的缺陷</li><li>当我们想要定义一个回调函数却不想写大量代码的时候我们可以选择使用匿名内部类来实现</li></ul><p>内部类特点：</p><ol><li>无限制访问外部类所有对象及方法<ol><li>各自生成的class文件，内部类通过外部类.this访问外部类成员</li><li>编译后，内部类实际上是在constructor(构造函数)重写，将引用的外部类，作为constructor参数传入</li></ol></li></ol><p>对反编译看到的<code>access$000</code>不理解，下面是相关文章</p><p><a href="https://bbs.csdn.net/topics/300052325" target="_blank" rel="noopener">https://bbs.csdn.net/topics/300052325</a></p><p>参考资料：<a href="https://blog.csdn.net/u013728021/article/details/87358517" target="_blank" rel="noopener">https://blog.csdn.net/u013728021/article/details/87358517</a></p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
            <tag> Memory leak </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shadowsocks libev multiple port Config</title>
      <link href="/2020/09/17/shadowsocks-libev-multiple-port-config/"/>
      <url>/2020/09/17/shadowsocks-libev-multiple-port-config/</url>
      
        <content type="html"><![CDATA[<h1 id="Shadowsocks-libev-多端口配置方式"><a href="#Shadowsocks-libev-多端口配置方式" class="headerlink" title="Shadowsocks libev 多端口配置方式"></a>Shadowsocks libev 多端口配置方式</h1><h3 id="创建不同端口的配置文件"><a href="#创建不同端口的配置文件" class="headerlink" title="创建不同端口的配置文件"></a>创建不同端口的配置文件</h3><p>新建<code>/etc/shadowsocks-libev/config_x.json</code>文件</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"server"</span><span class="token operator">:</span><span class="token string">"server_ip"</span><span class="token punctuation">,</span>    <span class="token property">"server_port"</span><span class="token operator">:</span> server_port<span class="token punctuation">,</span>    <span class="token property">"local_port"</span><span class="token operator">:</span> <span class="token number">1080</span><span class="token punctuation">,</span>    <span class="token property">"password"</span><span class="token operator">:</span> <span class="token string">"custom password"</span><span class="token punctuation">,</span>    <span class="token property">"timeout"</span><span class="token operator">:</span> <span class="token number">300</span><span class="token punctuation">,</span>    <span class="token property">"method"</span><span class="token operator">:</span> <span class="token string">"aes-256-cfb"</span><span class="token punctuation">,</span>    <span class="token property">"fast_open"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span></code></pre><h3 id="创建ss批量启动脚本"><a href="#创建ss批量启动脚本" class="headerlink" title="创建ss批量启动脚本"></a>创建ss批量启动脚本</h3><p>新建 <code>/usr/local/bin/shadowsocks-libev-autostart.sh</code> 文件</p><pre><code>#!/bin/bashproc=/usr/local/bin/ss-serverconfig_dir=/etc/shadowsocks-libevlog_dir=/etc/shadowsocks-libevarg=&quot; -v &quot;config_files=()files=$(ls ${config_dir}/config_*.json)for f in ${files[@]}do    fn=${f##*/}   nohup $proc -c $f $arg  &gt;&gt; ${log_dir}/${fn%.*}.log 2&gt;&amp;1 &amp;done</code></pre><h3 id="添加执行权限"><a href="#添加执行权限" class="headerlink" title="添加执行权限"></a>添加执行权限</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">chmod</span> 755 /usr/local/bin/shadowsocks-libev-autostart.sh</code></pre><h3 id="配置systemd自启动"><a href="#配置systemd自启动" class="headerlink" title="配置systemd自启动"></a>配置systemd自启动</h3><p>创建文件<code>/etc/systemd/system/sslibev.service</code></p><pre><code>[Unit]Description=Shadowsocks-ssserverAfter=network.target[Service]Type=forkingTimeoutStartSec=3ExecStart=/usr/local/bin/shadowsocks-libev-autostart.shRestart=always[Install]WantedBy=multi-user.target</code></pre><p>注册systemd启动项，并运行</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">sudo</span> systemctl <span class="token function">enable</span> /etc/systemd/system/sslibev.service <span class="token comment" spellcheck="true">#注册自启动</span>$ <span class="token function">sudo</span> systemctl start sslibev     <span class="token comment" spellcheck="true"># 运行</span></code></pre><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>需要添加新端口的时候，新建<code>/etc/shadowsocks-libev/config_{x}.json</code>文件，如<code>config_1.json</code>、<code>config_2.json</code>，配置对应端口和密码，然后重启systemd的<code>sslibev</code>服务即可。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><pre><code>$ sudo systemctl restart sslibev   # 重启sslibev服务$ sudo systemctl disable sslibev   # 停用sslibev自启动$ sudo rm /etc/systemd/system/sslibev.service   # 移除sslibev启动项$ systemctl status sslibev         # 查看运行状态$ ss -lnt   # 查看tcp端口接听状态</code></pre>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shadowsocks </tag>
            
            <tag> ss </tag>
            
            <tag> server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Activity中onResume方法触发的ActivityRecord not found异常分析</title>
      <link href="/2020/07/27/activity-not-found-error/"/>
      <url>/2020/07/27/activity-not-found-error/</url>
      
        <content type="html"><![CDATA[<h1 id="Activity中onResume方法触发的ActivityRecord-not-found异常分析"><a href="#Activity中onResume方法触发的ActivityRecord-not-found异常分析" class="headerlink" title="Activity中onResume方法触发的ActivityRecord not found异常分析"></a>Activity中onResume方法触发的ActivityRecord not found异常分析</h1><blockquote><p><a href="https://www.jianshu.com/p/0c63a8e5c1ad" target="_blank" rel="noopener">https://www.jianshu.com/p/0c63a8e5c1ad</a></p><p>再次基础上 写了个Java版供参考</p></blockquote><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>最近我在处理线上奔溃日志的时候发现一个由Activity中<strong>onResume</strong>方法触发的<strong>ActivityRecord not found</strong>异常，具体信息如下：</p><pre class=" language-java"><code class="language-java">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>RuntimeException<span class="token operator">:</span> Unable to resume activity <span class="token punctuation">{</span>com<span class="token punctuation">.</span>xxx<span class="token punctuation">.</span>xx<span class="token operator">/</span>com<span class="token punctuation">.</span>xxx<span class="token punctuation">.</span>xxx<span class="token punctuation">.</span>RegisterActivity<span class="token punctuation">}</span><span class="token operator">:</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>IllegalArgumentException    at android<span class="token punctuation">.</span>app<span class="token punctuation">.</span>ActivityThread<span class="token punctuation">.</span><span class="token function">performResumeActivity</span><span class="token punctuation">(</span>ActivityThread<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">4025</span><span class="token punctuation">)</span>    at android<span class="token punctuation">.</span>app<span class="token punctuation">.</span>ActivityThread<span class="token punctuation">.</span><span class="token function">handleResumeActivity</span><span class="token punctuation">(</span>ActivityThread<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">4057</span><span class="token punctuation">)</span>    at android<span class="token punctuation">.</span>app<span class="token punctuation">.</span>servertransaction<span class="token punctuation">.</span>ResumeActivityItem<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>ResumeActivityItem<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">51</span><span class="token punctuation">)</span>    at android<span class="token punctuation">.</span>app<span class="token punctuation">.</span>servertransaction<span class="token punctuation">.</span>TransactionExecutor<span class="token punctuation">.</span><span class="token function">executeLifecycleState</span><span class="token punctuation">(</span>TransactionExecutor<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">145</span><span class="token punctuation">)</span>    at android<span class="token punctuation">.</span>app<span class="token punctuation">.</span>servertransaction<span class="token punctuation">.</span>TransactionExecutor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>TransactionExecutor<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">70</span><span class="token punctuation">)</span>    at android<span class="token punctuation">.</span>app<span class="token punctuation">.</span>ActivityThread$H<span class="token punctuation">.</span><span class="token function">handleMessage</span><span class="token punctuation">(</span>ActivityThread<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1960</span><span class="token punctuation">)</span>    at android<span class="token punctuation">.</span>os<span class="token punctuation">.</span>Handler<span class="token punctuation">.</span><span class="token function">dispatchMessage</span><span class="token punctuation">(</span>Handler<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">106</span><span class="token punctuation">)</span>    at android<span class="token punctuation">.</span>os<span class="token punctuation">.</span>Looper<span class="token punctuation">.</span><span class="token function">loop</span><span class="token punctuation">(</span>Looper<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">214</span><span class="token punctuation">)</span>    at android<span class="token punctuation">.</span>app<span class="token punctuation">.</span>ActivityThread<span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span>ActivityThread<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">7097</span><span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>Native Method<span class="token punctuation">)</span>    at com<span class="token punctuation">.</span>android<span class="token punctuation">.</span>internal<span class="token punctuation">.</span>os<span class="token punctuation">.</span>RuntimeInit$MethodAndArgsCaller<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>RuntimeInit<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">494</span><span class="token punctuation">)</span>    at com<span class="token punctuation">.</span>android<span class="token punctuation">.</span>internal<span class="token punctuation">.</span>os<span class="token punctuation">.</span>ZygoteInit<span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span>ZygoteInit<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">975</span><span class="token punctuation">)</span>Caused by<span class="token operator">:</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>IllegalArgumentException    at android<span class="token punctuation">.</span>os<span class="token punctuation">.</span>Parcel<span class="token punctuation">.</span><span class="token function">createException</span><span class="token punctuation">(</span>Parcel<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1970</span><span class="token punctuation">)</span>    at android<span class="token punctuation">.</span>os<span class="token punctuation">.</span>Parcel<span class="token punctuation">.</span><span class="token function">readException</span><span class="token punctuation">(</span>Parcel<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1934</span><span class="token punctuation">)</span>    at android<span class="token punctuation">.</span>os<span class="token punctuation">.</span>Parcel<span class="token punctuation">.</span><span class="token function">readException</span><span class="token punctuation">(</span>Parcel<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1884</span><span class="token punctuation">)</span>    at android<span class="token punctuation">.</span>app<span class="token punctuation">.</span>IActivityManager$Stub$Proxy<span class="token punctuation">.</span><span class="token function">isTopOfTask</span><span class="token punctuation">(</span>IActivityManager<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">7845</span><span class="token punctuation">)</span>    at android<span class="token punctuation">.</span>app<span class="token punctuation">.</span>Activity<span class="token punctuation">.</span><span class="token function">isTopOfTask</span><span class="token punctuation">(</span>Activity<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">6551</span><span class="token punctuation">)</span>    at android<span class="token punctuation">.</span>app<span class="token punctuation">.</span>Activity<span class="token punctuation">.</span><span class="token function">onResume</span><span class="token punctuation">(</span>Activity<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1404</span><span class="token punctuation">)</span>    at androidx<span class="token punctuation">.</span>fragment<span class="token punctuation">.</span>app<span class="token punctuation">.</span>FragmentActivity<span class="token punctuation">.</span><span class="token function">onResume</span><span class="token punctuation">(</span>ProGuard<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">)</span>    at com<span class="token punctuation">.</span>xxx<span class="token punctuation">.</span>xxx<span class="token punctuation">.</span>BaseMVPActivity<span class="token punctuation">.</span><span class="token function">onResume</span><span class="token punctuation">(</span>ProGuard<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">)</span>    at android<span class="token punctuation">.</span>app<span class="token punctuation">.</span>Instrumentation<span class="token punctuation">.</span><span class="token function">callActivityOnResume</span><span class="token punctuation">(</span>Instrumentation<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1416</span><span class="token punctuation">)</span>    at android<span class="token punctuation">.</span>app<span class="token punctuation">.</span>Activity<span class="token punctuation">.</span><span class="token function">performResume</span><span class="token punctuation">(</span>Activity<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">7585</span><span class="token punctuation">)</span>    at android<span class="token punctuation">.</span>app<span class="token punctuation">.</span>ActivityThread<span class="token punctuation">.</span><span class="token function">performResumeActivity</span><span class="token punctuation">(</span>ActivityThread<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">4017</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token number">11</span> moreCaused by<span class="token operator">:</span> android<span class="token punctuation">.</span>os<span class="token punctuation">.</span>RemoteException<span class="token operator">:</span> Remote stack trace<span class="token operator">:</span>    at com<span class="token punctuation">.</span>android<span class="token punctuation">.</span>server<span class="token punctuation">.</span>am<span class="token punctuation">.</span>ActivityManagerService<span class="token punctuation">.</span><span class="token function">isTopOfTask</span><span class="token punctuation">(</span>ActivityManagerService<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">18293</span><span class="token punctuation">)</span>    at android<span class="token punctuation">.</span>app<span class="token punctuation">.</span>IActivityManager$Stub<span class="token punctuation">.</span><span class="token function">onTransact</span><span class="token punctuation">(</span>IActivityManager<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">2058</span><span class="token punctuation">)</span>    at com<span class="token punctuation">.</span>android<span class="token punctuation">.</span>server<span class="token punctuation">.</span>am<span class="token punctuation">.</span>ActivityManagerService<span class="token punctuation">.</span><span class="token function">onTransact</span><span class="token punctuation">(</span>ActivityManagerService<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">4174</span><span class="token punctuation">)</span>    at android<span class="token punctuation">.</span>os<span class="token punctuation">.</span>Binder<span class="token punctuation">.</span><span class="token function">execTransact</span><span class="token punctuation">(</span>Binder<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">739</span><span class="token punctuation">)</span></code></pre><p>可见当发生<code>ActivityRecord not found</code>时，<code>isTopOfTask()</code>方法里抛出来了一个<code>IllegalArgumentException</code>异常。引起<code>ActivityRecord not found</code>的原因有多种，这里不太好针对<code>ActivityRecord not found</code>进行处理，所以我想怎么来屏蔽这个异常，让程序不奔溃。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先我们来看看<code>Activity</code>的源码(API 24)：</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token annotation punctuation">@CallSuper</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onResume</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>DEBUG_LIFECYCLE<span class="token punctuation">)</span> Slog<span class="token punctuation">.</span><span class="token function">v</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"onResume "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">getApplication</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">dispatchActivityResumed</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    mActivityTransitionState<span class="token punctuation">.</span><span class="token function">onResume</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token function">isTopOfTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    mCalled <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isTopOfTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mToken <span class="token operator">==</span> null <span class="token operator">||</span> mWindow <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> ActivityManagerNative<span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isTopOfTask</span><span class="token punctuation">(</span><span class="token function">getActivityToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RemoteException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>注意，在7.0到9.0系统上的onResume方法里才会调用这个isTopOfTask方法，所以这个问题只有这几个版本有。</p></blockquote><blockquote><p>网上有一种做法是直接try-catch <code>onResume</code>方法，然后通过反射将<code>mCalled</code>修改为true。由于这个问题不好复现，我没有去验证这个方法的可行性，但是这种简单粗暴的方法看上去其实是有问题的，因为<code>isTopOfTask()</code>抛出异常后，<code>mActivityTransitionState.onResume()</code>方法里的逻辑就没有执行。</p></blockquote><p>我们分析下<code>isTopOfTask()</code>方法，发现这个方法try-catch了一个<code>RemoteException</code>异常，当发生这个异常的时候将返回false，后面的流程能正常执行，不会影响Activity，于是我们想这里可不可以将<code>IllegalArgumentException</code>异常也try-catch一下呐，但是发现这是一个私有方法，无法重写，所以只能继续往下追踪。<br> 来看看<code>ActivityManagerNative.getDefault()</code>的实现：<br> 在API 24、25上：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">ActivityManagerNative</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">static</span> <span class="token keyword">public</span> IActivityManager <span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> gDefault<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton<span class="token operator">&lt;</span>IActivityManager<span class="token operator">></span> gDefault <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token operator">&lt;</span>IActivityManager<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">protected</span> IActivityManager <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            IBinder b <span class="token operator">=</span> ServiceManager<span class="token punctuation">.</span><span class="token function">getService</span><span class="token punctuation">(</span><span class="token string">"activity"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Log<span class="token punctuation">.</span><span class="token function">v</span><span class="token punctuation">(</span><span class="token string">"ActivityManager"</span><span class="token punctuation">,</span> <span class="token string">"default service binder = "</span> <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            IActivityManager am <span class="token operator">=</span> <span class="token function">asInterface</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Log<span class="token punctuation">.</span><span class="token function">v</span><span class="token punctuation">(</span><span class="token string">"ActivityManager"</span><span class="token punctuation">,</span> <span class="token string">"default service = "</span> <span class="token operator">+</span> am<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> am<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>在API 26+上：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">ActivityManagerNative</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">static</span> <span class="token keyword">public</span> IActivityManager <span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> ActivityManager<span class="token punctuation">.</span><span class="token function">getService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>继续看<code>ActivityManager.getService()</code>：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ActivityManager</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> IActivityManager <span class="token function">getService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> IActivityManagerSingleton<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton<span class="token operator">&lt;</span>IActivityManager<span class="token operator">></span> IActivityManagerSingleton <span class="token operator">=</span>            <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token operator">&lt;</span>IActivityManager<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">protected</span> IActivityManager <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">final</span> IBinder b <span class="token operator">=</span> ServiceManager<span class="token punctuation">.</span><span class="token function">getService</span><span class="token punctuation">(</span>Context<span class="token punctuation">.</span>ACTIVITY_SERVICE<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">final</span> IActivityManager am <span class="token operator">=</span> IActivityManager<span class="token punctuation">.</span>Stub<span class="token punctuation">.</span><span class="token function">asInterface</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> am<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>我们发现<code>getDefault()</code>方法返回的是一个<code>IActivityManager</code>对象，所以实际上执行的是<code>IActivityManager</code>里的<code>isTopOfTask()</code>方法。而<code>IActivityManager</code>是一个单例，在7.0和7.1上这个单例对象在<code>ActivityManagerNative</code>类里面的，而从8.0开始放到了<code>ActivityManager</code>里。而且通过上面的<code>final IActivityManager am = IActivityManager.Stub.asInterface(b);</code>这句还知道了<code>IActivityManager</code>其实是一个接口（懒得继续翻源码了^_^）。<br> 继续看这个<code>Singleton</code>：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> T mInstance<span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token keyword">abstract</span> T <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> T <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mInstance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                mInstance <span class="token operator">=</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> mInstance<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>到这里我们就可以想到使用反射和动态代理就可以对<code>IActivityManager</code>里的方法进行Hook，然后就可以处理这个<code>IllegalArgumentException</code>异常了。</p><h2 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h2><p>第一步：通过反射拿到<code>Singleton</code>对象：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// Singleton是一个隐藏类，无法直接访问，所以这里通过Class.forName来加载，备用</span><span class="token keyword">val</span> singletonCls <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"android.util.Singleton"</span><span class="token punctuation">)</span></code></pre><p>在API 24、25上：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">private</span> <span class="token keyword">fun</span> <span class="token function">getIActivityManagerSingletonInstanceN</span><span class="token punctuation">(</span>singletonCls<span class="token operator">:</span> Class<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> Any<span class="token operator">?</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 找到ActivityManagerNative里的gDefault这个常量</span>    <span class="token comment" spellcheck="true">// 这里通过变量的类型对比找出gDefault这个常量，</span>    <span class="token comment" spellcheck="true">// 没有通过名字来查找，防止名字有变法</span>    <span class="token comment" spellcheck="true">// 这里也可以直接使用activityManagerNativeCls.getDeclaredField("gDefault")来获取</span>    <span class="token keyword">val</span> activityManagerNativeCls <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"android.app.ActivityManagerNative"</span><span class="token punctuation">)</span>    <span class="token keyword">var</span> iActivityManagerSingleton<span class="token operator">:</span> Any<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>field <span class="token keyword">in</span> activityManagerNativeCls<span class="token punctuation">.</span>declaredFields<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>field<span class="token punctuation">.</span>type <span class="token operator">==</span> singletonCls<span class="token punctuation">)</span> <span class="token punctuation">{</span>            field<span class="token punctuation">.</span>isAccessible <span class="token operator">=</span> <span class="token boolean">true</span>            iActivityManagerSingleton <span class="token operator">=</span> field<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token keyword">break</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>iActivityManagerSingleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Logger<span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"Not found IActivityManager singleton field in class ActivityManagerNative."</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> iActivityManagerSingleton<span class="token punctuation">}</span></code></pre><p>在API 26+上：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">private</span> <span class="token keyword">fun</span> <span class="token function">getIActivityManagerSingletonInstance</span><span class="token punctuation">(</span>singletonCls<span class="token operator">:</span> Class<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> Any<span class="token operator">?</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 找到ActivityManager里的IActivityManagerSingleton常量</span>    <span class="token comment" spellcheck="true">// 这里通过变量的类型对比找出IActivityManagerSingleton这个常量，</span>    <span class="token comment" spellcheck="true">// 没有通过名字来查找，防止名字有变法</span>    <span class="token comment" spellcheck="true">// 这里也可以直接使用ActivityManager::class.java.getDeclaredField("IActivityManagerSingleton")来获取</span>    <span class="token keyword">var</span> iActivityManagerSingleton<span class="token operator">:</span> Any<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>field <span class="token keyword">in</span> ActivityManager<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">.</span>java<span class="token punctuation">.</span>declaredFields<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>field<span class="token punctuation">.</span>type <span class="token operator">==</span> singletonCls<span class="token punctuation">)</span> <span class="token punctuation">{</span>            field<span class="token punctuation">.</span>isAccessible <span class="token operator">=</span> <span class="token boolean">true</span>            iActivityManagerSingleton <span class="token operator">=</span> field<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token keyword">break</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>iActivityManagerSingleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Logger<span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"Not found IActivityManager singleton field in class ActivityManager."</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> iActivityManagerSingleton<span class="token punctuation">}</span></code></pre><p>第二步：拿到<code>Singleton</code>里的<code>mInstance</code>字段：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// 注意这里的iActivityManagerSingleton是Singleton的一个匿名子类</span><span class="token comment" spellcheck="true">// 如果要用iActivityManagerSingleton来进行反射，需要这样处理：</span><span class="token comment" spellcheck="true">// iActivityManagerSingleton::class.java.superclass.getDeclaredField("mInstance")</span><span class="token keyword">val</span> instanceField <span class="token operator">=</span> singletonCls<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"mInstance"</span><span class="token punctuation">)</span>instanceField<span class="token punctuation">.</span>isAccessible <span class="token operator">=</span> <span class="token boolean">true</span><span class="token keyword">val</span> iActivityManager <span class="token operator">=</span> instanceField<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>iActivityManagerSingleton<span class="token punctuation">)</span></code></pre><p>第三步：把代理类写出来<br>（本方法的处理核心就在这里）</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token function">IActivityManagerProxy</span><span class="token punctuation">(</span><span class="token keyword">private</span> <span class="token keyword">val</span> instance<span class="token operator">:</span> Any<span class="token punctuation">)</span><span class="token operator">:</span> InvocationHandler <span class="token punctuation">{</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">invoke</span><span class="token punctuation">(</span>proxy<span class="token operator">:</span> Any<span class="token operator">?</span><span class="token punctuation">,</span> method<span class="token operator">:</span> Method<span class="token punctuation">,</span> args<span class="token operator">:</span> Array<span class="token operator">&lt;</span><span class="token keyword">out</span> Any<span class="token operator">></span><span class="token operator">?</span><span class="token punctuation">)</span><span class="token operator">:</span> Any<span class="token operator">?</span> <span class="token punctuation">{</span>        Logger<span class="token punctuation">.</span><span class="token function">i</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"invoke: <span class="token interpolation"><span class="token delimiter variable">${</span>method<span class="token punctuation">.</span>name<span class="token delimiter variable">}</span></span>()"</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>method<span class="token punctuation">.</span>name <span class="token operator">==</span> <span class="token string">"isTopOfTask"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">val</span> result <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>args <span class="token operator">?:</span> <span class="token function">emptyArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">as</span> Boolean                Logger<span class="token punctuation">.</span><span class="token function">i</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"isTopOfTask() invoke success"</span><span class="token punctuation">)</span>                result            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> Exception<span class="token punctuation">)</span> <span class="token punctuation">{</span>                Logger<span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"isTopOfTask() invoke exception: <span class="token interpolation variable">$e</span>"</span><span class="token punctuation">)</span>                <span class="token boolean">false</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>args <span class="token operator">?:</span> <span class="token function">emptyArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>第四步：用动态代理替换原来的IActivityManager对象</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> proxy <span class="token operator">=</span> <span class="token function">IActivityManagerProxy</span><span class="token punctuation">(</span>iActivityManager<span class="token punctuation">)</span><span class="token keyword">val</span> iActivityManagerCls <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"android.app.IActivityManager"</span><span class="token punctuation">)</span><span class="token keyword">val</span> iActivityManageProxy <span class="token operator">=</span> Proxy<span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>iActivityManagerCls<span class="token punctuation">.</span>classLoader<span class="token punctuation">,</span> <span class="token function">arrayOf</span><span class="token punctuation">(</span>iActivityManagerCls<span class="token punctuation">)</span><span class="token punctuation">,</span> proxy<span class="token punctuation">)</span>instanceField<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>iActivityManagerSingleton<span class="token punctuation">,</span> iActivityManageProxy<span class="token punctuation">)</span></code></pre><p>完整代码如下：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">object</span> IActivityManagerHook <span class="token punctuation">{</span>   <span class="token keyword">private</span> <span class="token keyword">const</span> <span class="token keyword">val</span> TAG <span class="token operator">=</span> <span class="token string">"IActivityManagerHook"</span>    <span class="token annotation builtin">@SuppressLint</span><span class="token punctuation">(</span><span class="token string">"PrivateApi"</span><span class="token punctuation">)</span>    <span class="token keyword">fun</span> <span class="token function">iActivityManagerHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>Build<span class="token punctuation">.</span>VERSION<span class="token punctuation">.</span>SDK_INT <span class="token operator">&lt;</span> <span class="token number">24</span> <span class="token operator">||</span> Build<span class="token punctuation">.</span>VERSION<span class="token punctuation">.</span>SDK_INT <span class="token operator">></span> <span class="token number">28</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span>        <span class="token punctuation">}</span>        Logger<span class="token punctuation">.</span><span class="token function">i</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"IActivityManager hook ..."</span><span class="token punctuation">)</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">val</span> singletonCls <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"android.util.Singleton"</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 第一步：通过反射拿到Singleton对象</span>            <span class="token keyword">val</span> iActivityManagerSingleton <span class="token operator">=</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>Build<span class="token punctuation">.</span>VERSION<span class="token punctuation">.</span>SDK_INT <span class="token operator">&lt;=</span> <span class="token number">25</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">getIActivityManagerSingletonInstanceN</span><span class="token punctuation">(</span>singletonCls<span class="token punctuation">)</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token function">getIActivityManagerSingletonInstance</span><span class="token punctuation">(</span>singletonCls<span class="token punctuation">)</span>            <span class="token punctuation">}</span> <span class="token operator">?:</span> <span class="token keyword">return</span>            <span class="token comment" spellcheck="true">// 第二步：找出Singleton里的mInstance变量</span>            <span class="token keyword">val</span> instanceField <span class="token operator">=</span> singletonCls<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"mInstance"</span><span class="token punctuation">)</span>            instanceField<span class="token punctuation">.</span>isAccessible <span class="token operator">=</span> <span class="token boolean">true</span>            <span class="token keyword">val</span> iActivityManager <span class="token operator">=</span> instanceField<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>iActivityManagerSingleton<span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>iActivityManager <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Logger<span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"Not found IActivityManager instance."</span><span class="token punctuation">)</span>                <span class="token keyword">return</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 第三步：使用动态代理替换原来的IActivityManager对象</span>            <span class="token keyword">val</span> proxy <span class="token operator">=</span> <span class="token function">IActivityManagerProxy</span><span class="token punctuation">(</span>iActivityManager<span class="token punctuation">)</span>            <span class="token keyword">val</span> iActivityManagerCls <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"android.app.IActivityManager"</span><span class="token punctuation">)</span>            <span class="token keyword">val</span> iActivityManageProxy <span class="token operator">=</span> Proxy<span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>iActivityManagerCls<span class="token punctuation">.</span>classLoader<span class="token punctuation">,</span> <span class="token function">arrayOf</span><span class="token punctuation">(</span>iActivityManagerCls<span class="token punctuation">)</span><span class="token punctuation">,</span> proxy<span class="token punctuation">)</span>            instanceField<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>iActivityManagerSingleton<span class="token punctuation">,</span> iActivityManageProxy<span class="token punctuation">)</span>            Logger<span class="token punctuation">.</span><span class="token function">i</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"IActivityManager hook success."</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> Throwable<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Logger<span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"IActivityManager hook fail: <span class="token interpolation variable">$e</span>"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation builtin">@SuppressLint</span><span class="token punctuation">(</span><span class="token string">"PrivateApi"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">fun</span> <span class="token function">getIActivityManagerSingletonInstanceN</span><span class="token punctuation">(</span>singletonCls<span class="token operator">:</span> Class<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> Any<span class="token operator">?</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 找到ActivityManagerNative里的gDefault这个常量</span>        <span class="token comment" spellcheck="true">// 这里通过变量的类型对比找出gDefault这个常量，</span>        <span class="token comment" spellcheck="true">// 没有通过名字来查找，防止名字有变法</span>        <span class="token comment" spellcheck="true">// 这里也可以直接使用activityManagerNativeCls.getDeclaredField("gDefault")来获取</span>        <span class="token keyword">val</span> activityManagerNativeCls <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"android.app.ActivityManagerNative"</span><span class="token punctuation">)</span>        <span class="token keyword">var</span> iActivityManagerSingleton<span class="token operator">:</span> Any<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>field <span class="token keyword">in</span> activityManagerNativeCls<span class="token punctuation">.</span>declaredFields<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>field<span class="token punctuation">.</span>type <span class="token operator">==</span> singletonCls<span class="token punctuation">)</span> <span class="token punctuation">{</span>                field<span class="token punctuation">.</span>isAccessible <span class="token operator">=</span> <span class="token boolean">true</span>                iActivityManagerSingleton <span class="token operator">=</span> field<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>                <span class="token keyword">break</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>iActivityManagerSingleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Logger<span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"Not found IActivityManager singleton field in class ActivityManagerNative."</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> iActivityManagerSingleton    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">fun</span> <span class="token function">getIActivityManagerSingletonInstance</span><span class="token punctuation">(</span>singletonCls<span class="token operator">:</span> Class<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> Any<span class="token operator">?</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 找到ActivityManager里的IActivityManagerSingleton常量</span>        <span class="token comment" spellcheck="true">// 这里通过变量的类型对比找出IActivityManagerSingleton这个常量，</span>        <span class="token comment" spellcheck="true">// 没有通过名字来查找，防止名字有变法</span>        <span class="token comment" spellcheck="true">// 这里也可以直接使用ActivityManager::class.java.getDeclaredField("IActivityManagerSingleton")来获取</span>        <span class="token keyword">var</span> iActivityManagerSingleton<span class="token operator">:</span> Any<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>field <span class="token keyword">in</span> ActivityManager<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">.</span>java<span class="token punctuation">.</span>declaredFields<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>field<span class="token punctuation">.</span>type <span class="token operator">==</span> singletonCls<span class="token punctuation">)</span> <span class="token punctuation">{</span>                field<span class="token punctuation">.</span>isAccessible <span class="token operator">=</span> <span class="token boolean">true</span>                iActivityManagerSingleton <span class="token operator">=</span> field<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>                <span class="token keyword">break</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>iActivityManagerSingleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Logger<span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"Not found IActivityManager singleton field in class ActivityManager."</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> iActivityManagerSingleton    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token function">IActivityManagerProxy</span><span class="token punctuation">(</span><span class="token keyword">private</span> <span class="token keyword">val</span> instance<span class="token operator">:</span> Any<span class="token punctuation">)</span><span class="token operator">:</span> InvocationHandler <span class="token punctuation">{</span>        <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">invoke</span><span class="token punctuation">(</span>proxy<span class="token operator">:</span> Any<span class="token operator">?</span><span class="token punctuation">,</span> method<span class="token operator">:</span> Method<span class="token punctuation">,</span> args<span class="token operator">:</span> Array<span class="token operator">&lt;</span><span class="token keyword">out</span> Any<span class="token operator">></span><span class="token operator">?</span><span class="token punctuation">)</span><span class="token operator">:</span> Any<span class="token operator">?</span> <span class="token punctuation">{</span>            Logger<span class="token punctuation">.</span><span class="token function">i</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"invoke: <span class="token interpolation"><span class="token delimiter variable">${</span>method<span class="token punctuation">.</span>name<span class="token delimiter variable">}</span></span>()"</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>method<span class="token punctuation">.</span>name <span class="token operator">==</span> <span class="token string">"isTopOfTask"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token keyword">val</span> result <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>args <span class="token operator">?:</span> <span class="token function">emptyArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">as</span> Boolean                    Logger<span class="token punctuation">.</span><span class="token function">i</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"isTopOfTask() invoke success"</span><span class="token punctuation">)</span>                    result                 <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> Exception<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    Logger<span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"isTopOfTask() invoke exception: <span class="token interpolation variable">$e</span>"</span><span class="token punctuation">)</span>                    <span class="token boolean">false</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>args <span class="token operator">?:</span> <span class="token function">emptyArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>java代码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IActivityManagerHook</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> String TAG <span class="token operator">=</span> <span class="token string">"IActivityManagerHook"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">iActivityManagerHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>Build<span class="token punctuation">.</span>VERSION<span class="token punctuation">.</span>SDK_INT <span class="token operator">&lt;</span> <span class="token number">24</span> <span class="token operator">||</span> Build<span class="token punctuation">.</span>VERSION<span class="token punctuation">.</span>SDK_INT <span class="token operator">></span> <span class="token number">28</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Log<span class="token punctuation">.</span><span class="token function">i</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"IActivityManager hook ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> singletonCls <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"android.util.Singleton"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 第一步：通过反射拿到Singleton对象</span>            Object iActivityManagerSingleton <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>Build<span class="token punctuation">.</span>VERSION<span class="token punctuation">.</span>SDK_INT <span class="token operator">&lt;=</span> <span class="token number">25</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                iActivityManagerSingleton <span class="token operator">=</span> <span class="token function">getIActivityManagerSingletonInstanceN</span><span class="token punctuation">(</span>singletonCls<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                iActivityManagerSingleton <span class="token operator">=</span> <span class="token function">getIActivityManagerSingletonInstance</span><span class="token punctuation">(</span>singletonCls<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>iActivityManagerSingleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 第二步：找出Singleton里的mInstance变量</span>            Field instanceField <span class="token operator">=</span> singletonCls<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"mInstance"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            instanceField<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Object iActivityManager <span class="token operator">=</span> instanceField<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>iActivityManagerSingleton<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>iActivityManager <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                Log<span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"Not found IActivityManager instance."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 第三步：使用动态代理替换原来的IActivityManager对象</span>            IActivityManagerProxy proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IActivityManagerProxy</span><span class="token punctuation">(</span>iActivityManager<span class="token punctuation">)</span><span class="token punctuation">;</span>            Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> iActivityManagerCls <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"android.app.IActivityManager"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Object iActivityManageProxy <span class="token operator">=</span> Proxy<span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>iActivityManagerCls<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>iActivityManagerCls<span class="token punctuation">}</span><span class="token punctuation">,</span> proxy<span class="token punctuation">)</span><span class="token punctuation">;</span>            instanceField<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>iActivityManagerSingleton<span class="token punctuation">,</span> iActivityManageProxy<span class="token punctuation">)</span><span class="token punctuation">;</span>            Log<span class="token punctuation">.</span><span class="token function">i</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"IActivityManager hook success."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Log<span class="token punctuation">.</span><span class="token function">e</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Object <span class="token function">getIActivityManagerSingletonInstanceN</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> singletonCls<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException<span class="token punctuation">,</span> IllegalAccessException<span class="token punctuation">,</span> NoSuchFieldException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 找到ActivityManagerNative里的gDefault这个常量</span>        <span class="token comment" spellcheck="true">// 这里通过变量的类型对比找出gDefault这个常量，</span>        <span class="token comment" spellcheck="true">// 没有通过名字来查找，防止名字有变法</span>        <span class="token comment" spellcheck="true">// 这里也可以直接使用activityManagerNativeCls.getDeclaredField("gDefault")来获取</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> activityManagerNativeCls <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"android.app.ActivityManagerNative"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Object iActivityManagerSingleton <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Field field <span class="token operator">:</span> activityManagerNativeCls<span class="token punctuation">.</span><span class="token function">getDeclaredFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>field<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> singletonCls<span class="token punctuation">)</span> <span class="token punctuation">{</span>                field<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                iActivityManagerSingleton <span class="token operator">=</span> field<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>iActivityManagerSingleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Log<span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"Not found IActivityManager singleton field in class ActivityManagerNative."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> iActivityManagerSingleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Object <span class="token function">getIActivityManagerSingletonInstance</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> singletonCls<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException<span class="token punctuation">,</span> IllegalAccessException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 找到ActivityManager里的IActivityManagerSingleton常量</span>        <span class="token comment" spellcheck="true">// 这里通过变量的类型对比找出IActivityManagerSingleton这个常量，</span>        <span class="token comment" spellcheck="true">// 没有通过名字来查找，防止名字有变法</span>        <span class="token comment" spellcheck="true">// 这里也可以直接使用ActivityManager::class.java.getDeclaredField("IActivityManagerSingleton")来获取</span>        Object iActivityManagerSingleton <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Field field <span class="token operator">:</span> ActivityManager<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>field<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> singletonCls<span class="token punctuation">)</span> <span class="token punctuation">{</span>                field<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                iActivityManagerSingleton <span class="token operator">=</span> field<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>iActivityManagerSingleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Log<span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"Not found IActivityManager singleton field in class ActivityManagerNative."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> iActivityManagerSingleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">IActivityManagerProxy</span> <span class="token keyword">implements</span> <span class="token class-name">InvocationHandler</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> Object instance<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">IActivityManagerProxy</span><span class="token punctuation">(</span>Object instance<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>instance <span class="token operator">=</span> instance<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>            Log<span class="token punctuation">.</span><span class="token function">i</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"invoke: "</span> <span class="token operator">+</span> method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">"isTopOfTask"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">boolean</span> invoke <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    invoke <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">boolean</span><span class="token punctuation">)</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>                    Log<span class="token punctuation">.</span><span class="token function">i</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"isTopOfTask() invoke success"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    Log<span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"isTopOfTask() invoke exception: "</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">return</span> invoke<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> BUG </tag>
            
            <tag> Activity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>diskutil MacOS summary</title>
      <link href="/2020/07/06/diskutil-macos-summary/"/>
      <url>/2020/07/06/diskutil-macos-summary/</url>
      
        <content type="html"><![CDATA[<h1 id="diskutil-macOS-工具使用总结"><a href="#diskutil-macOS-工具使用总结" class="headerlink" title="diskutil macOS 工具使用总结"></a>diskutil macOS 工具使用总结</h1><hr><ul><li>获取磁盘和分区信息：如 <strong>list</strong>、<strong>info</strong>、<strong>activity</strong> 等</li><li>挂（卸）载磁盘或卷：如 <strong>mount</strong>、<strong>eject</strong>、<strong>mountDisk</strong> 等</li><li>验证、修复磁盘分区或文件系统：如 <strong>verifyVolume</strong>、<strong>repairDisk</strong> 等</li><li>分区操作：如 <strong>splitPartitions</strong>、<strong>mergePartitions</strong> 等</li><li>其他：如 <strong>appleRAID</strong>、<strong>apfs</strong> 等</li></ul><h2 id="apfs"><a href="#apfs" class="headerlink" title="apfs"></a>apfs</h2><p>apfs模拟的是一个完整的硬盘(个人理解)</p><h3 id="列出apfs列表"><a href="#列出apfs列表" class="headerlink" title="列出apfs列表"></a>列出apfs列表</h3><pre class=" language-bash"><code class="language-bash">diskutil apfs list /dev/disk3</code></pre><h3 id="删除apfs容器"><a href="#删除apfs容器" class="headerlink" title="删除apfs容器"></a>删除apfs容器</h3><p>删除容器目标应该是以disk硬盘为目标</p><pre class=" language-bash"><code class="language-bash"> diskutil apfs deleteContainer disk3</code></pre><h2 id="HFS"><a href="#HFS" class="headerlink" title="HFS"></a>HFS</h2><h3 id="格式化-擦除整个磁盘格式化"><a href="#格式化-擦除整个磁盘格式化" class="headerlink" title="格式化/擦除整个磁盘格式化"></a>格式化/擦除整个磁盘格式化</h3><h4 id="eraseDisk"><a href="#eraseDisk" class="headerlink" title="eraseDisk"></a>eraseDisk</h4><pre class=" language-bash"><code class="language-bash">diskutil eraseDisk <span class="token operator">&lt;</span>format<span class="token operator">></span> <span class="token operator">&lt;</span>name<span class="token operator">></span> <span class="token punctuation">[</span>APM<span class="token operator">|</span>MBR<span class="token operator">|</span>GPT<span class="token punctuation">]</span> MountPoint<span class="token operator">|</span>DiskIdentifier<span class="token operator">|</span>DeviceNode</code></pre><p><em>format</em> 用于指定擦除数据后需要重新建立的文件系统类型。可以为 <em>%noformat%</em> 来跳过初始化文件系统的操作。其他支持的类型可以通过 <code>listFilesystems</code> 选项查看。</p><p>可以使用 <code>diskutil eraseDisk ExFAT StarkyDisk disk2</code> 命令将优盘数据擦除并格式化为 ExFAT 格式。</p><h4 id="eraseVolume"><a href="#eraseVolume" class="headerlink" title="eraseVolume"></a>eraseVolume</h4><p>完全擦除整个磁盘或某个磁盘分区，创建新的文件系统</p><h4 id="zeroDisk"><a href="#zeroDisk" class="headerlink" title="zeroDisk"></a>zeroDisk</h4><p>向整个磁盘或某个分区全部写入 ‘0’，该磁盘上的全部信息被抹除，同时也不再包含分区和文件系统信息</p><h3 id="创建磁盘分区"><a href="#创建磁盘分区" class="headerlink" title="创建磁盘分区"></a>创建磁盘分区</h3><pre class=" language-bash"><code class="language-bash">diskutil partitionDisk MountPoint<span class="token operator">|</span>DiskIdentifier<span class="token operator">|</span>DeviceNode        <span class="token punctuation">[</span>numberOfPartitions<span class="token punctuation">]</span> <span class="token punctuation">[</span>APM<span class="token operator">|</span>MBR<span class="token operator">|</span>GPT<span class="token punctuation">]</span>        <span class="token punctuation">[</span>part1Format part1Name part1Size part2Format part2Name part2Size         part3Format part3Name part3Size <span class="token punctuation">..</span>.<span class="token punctuation">]</span></code></pre><p>命令选项中的 <strong>Size</strong> 用来指定分区的大小（以<strong>扇区</strong>数计量），合法的值包括带有指定后缀的浮点数。其中的<strong>后缀</strong>有 B(ytes), S(512-byte-<br> blocks), K(ilobytes), M(egabytes), G(igabytes), T(erabytes), P(etabytes)，也可以是 % 来表示对整个磁盘的占比。<br> 最后一个分区会自动扩展到占用整个磁盘的剩余空间，如果想为最后一个分区指定固定的大小，可在其后再创建一个类型为『free space』的分区。</p><pre class=" language-dart"><code class="language-dart">➜  <span class="token operator">~</span> sudo diskutil partitionDisk disk2 <span class="token number">3</span> MBR MS<span class="token operator">-</span>DOS F01 3G JHFS<span class="token operator">+</span> F02 3G <span class="token string">"Free Space"</span> F03 <span class="token number">0</span>Started partitioning on disk2Unmounting diskCreating the partition mapWaiting <span class="token keyword">for</span> partitions to activateFormatting disk2s1 <span class="token operator">as</span> MS<span class="token operator">-</span><span class="token function">DOS</span> <span class="token punctuation">(</span>FAT<span class="token punctuation">)</span> <span class="token keyword">with</span> name F01<span class="token number">512</span> bytes per physical sector<span class="token operator">/</span>dev<span class="token operator">/</span>rdisk2s1<span class="token punctuation">:</span> <span class="token number">5847920</span> sectors <span class="token keyword">in</span> <span class="token number">730990</span> FAT32 <span class="token function">clusters</span> <span class="token punctuation">(</span><span class="token number">4096</span> bytes<span class="token operator">/</span>cluster<span class="token punctuation">)</span>bps<span class="token operator">=</span><span class="token number">512</span> spc<span class="token operator">=</span><span class="token number">8</span> res<span class="token operator">=</span><span class="token number">32</span> nft<span class="token operator">=</span><span class="token number">2</span> mid<span class="token operator">=</span><span class="token number">0xf8</span> spt<span class="token operator">=</span><span class="token number">32</span> hds<span class="token operator">=</span><span class="token number">255</span> hid<span class="token operator">=</span><span class="token number">2</span> drv<span class="token operator">=</span><span class="token number">0x80</span> bsec<span class="token operator">=</span><span class="token number">5859376</span> bspf<span class="token operator">=</span><span class="token number">5711</span> rdcl<span class="token operator">=</span><span class="token number">2</span> infs<span class="token operator">=</span><span class="token number">1</span> bkbs<span class="token operator">=</span><span class="token number">6</span>Mounting diskFormatting disk2s2 <span class="token operator">as</span> Mac OS <span class="token function">Extended</span> <span class="token punctuation">(</span>Journaled<span class="token punctuation">)</span> <span class="token keyword">with</span> name F02Initialized <span class="token operator">/</span>dev<span class="token operator">/</span>rdisk2s2 <span class="token operator">as</span> a <span class="token number">3</span> GB <span class="token keyword">case</span><span class="token operator">-</span>insensitive HFS Plus volume <span class="token keyword">with</span> a 8192k journalMounting diskFinished partitioning on disk2<span class="token operator">/</span>dev<span class="token operator">/</span><span class="token function">disk2</span> <span class="token punctuation">(</span><span class="token keyword">external</span><span class="token punctuation">,</span> physical<span class="token punctuation">)</span><span class="token punctuation">:</span>   #<span class="token punctuation">:</span>                       TYPE NAME                    SIZE       IDENTIFIER   <span class="token number">0</span><span class="token punctuation">:</span>     FDisk_partition_scheme                        <span class="token operator">*</span><span class="token number">7.8</span> GB     disk2   <span class="token number">1</span><span class="token punctuation">:</span>                 DOS_FAT_32 F01                     <span class="token number">3.0</span> GB     disk2s1   <span class="token number">2</span><span class="token punctuation">:</span>                  Apple_HFS F02                     <span class="token number">3.0</span> GB     disk2s2</code></pre><p>上面的命令在优盘（disk2）上创建了 3 个分区，第一个（F01）格式为 FAT32，大小是 3 Gb。第二个（F02）格式为 JHFS+，大小为 3 Gb。最后一个是『自由空间』，大小为剩余的容量。所以实际上只是分了两个区，整体的分区表类型为 MBR。</p><h3 id="分割-合并磁盘分区"><a href="#分割-合并磁盘分区" class="headerlink" title="分割/合并磁盘分区"></a>分割/合并磁盘分区</h3><p><em>splitPartition</em> 选项可以用来将已存在的某个分区再分割成数个更小的分区，注意原分区上的所有数据都会丢失。<br> 该选项的第一个参数为需要分割的分区的挂载点/标志符/设备节点，其余参数和使用 <em>partitionDisk</em> 时相同。</p><pre class=" language-dart"><code class="language-dart">➜  <span class="token operator">~</span> sudo diskutil list <span class="token operator">|</span> grep disk2<span class="token operator">/</span>dev<span class="token operator">/</span><span class="token function">disk2</span> <span class="token punctuation">(</span><span class="token keyword">external</span><span class="token punctuation">,</span> physical<span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token number">0</span><span class="token punctuation">:</span>      GUID_partition_scheme                        <span class="token operator">*</span><span class="token number">7.8</span> GB     disk2   <span class="token number">1</span><span class="token punctuation">:</span>                        EFI EFI                     <span class="token number">209.7</span> MB   disk2s1   <span class="token number">2</span><span class="token punctuation">:</span>                  Apple_HFS starky                  <span class="token number">7.5</span> GB     disk2s2➜  <span class="token operator">~</span> sudo diskutil splitPartition disk2s2 <span class="token number">2</span> MS<span class="token operator">-</span>DOS F01 3g JHFS<span class="token operator">+</span> F02 3gStarted partitioning on disk2s2 starkySplittingUnmounting diskWaiting <span class="token keyword">for</span> partitions to activateFormatting disk2s2 <span class="token operator">as</span> MS<span class="token operator">-</span><span class="token function">DOS</span> <span class="token punctuation">(</span>FAT<span class="token punctuation">)</span> <span class="token keyword">with</span> name F01<span class="token number">512</span> bytes per physical sector<span class="token operator">/</span>dev<span class="token operator">/</span>rdisk2s2<span class="token punctuation">:</span> <span class="token number">5845824</span> sectors <span class="token keyword">in</span> <span class="token number">730728</span> FAT32 <span class="token function">clusters</span> <span class="token punctuation">(</span><span class="token number">4096</span> bytes<span class="token operator">/</span>cluster<span class="token punctuation">)</span>bps<span class="token operator">=</span><span class="token number">512</span> spc<span class="token operator">=</span><span class="token number">8</span> res<span class="token operator">=</span><span class="token number">32</span> nft<span class="token operator">=</span><span class="token number">2</span> mid<span class="token operator">=</span><span class="token number">0xf8</span> spt<span class="token operator">=</span><span class="token number">32</span> hds<span class="token operator">=</span><span class="token number">255</span> hid<span class="token operator">=</span><span class="token number">411648</span> drv<span class="token operator">=</span><span class="token number">0x80</span> bsec<span class="token operator">=</span><span class="token number">5857280</span> bspf<span class="token operator">=</span><span class="token number">5709</span> rdcl<span class="token operator">=</span><span class="token number">2</span> infs<span class="token operator">=</span><span class="token number">1</span> bkbs<span class="token operator">=</span><span class="token number">6</span>Mounting diskFormatting disk2s3 <span class="token operator">as</span> Mac OS <span class="token function">Extended</span> <span class="token punctuation">(</span>Journaled<span class="token punctuation">)</span> <span class="token keyword">with</span> name F02Initialized <span class="token operator">/</span>dev<span class="token operator">/</span>rdisk2s3 <span class="token operator">as</span> a <span class="token number">4</span> GB <span class="token keyword">case</span><span class="token operator">-</span>insensitive HFS Plus volume <span class="token keyword">with</span> a 8192k journalMounting diskFinished partitioning on disk2s2 starky<span class="token operator">/</span>dev<span class="token operator">/</span><span class="token function">disk2</span> <span class="token punctuation">(</span><span class="token keyword">external</span><span class="token punctuation">,</span> physical<span class="token punctuation">)</span><span class="token punctuation">:</span>   #<span class="token punctuation">:</span>                       TYPE NAME                    SIZE       IDENTIFIER   <span class="token number">0</span><span class="token punctuation">:</span>      GUID_partition_scheme                        <span class="token operator">*</span><span class="token number">7.8</span> GB     disk2   <span class="token number">1</span><span class="token punctuation">:</span>                        EFI EFI                     <span class="token number">209.7</span> MB   disk2s1   <span class="token number">2</span><span class="token punctuation">:</span>       Microsoft Basic Data F01                     <span class="token number">3.0</span> GB     disk2s2   <span class="token number">3</span><span class="token punctuation">:</span>                  Apple_HFS F02                     <span class="token number">4.5</span> GB     disk2s3</code></pre><p><em>mergePartitions</em> 选项用来将多个已存在的分区合并为一个大的分区。该选项的格式为：</p><pre class=" language-dart"><code class="language-dart">diskutil mergePartitions <span class="token punctuation">[</span>force<span class="token punctuation">]</span> format name DiskIdentifier<span class="token operator">|</span>DeviceNode DiskIdentifier<span class="token operator">|</span>DeviceNode</code></pre><p>第一个分区参数为起始分区，第二个分区参数为结束分区。这两个分区<strong>之间</strong>的所有分区都将被合并。<br> 如果 <em>force</em> 选项没有被指定，且合并前的第一个分区是可调整大小的文件系统（如 JHFS+），则第一个分区上的数据会保留到合并后的分区。</p><pre class=" language-csharp"><code class="language-csharp">➜  <span class="token operator">~</span> sudo diskutil list <span class="token operator">|</span> grep disk2<span class="token operator">/</span>dev<span class="token operator">/</span><span class="token function">disk2</span> <span class="token punctuation">(</span>external<span class="token punctuation">,</span> physical<span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token number">0</span><span class="token punctuation">:</span>      GUID_partition_scheme                        <span class="token operator">*</span><span class="token number">7.8</span> GB     disk2   <span class="token number">1</span><span class="token punctuation">:</span>                        EFI EFI                     <span class="token number">209.7</span> MB   disk2s1   <span class="token number">2</span><span class="token punctuation">:</span>                  Apple_HFS F01                     <span class="token number">2.9</span> GB     disk2s2   <span class="token number">3</span><span class="token punctuation">:</span>       Microsoft Basic Data F02                     <span class="token number">4.5</span> GB     disk2s4➜  <span class="token operator">~</span> sudo diskutil mergePartitions JHFS<span class="token operator">+</span> Starky disk2s2 disk2s4Merging partitions <span class="token keyword">into</span> a <span class="token keyword">new</span> <span class="token class-name">partition</span>     Start partition<span class="token punctuation">:</span> disk2s2 F01     Finish partition<span class="token punctuation">:</span> disk2s4 F02Started partitioning on disk2Merging partitionsWaiting <span class="token keyword">for</span> partitions to activateGrowing diskFinished partitioning on disk2<span class="token operator">/</span>dev<span class="token operator">/</span><span class="token function">disk2</span> <span class="token punctuation">(</span>external<span class="token punctuation">,</span> physical<span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token preprocessor property">#:                       TYPE NAME                    SIZE       IDENTIFIER</span>   <span class="token number">0</span><span class="token punctuation">:</span>      GUID_partition_scheme                        <span class="token operator">*</span><span class="token number">7.8</span> GB     disk2   <span class="token number">1</span><span class="token punctuation">:</span>                        EFI EFI                     <span class="token number">209.7</span> MB   disk2s1   <span class="token number">2</span><span class="token punctuation">:</span>                  Apple_HFS F01                     <span class="token number">7.5</span> GB     disk2s2</code></pre><h3 id="调整分区大小（无损）"><a href="#调整分区大小（无损）" class="headerlink" title="调整分区大小（无损）"></a>调整分区大小（无损）</h3><p><em>resizeVolume</em> 选项可以<strong>无损</strong>调整（增加或缩减）分区大小。</p><p>将 disk2s2 分区缩减为 4g 大小，腾出的空间作为『free space』：</p><pre class=" language-dart"><code class="language-dart">➜  <span class="token operator">~</span> diskutil list <span class="token operator">|</span> grep disk2<span class="token operator">/</span>dev<span class="token operator">/</span><span class="token function">disk2</span> <span class="token punctuation">(</span><span class="token keyword">external</span><span class="token punctuation">,</span> physical<span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token number">0</span><span class="token punctuation">:</span>      GUID_partition_scheme                        <span class="token operator">*</span><span class="token number">7.8</span> GB     disk2   <span class="token number">1</span><span class="token punctuation">:</span>                        EFI EFI                     <span class="token number">209.7</span> MB   disk2s1   <span class="token number">2</span><span class="token punctuation">:</span>                  Apple_HFS F01                     <span class="token number">7.5</span> GB     disk2s2➜  <span class="token operator">~</span> sudo diskutil resizeVolume disk2s2 4gResizing to <span class="token number">4000000000</span> bytesStarted partitioning on disk2s2 F01Verifying the diskVerifying file systemVolume was successfully unmountedPerforming fsck_hfs <span class="token operator">-</span>fn <span class="token operator">-</span>x <span class="token operator">/</span>dev<span class="token operator">/</span>rdisk2s2Checking Journaled HFS Plus volumeChecking extents overflow fileChecking catalog fileChecking multi<span class="token operator">-</span>linked filesChecking catalog hierarchyChecking extended attributes fileChecking volume bitmapChecking volume informationThe volume F01 appears to be OKFile system check exit code <span class="token operator">is</span> <span class="token number">0</span>Restoring the original state found <span class="token operator">as</span> mountedResizingShrinking file systemModifying partition mapFinished partitioning on disk2s2 F01<span class="token operator">/</span>dev<span class="token operator">/</span><span class="token function">disk2</span> <span class="token punctuation">(</span><span class="token keyword">external</span><span class="token punctuation">,</span> physical<span class="token punctuation">)</span><span class="token punctuation">:</span>   #<span class="token punctuation">:</span>                       TYPE NAME                    SIZE       IDENTIFIER   <span class="token number">0</span><span class="token punctuation">:</span>      GUID_partition_scheme                        <span class="token operator">*</span><span class="token number">7.8</span> GB     disk2   <span class="token number">1</span><span class="token punctuation">:</span>                        EFI EFI                     <span class="token number">209.7</span> MB   disk2s1   <span class="token number">2</span><span class="token punctuation">:</span>                  Apple_HFS F01                     <span class="token number">4.0</span> GB     disk2s2</code></pre><p>将 disk2s2 分区扩展，并尽可能占用所有可用的自由空间。</p><pre class=" language-dart"><code class="language-dart">➜  <span class="token operator">~</span> sudo diskutil resizeVolume disk2s2 RResizing to full <span class="token function">size</span> <span class="token punctuation">(</span>fit to fill<span class="token punctuation">)</span>Started partitioning on disk2s2 F01Verifying the diskVerifying file systemVolume was successfully unmountedPerforming fsck_hfs <span class="token operator">-</span>fn <span class="token operator">-</span>x <span class="token operator">/</span>dev<span class="token operator">/</span>rdisk2s2Checking Journaled HFS Plus volumeChecking extents overflow fileChecking catalog fileChecking multi<span class="token operator">-</span>linked filesChecking catalog hierarchyChecking extended attributes fileChecking volume bitmapChecking volume informationThe volume F01 appears to be OKFile system check exit code <span class="token operator">is</span> <span class="token number">0</span>Restoring the original state found <span class="token operator">as</span> mountedResizingModifying partition mapGrowing file systemFinished partitioning on disk2s2 F01<span class="token operator">/</span>dev<span class="token operator">/</span><span class="token function">disk2</span> <span class="token punctuation">(</span><span class="token keyword">external</span><span class="token punctuation">,</span> physical<span class="token punctuation">)</span><span class="token punctuation">:</span>   #<span class="token punctuation">:</span>                       TYPE NAME                    SIZE       IDENTIFIER   <span class="token number">0</span><span class="token punctuation">:</span>      GUID_partition_scheme                        <span class="token operator">*</span><span class="token number">7.8</span> GB     disk2   <span class="token number">1</span><span class="token punctuation">:</span>                        EFI EFI                     <span class="token number">209.7</span> MB   disk2s1   <span class="token number">2</span><span class="token punctuation">:</span>                  Apple_HFS F01                     <span class="token number">7.5</span> GB     disk2s2</code></pre>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> macOS </tag>
            
            <tag> 分区 </tag>
            
            <tag> diskutil </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>install new system list</title>
      <link href="/2020/06/12/myself-install-new-system-list/"/>
      <url>/2020/06/12/myself-install-new-system-list/</url>
      
        <content type="html"><![CDATA[<h1 id="重新安装新系统准备List"><a href="#重新安装新系统准备List" class="headerlink" title="重新安装新系统准备List"></a>重新安装新系统准备List</h1><h2 id="备份系统"><a href="#备份系统" class="headerlink" title="备份系统"></a>备份系统</h2><h3 id="APP备份"><a href="#APP备份" class="headerlink" title="APP备份"></a>APP备份</h3><h3 id="APP-数据备份"><a href="#APP-数据备份" class="headerlink" title="APP 数据备份"></a>APP 数据备份</h3><pre><code>/Users/[user]/Library/Application Support/Users/[user]/Library/Containers</code></pre><h3 id="开发配置备份"><a href="#开发配置备份" class="headerlink" title="开发配置备份"></a>开发配置备份</h3><pre><code>~/.ssh.zshrc.gitconfigAndroidAndroidGeneralCodeAndroidStudioProjectsdecompileApkechatothercodeservertest</code></pre><h3 id="其他备份目录"><a href="#其他备份目录" class="headerlink" title="其他备份目录"></a>其他备份目录</h3><pre><code>ArchiveDocumentsMoviesMusic</code></pre><h2 id="安装系统后"><a href="#安装系统后" class="headerlink" title="安装系统后"></a>安装系统后</h2><h3 id="解决APP第三方开发者无法在MacOS-10-15-运行"><a href="#解决APP第三方开发者无法在MacOS-10-15-运行" class="headerlink" title="解决APP第三方开发者无法在MacOS 10.15 运行"></a>解决APP第三方开发者无法在MacOS 10.15 运行</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> xattr -r -d com.apple.quarantine</code></pre><p>解决APP认为自己不在/Application中</p><pre class=" language-bash"><code class="language-bash"> xattr -rc</code></pre><h3 id="黑苹果开启SSD-trim"><a href="#黑苹果开启SSD-trim" class="headerlink" title="黑苹果开启SSD trim"></a>黑苹果开启SSD trim</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> trimforce <span class="token function">enable</span></code></pre><h2 id="HomeBrew"><a href="#HomeBrew" class="headerlink" title="HomeBrew"></a>HomeBrew</h2><h3 id="安装homebrew"><a href="#安装homebrew" class="headerlink" title="安装homebrew"></a>安装homebrew</h3><pre class=" language-bash"><code class="language-bash">/bin/bash -c <span class="token string">"<span class="token variable"><span class="token variable">$(</span>curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh<span class="token variable">)</span></span>"</span></code></pre><h3 id="安装brew-cask"><a href="#安装brew-cask" class="headerlink" title="安装brew cask"></a>安装brew cask</h3><pre class=" language-bash"><code class="language-bash">brew cask</code></pre><h3 id="brew-历史版本"><a href="#brew-历史版本" class="headerlink" title="brew 历史版本"></a>brew 历史版本</h3><pre class=" language-bash"><code class="language-bash">brew tap homebrew/cask-versions</code></pre><h3 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h3><pre><code>brew search javabrew cask install java6brew cask install AdoptOpenJDK/openjdk/adoptopenjdk8brew cask install AdoptOpenJDK/openjdk/adoptopenjdk9brew cask install AdoptOpenJDK/openjdk/adoptopenjdk10brew cask install AdoptOpenJDK/openjdk/adoptopenjdk11brew cask install AdoptOpenJDK/openjdk/adoptopenjdk12brew cask install AdoptOpenJDK/openjdk/adoptopenjdk# 运行以下命令会安装 Oracle 提供的 Oracle JDK12brew cask install oracle-jdk# 在2019年5月## 该命令会安装由 Oracle 提供的 OpenJDK12brew cask install java## 而该命令则安装由 Oracle 提供的 OpenJDK11brew cask install java11brew cask install homebrew/cask-versions/java6</code></pre><h4 id="Java环境"><a href="#Java环境" class="headerlink" title="Java环境"></a>Java环境</h4><pre><code>export JDK6_HOME=&quot;/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home&quot;export JDK8_HOME=&quot;/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home&quot;</code></pre><h4 id="查看Macos-安装的Java版本"><a href="#查看Macos-安装的Java版本" class="headerlink" title="查看Macos 安装的Java版本"></a>查看Macos 安装的Java版本</h4><pre class=" language-bash"><code class="language-bash"> /usr/libexec/java_home -V</code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="安装python3-pip"><a href="#安装python3-pip" class="headerlink" title="安装python3 / pip"></a>安装python3 / pip</h3><pre class=" language-bash"><code class="language-bash">brew <span class="token function">install</span> python</code></pre><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> easy_install pip</code></pre><h3 id="安装ffmpeg"><a href="#安装ffmpeg" class="headerlink" title="安装ffmpeg"></a>安装ffmpeg</h3><p>第三方的ffmpeg 才可以自定义库</p><pre class=" language-bash"><code class="language-bash">brew tap varenc/ffmpegbrew <span class="token function">install</span> varenc/ffmpeg/ffmpegbrew update <span class="token operator">&amp;&amp;</span> brew upgrade ffmpegbrew upgrade --fetch-HEAD ffmpegbrew options varenc/homebrew-ffmpeg/ffmpeg</code></pre><h3 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h3><pre class=" language-bash"><code class="language-bash">brew <span class="token function">install</span> nodejs</code></pre><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> -g hexo-cli</code></pre><h3 id="安装VSCode"><a href="#安装VSCode" class="headerlink" title="安装VSCode"></a>安装VSCode</h3><pre><code>brew cask install visual-studio-code</code></pre><h3 id="安装iina"><a href="#安装iina" class="headerlink" title="安装iina"></a>安装iina</h3><pre><code>brew cask install iina</code></pre><h2 id="Android-Dev"><a href="#Android-Dev" class="headerlink" title="Android Dev"></a>Android Dev</h2><h3 id="国内Android索引"><a href="#国内Android索引" class="headerlink" title="国内Android索引"></a>国内Android索引</h3><p><a href="https://www.androiddevtools.cn/" target="_blank" rel="noopener">https://www.androiddevtools.cn/</a></p><h3 id="旧版NDK下载"><a href="#旧版NDK下载" class="headerlink" title="旧版NDK下载"></a>旧版NDK下载</h3><p><a href="https://developer.android.com/ndk/downloads/older_releases" target="_blank" rel="noopener">https://developer.android.com/ndk/downloads/older_releases</a></p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> system </tag>
            
            <tag> ready list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>curl总结</title>
      <link href="/2020/04/26/curl-summary/"/>
      <url>/2020/04/26/curl-summary/</url>
      
        <content type="html"><![CDATA[<h1 id="curl-参数详解"><a href="#curl-参数详解" class="headerlink" title="curl 参数详解"></a>curl 参数详解</h1><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-I/–head</td><td>只显示传输文档，经常用于测试连接本身</td></tr><tr><td>-o/–output</td><td>把输出写到该文件中，必须输入保存文件名</td></tr><tr><td>-O/–remote-name</td><td>把输出写到该文件中，保留远程文件的文件名</td></tr><tr><td>-F/–form</td><td>模拟表单提交</td></tr><tr><td>-s/–silent</td><td>静默模式，不输出任何东西</td></tr><tr><td>-S/–show-error</td><td>显示错误，在选项 -s 中，当 curl 出现错误时将显示</td></tr><tr><td>-L/–location</td><td>跟踪重定向</td></tr><tr><td>-f/–fail</td><td>不输出错误</td></tr><tr><td>-n/–netrc</td><td>从netrc文件中读取用户名和密码</td></tr><tr><td>–netrc-optional</td><td>使用 .netrc 或者 URL来覆盖-n</td></tr><tr><td>–ntlm</td><td>使用 HTTP NTLM 身份验证</td></tr><tr><td>-N/–no-buffer</td><td>禁用缓冲输出</td></tr><tr><td>-p/–proxytunnel</td><td>使用HTTP代理</td></tr><tr><td>–proxy-anyauth</td><td>选择任一代理身份验证方法</td></tr><tr><td>–proxy-basic</td><td>在代理上使用基本身份验证</td></tr><tr><td>–proxy-digest</td><td>在代理上使用数字身份验证</td></tr><tr><td>–proxy-ntlm</td><td>在代理上使用ntlm身份验证</td></tr><tr><td>-P/–ftp-port</td><td>使用端口地址，而不是使用PASV</td></tr><tr><td>-M/–manual</td><td>显示全手动</td></tr><tr><td>-Q/–quote</td><td>文件传输前，发送命令到服务器</td></tr><tr><td>-r/–range</td><td>检索来自HTTP/1.1或FTP服务器字节范围</td></tr><tr><td>–range-file</td><td>读取（SSL）的随机文件</td></tr><tr><td>-R/–remote-time</td><td>在本地生成文件时，保留远程文件时间</td></tr><tr><td>–retry</td><td>传输出现问题时，重试的次数</td></tr><tr><td>–retry-delay</td><td>传输出现问题时，设置重试间隔时间</td></tr><tr><td>–retry-max-time</td><td>传输出现问题时，设置最大重试时间</td></tr><tr><td>–socks4</td><td>用socks4代理给定主机和端口</td></tr><tr><td>–socks5</td><td>用socks5代理给定主机和端口</td></tr><tr><td>-t/–telnet-option</td><td>Telnet选项设置</td></tr><tr><td>–trace</td><td>对指定文件进行debug</td></tr><tr><td>–trace-ascii Like</td><td>跟踪但没有hex输出</td></tr><tr><td>–trace-time    跟踪/</td><td>详细输出时，添加时间戳</td></tr><tr><td>-T/–upload-file</td><td>上传文件</td></tr><tr><td>-u/–user</td><td>设置服务器的用户和密码</td></tr><tr><td>-U/–proxy-user</td><td>设置代理用户名和密码</td></tr><tr><td>-V/–version</td><td>显示版本信息</td></tr><tr><td>-w/–write-out [format]</td><td>什么输出完成后</td></tr><tr><td>-x/–proxy</td><td>在给定的端口上使用HTTP代理</td></tr><tr><td>-X/–request</td><td>指定什么命令</td></tr><tr><td>-y/–speed-time</td><td>放弃限速所要的时间。默认为30</td></tr><tr><td>-Y/–speed-limit</td><td>停止传输速度的限制，速度时间’秒</td></tr><tr><td>-z/–time-cond</td><td>传送时间设置</td></tr><tr><td>-0/–http1.0</td><td>使用HTTP 1.0</td></tr><tr><td>-1/–tlsv1</td><td>使用TLSv1（SSL）</td></tr><tr><td>-2/–sslv2</td><td>使用SSLv2的（SSL）</td></tr><tr><td>-3/–sslv3</td><td>使用的SSLv3（SSL）</td></tr><tr><td>–3p-quote</td><td>like -Q for the source URL for 3rd party transfer</td></tr><tr><td>–3p-url</td><td>使用url，进行第三方传送</td></tr><tr><td>–3p-user</td><td>使用用户名和密码，进行第三方传送</td></tr><tr><td>-4/–ipv4</td><td>使用IP4</td></tr><tr><td>-6/–ipv6</td><td>使用IP6</td></tr><tr><td>-#/–progress-bar</td><td>用进度条显示当前的传送状态</td></tr></tbody></table><h3 id="使用cookie文件"><a href="#使用cookie文件" class="headerlink" title="使用cookie文件"></a>使用cookie文件</h3><pre class=" language-sh"><code class="language-sh">curl -b ./cookie_c.txt  http://blog.mydomain.com/wp-admin</code></pre><h3 id="断点续传，-C-大写的"><a href="#断点续传，-C-大写的" class="headerlink" title="断点续传，-C(大写的)"></a>断点续传，<code>-C(大写的)</code></h3><pre class=" language-sh"><code class="language-sh">curl -C -O http://www.sina.com.cn</code></pre><h3 id="传送数据"><a href="#传送数据" class="headerlink" title="传送数据"></a>传送数据</h3><p>最好用登录页面测试，因为你传值过去后，回抓数据，你可以看到你传值有没有成功</p><pre class=" language-sh"><code class="language-sh">curl -d log=aaaa  http://blog.mydomain.com/login.php</code></pre><h3 id="显示抓取错误-f"><a href="#显示抓取错误-f" class="headerlink" title="显示抓取错误 -f"></a>显示抓取错误 <code>-f</code></h3><pre class=" language-sh"><code class="language-sh">curl -f http://www.sina.com.cn/asdfcurl: (22) The requested URL returned error: 404curl http://www.sina.com.cn/asdf</code></pre><h3 id="伪造来源地址，有的网站会判断，请求来源地址-e"><a href="#伪造来源地址，有的网站会判断，请求来源地址-e" class="headerlink" title="伪造来源地址，有的网站会判断，请求来源地址-e"></a>伪造来源地址，有的网站会判断，请求来源地址<code>-e</code></h3><pre class=" language-sh"><code class="language-sh">curl -e http://localhost http://www.sina.com.cn</code></pre><h3 id="当我们经常用curl去搞人家东西的时候，人家会把你的IP给屏蔽掉的-这个时候-我们可以用代理"><a href="#当我们经常用curl去搞人家东西的时候，人家会把你的IP给屏蔽掉的-这个时候-我们可以用代理" class="headerlink" title="当我们经常用curl去搞人家东西的时候，人家会把你的IP给屏蔽掉的,这个时候,我们可以用代理"></a>当我们经常用curl去搞人家东西的时候，人家会把你的IP给屏蔽掉的,这个时候,我们可以用代理</h3><pre class=" language-sh"><code class="language-sh">curl -x 10.10.90.83:80 -o home.html http://www.sina.com.cn</code></pre><h3 id="比较大的东西，我们可以分段下载"><a href="#比较大的东西，我们可以分段下载" class="headerlink" title="比较大的东西，我们可以分段下载"></a>比较大的东西，我们可以分段下载</h3><pre class=" language-sh"><code class="language-sh">curl -r 0-100 -o img.part1 http://mydomian.cn/thumb/xxx.jpg  % Total    % Received % Xferd  Average Speed  Time    Time    Time  Current                                Dload  Upload  Total  Spent    Left  Speed100  101  100  101    0    0  1926      0 --:--:-- --:--:-- --:--:--    0curl -r 100-200 -o img.part2 http://mydomian.cn/thumb/xxx.jpg  % Total    % Received % Xferd  Average Speed  Time    Time    Time  Current                                Dload  Upload  Total  Spent    Left  Speed100  101  100  101    0    0  3498      0 --:--:-- --:--:-- --:--:--  98kcurl -r 200- -o img.part3 http://mydomian.cn/thumb/xxx.jpg  % Total    % Received % Xferd  Average Speed  Time    Time    Time  Current                                Dload  Upload  Total  Spent    Left  Speed100 13515  100 13515    0    0  154k      0 --:--:-- --:--:-- --:--:--  280kll |grep img.part</code></pre><p>用的时候，把他们cat一下就OK了,<code>cat img.part* &gt;img.jpg</code></p><h3 id="不显示下载进度信息-s"><a href="#不显示下载进度信息-s" class="headerlink" title="不显示下载进度信息 -s"></a>不显示下载进度信息 <code>-s</code></h3><pre class=" language-sh"><code class="language-sh">curl -s -o aaa.jpg</code></pre><h3 id="显示下载进度条"><a href="#显示下载进度条" class="headerlink" title="显示下载进度条 -#"></a>显示下载进度条 <code>-#</code></h3><pre class=" language-sh"><code class="language-sh">curl -# -O  http://www.mydomain.com/linux/25002_3.html######################################################################## 100.0%</code></pre><h3 id="通过ftp下载文件"><a href="#通过ftp下载文件" class="headerlink" title="通过ftp下载文件"></a>通过ftp下载文件</h3><pre class=" language-sh"><code class="language-sh">curl -u 用户名:密码 -O http://blog.mydomain.com/demo/curtain/bbstudy_files/style.css% Total    % Received % Xferd  Average Speed  Time    Time    Time  CurrentDload  Upload  Total  Spent    Left  Speed101  1934  101  1934    0    0  3184      0 --:--:-- --:--:-- --:--:--  7136或者用下面的方式curl -O ftp://xukai:test@192.168.242.144:21/www/focus/enhouse/index.php  % Total    % Received % Xferd  Average Speed  Time    Time    Time  Current                                Dload  Upload  Total  Spent    Left  Speed100 87518  100 87518    0    0  2312k      0 --:--:-- --:--:-- --:--:-- 11.5M</code></pre><h3 id="通过ftp上传"><a href="#通过ftp上传" class="headerlink" title="通过ftp上传"></a>通过ftp上传</h3><pre class=" language-sh"><code class="language-sh">curl -T xukai.php ftp://xukai:test@192.168.242.144:21/www/focus/enhouse/  % Total    % Received % Xferd  Average Speed  Time    Time    Time  Current                                Dload  Upload  Total  Spent    Left  Speed100 87518    0    0  100 87518      0  2040k --:--:-- --:--:-- --:--:-- 8901k</code></pre><h3 id="用法收集"><a href="#用法收集" class="headerlink" title="用法收集"></a>用法收集</h3><h4 id="下载保存"><a href="#下载保存" class="headerlink" title="下载保存"></a>下载保存</h4><pre class=" language-sh"><code class="language-sh">$curl http://mydomain.net > index.html$curl -o index.html http://mydomain.net$curl -O http://mydomain.net/target.tar.gz</code></pre><h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><pre class=" language-sh"><code class="language-sh">$curl http://www.yahoo.com/login.cgi?user=nickname&password=12345</code></pre><h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><pre class=" language-sh"><code class="language-sh">$curl -d "user=nickname&password=12345" http://www.yahoo.com/login.cgi</code></pre><h4 id="POST-文件"><a href="#POST-文件" class="headerlink" title="POST 文件"></a>POST 文件</h4><pre class=" language-sh"><code class="language-sh">$curl -F upload=$localfile  -F $btn_name=$btn_value http://mydomain.net/~zzh/up_file.cgi</code></pre><h4 id="通过代理"><a href="#通过代理" class="headerlink" title="通过代理"></a>通过代理</h4><pre class=" language-sh"><code class="language-sh">$curl -x 123.45.67.89:1080 -o page.html http://mydomain.net</code></pre><h4 id="保存cookie"><a href="#保存cookie" class="headerlink" title="保存cookie"></a>保存cookie</h4><pre class=" language-sh"><code class="language-sh">$curl -x 123.45.67.89:1080 -o page1.html -D cookie0001.txt http://mydomain.net</code></pre><h4 id="使用cookie"><a href="#使用cookie" class="headerlink" title="使用cookie"></a>使用cookie</h4><pre class=" language-sh"><code class="language-sh">$curl -x 123.45.67.89:1080 -o page1.html -D cookie0002.txt -b cookie0001.txt http://mydomain.net</code></pre><h4 id="模仿浏览器"><a href="#模仿浏览器" class="headerlink" title="模仿浏览器"></a>模仿浏览器</h4><pre class=" language-sh"><code class="language-sh">$curl -A "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)" -x123.45.67.89:1080 -o page.html -D cookie0001.txt http://mydomain.net</code></pre><h4 id="伪造referer"><a href="#伪造referer" class="headerlink" title="伪造referer"></a>伪造referer</h4><pre class=" language-sh"><code class="language-sh">$curl -A "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)" -x123.45.67.89:1080 -e"mail.yahoo.com" -o page.html -D cookie0001.txt http://mydomain.net</code></pre><h3 id="高级下载功能"><a href="#高级下载功能" class="headerlink" title="高级下载功能"></a>高级下载功能</h3><h4 id="循环下载"><a href="#循环下载" class="headerlink" title="循环下载"></a>循环下载</h4><pre class=" language-sh"><code class="language-sh">$curl -O http://mydomain.net/~zzh/screen[1-10].JPG</code></pre><h4 id="循环（匹配）下载"><a href="#循环（匹配）下载" class="headerlink" title="循环（匹配）下载"></a>循环（匹配）下载</h4><pre class=" language-sh"><code class="language-sh">$curl -O http://mydomain.net/~{zzh,nick}/[001-201].JPG  # >like zzh/001.JPG</code></pre><h4 id="循环（引用）下载"><a href="#循环（引用）下载" class="headerlink" title="循环（引用）下载"></a>循环（引用）下载</h4><pre class=" language-sh"><code class="language-sh">$curl -o #2_#1.jpg http://mydomain.net/~{zzh,nick}/[001-201].JPG # like >001_zzh.jpg</code></pre><h4 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h4><pre class=" language-sh"><code class="language-sh">$curl -c -O http://mydomain.net/~zzh/screen1.JPG</code></pre><h4 id="分块下载"><a href="#分块下载" class="headerlink" title="分块下载"></a>分块下载</h4><pre class=" language-sh"><code class="language-sh">$curl -r  0 -10240  -o "zhao.part1"  http://mydomain.net/~zzh/zhao1.mp3 &\$curl -r 10241 -20480  -o "zhao.part1"  http://mydomain.net/~zzh/zhao1.mp3 &\$curl -r 20481 -40960  -o "zhao.part1"  http://mydomain.net/~zzh/zhao1.mp3 &\$curl -r 40961 - -o  "zhao.part1"  http://mydomain.net/~zzh/zhao1.mp3...$cat zhao.part* > zhao.mp3</code></pre>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> curl </tag>
            
            <tag> 总结 </tag>
            
            <tag> 详解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 项目 Build 总结</title>
      <link href="/2020/04/26/android-build/"/>
      <url>/2020/04/26/android-build/</url>
      
        <content type="html"><![CDATA[<h1 id="Android-项目-Build-总结"><a href="#Android-项目-Build-总结" class="headerlink" title="Android 项目 Build 总结"></a>Android 项目 Build 总结</h1><h2 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h2><h3 id="查询当前项目依赖"><a href="#查询当前项目依赖" class="headerlink" title="查询当前项目依赖"></a>查询当前项目依赖</h3><pre><code>./gradlew module:dependencies</code></pre><p>最后会询问是否生成在线的doc yes</p><pre><code>./gradlew build --scan</code></pre><h3 id="获得当前flavor-name"><a href="#获得当前flavor-name" class="headerlink" title="获得当前flavor name"></a>获得当前flavor name</h3><pre><code>import java.util.regex.Matcherimport java.util.regex.Patterndef getCurrentFlavor() {       Gradle gradle = getGradle()       String  tskReqStr = gradle.getStartParameter().getTaskRequests().toString()       Pattern pattern;       if( tskReqStr.contains( &quot;assemble&quot; ) )           pattern = Pattern.compile(&quot;assemble(\\w+)(Release|Debug)&quot;)       else           pattern = Pattern.compile(&quot;generate(\\w+)(Release|Debug)&quot;)       Matcher matcher = pattern.matcher( tskReqStr )       if( matcher.find() )           return matcher.group(1).toLowerCase()       else       {           println &quot;[error]NO MATCH FOUND&quot;           return &quot;&quot;;       }}</code></pre><h3 id="Gradle修改输出的文件夹名称"><a href="#Gradle修改输出的文件夹名称" class="headerlink" title="Gradle修改输出的文件夹名称"></a>Gradle修改输出的文件夹名称</h3><p>直接设置 起始目录是rootDir</p><pre><code>android.applicationVariants.all { variant -&gt;    variant.outputs.all {        variant.packageApplication.outputDirectory  = new File(variant.packageApplication.outputDirectory.absolutePath.replace(&quot;${variant.flavorName}&quot;,&quot;${variant.flavorName}_v${variant.mergedFlavor.versionName}&quot;))        outputFileName = &quot;v${variant.mergedFlavor.versionName}${variant.buildType.name}.apk&quot;.replaceAll(&quot;/&quot;, &quot;-&quot;)    }}</code></pre><h3 id="自动-versionCode"><a href="#自动-versionCode" class="headerlink" title="自动 versionCode"></a>自动 versionCode</h3><p>使用 Git 仓库的 commit 数量作为 versionCode。使用命令 <code>git rev-list --count</code> , revision 可以是 HEAD, master, 也可以是 commit hash. 更多 <code>git rev-list</code> 的<a href="https://git-scm.com/docs/git-rev-list/2.16.0" target="_blank" rel="noopener">用法</a>。</p><p>通常我们使用当前分支的 commit 数量：</p><pre><code>git rev-list --count HEAD</code></pre><p>也可以使用所有的 commit 数量：</p><pre><code>git rev-list --all --count</code></pre><p>在 Android Studio 中这样使用：</p><pre><code>def cmd = &#39;git rev-list HEAD --count&#39;def gitCommitCount = cmd.execute().text.trim().toInteger()android {    ...    defaultConfig {        ...        versionCode gitCommitCount    }}</code></pre><h3 id="自动-versionName"><a href="#自动-versionName" class="headerlink" title="自动 versionName"></a>自动 versionName</h3><p>使用 Git 的 tag 作为 versionName。</p><p>首先，需要在当前分支中的 commit 打上 tag，使用命令 <code>git tag</code> 如下：</p><pre><code>git tag 0.0.1</code></pre><p>然后使用命令 <code>git describe --tags</code> 获取当前的 tag.</p><p>在 Android Studio 中这样使用：</p><pre><code>def cmd = &#39;git describe --tags&#39;def gitTag = cmd.execute().text.trim()android {    ...    defaultConfig {        ...        versionName gitTag    }}</code></pre><p>在实际开发中，我们通常不会这样使用，tag 命名不适合用于 versionName.</p><h3 id="优雅的设置-APK-文件名"><a href="#优雅的设置-APK-文件名" class="headerlink" title="优雅的设置 APK 文件名"></a>优雅的设置 APK 文件名</h3><pre><code>android.applicationVariants.all { variant -&gt;    variant.outputs.all {          outputFileName = getApkName()    }}</code></pre><h3 id="gradle-读取local-properties"><a href="#gradle-读取local-properties" class="headerlink" title="gradle 读取local.properties"></a>gradle 读取local.properties</h3><pre class=" language-groovy"><code class="language-groovy"><span class="token keyword">def</span> <span class="token function">readProperties</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    File file <span class="token operator">=</span> rootProject<span class="token operator">.</span><span class="token function">file</span><span class="token punctuation">(</span><span class="token string">'local.properties'</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>file<span class="token operator">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        InputStream inputStream <span class="token operator">=</span> rootProject<span class="token operator">.</span><span class="token function">file</span><span class="token punctuation">(</span><span class="token string">'local.properties'</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token function">newDataInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        Properties properties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        properties<span class="token operator">.</span><span class="token function">load</span><span class="token punctuation">(</span>inputStream<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>properties<span class="token operator">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> properties<span class="token operator">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="打包APP并上传到测试渠道"><a href="#打包APP并上传到测试渠道" class="headerlink" title="打包APP并上传到测试渠道"></a>打包APP并上传到测试渠道</h2><h3 id="通过curl-上传文件"><a href="#通过curl-上传文件" class="headerlink" title="通过curl 上传文件"></a>通过curl 上传文件</h3><pre class=" language-shell"><code class="language-shell">curl -F "file=@build/outputs/apk/lowversion/debug/echatsdkdemo-1.0.38-lowVersion-debug.apk" -F "_api_key=key" -F "buildUpdateDescription=update" https://www.pgyer.com/apiv2/app/upload</code></pre><h3 id="gradle-设置apk输出"><a href="#gradle-设置apk输出" class="headerlink" title="gradle 设置apk输出"></a>gradle 设置apk输出</h3><p>在主gradle中，<code>buildscript</code>配置ext信息</p><pre class=" language-groovy"><code class="language-groovy">buildscript<span class="token punctuation">{</span>        ext <span class="token punctuation">{</span>        demoVersionCode <span class="token operator">=</span> <span class="token number">1039</span>        demoVersionName <span class="token operator">=</span> <span class="token string">"1.0.39"</span>        apiKey<span class="token operator">=</span><span class="token string">""</span>        pgyUpload<span class="token operator">=</span><span class="token string">"https://www.pgyer.com/apiv2/app/upload"</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在 application 工程的 <code>build.gradle</code> 中修改 apk 文件名</p><pre><code>productFlavors {        offline {            versionName getVersionName(&quot;offline&quot;) //修改 versionName        }                lowversion {            minSdkVersion 15            versionName getVersionName(&quot;lowversion&quot;)        }        online {            versionName demoVersionName        }        admin {            versionName versionName getVersionName(&quot;管理员&quot;) //修改 versionName        }}android.applicationVariants.all { variant -&gt;    variant.outputs.all {        outputFileName = getApkName(variant.versionName)    }}</code></pre><p>根据Flavor和debug模式等，手动配置apk路径供脚本上传</p><pre class=" language-groovy"><code class="language-groovy"><span class="token keyword">def</span> <span class="token function">getVersionName</span><span class="token punctuation">(</span>String suffix<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>suffix <span class="token operator">==</span> null <span class="token operator">||</span> suffix<span class="token operator">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> String<span class="token operator">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> demoVersionName<span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> String<span class="token operator">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%s.%s"</span><span class="token punctuation">,</span> demoVersionName<span class="token punctuation">,</span> suffix<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">def</span> <span class="token function">getApkName</span><span class="token punctuation">(</span>String versionName<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> String<span class="token operator">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"appName-v%s-%s.apk"</span><span class="token punctuation">,</span> versionName<span class="token punctuation">,</span> <span class="token function">releaseTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">def</span> <span class="token function">releaseTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd"</span><span class="token punctuation">,</span> TimeZone<span class="token operator">.</span><span class="token function">getTimeZone</span><span class="token punctuation">(</span><span class="token string">"UTC"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">def</span> <span class="token function">getUpdateDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">'update'</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">def</span> <span class="token function">uploadPGY</span><span class="token punctuation">(</span>String filePath<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">def</span> stdout <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    exec <span class="token punctuation">{</span>        executable <span class="token operator">=</span> <span class="token string">'curl'</span>        args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'-F'</span><span class="token punctuation">,</span> <span class="token string">"file=@${filePath}"</span><span class="token punctuation">,</span> <span class="token string">'-F'</span><span class="token punctuation">,</span> <span class="token string">"_api_key=${apiKey}"</span>                <span class="token punctuation">,</span> <span class="token string">'-F'</span><span class="token punctuation">,</span> <span class="token string">"buildUpdateDescription=${getUpdateDescription()}"</span><span class="token punctuation">,</span> pgyUpload<span class="token punctuation">]</span>        standardOutput <span class="token operator">=</span> stdout    <span class="token punctuation">}</span>    String output <span class="token operator">=</span> stdout<span class="token operator">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> parsedJson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">groovy<span class="token punctuation">.</span>json<span class="token punctuation">.</span>JsonSlurper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token function">parseText</span><span class="token punctuation">(</span>output<span class="token punctuation">)</span>    println parsedJson<span class="token operator">.</span>data<span class="token operator">.</span>buildQRCodeURL    println <span class="token string">"版本号："</span> <span class="token operator">+</span> parsedJson<span class="token operator">.</span>data<span class="token operator">.</span>buildVersion<span class="token operator">+</span><span class="token string">" \n"</span>    println <span class="token string">""</span>    println output<span class="token punctuation">}</span><span class="token keyword">def</span> lowversion <span class="token operator">=</span> <span class="token string">"${projectDir.absolutePath}/build/outputs/apk/lowversion/%s/${getApkName(getVersionName("</span>lowversion<span class="token string">"))}"</span><span class="token keyword">def</span> <span class="token function">getApkPath</span><span class="token punctuation">(</span>String path<span class="token punctuation">,</span> String type<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> String<span class="token operator">.</span><span class="token function">format</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">}</span>task <span class="token function">uploadLowversionDebugApk</span><span class="token punctuation">(</span>dependsOn<span class="token punctuation">:</span> <span class="token string">'assembleLowversionDebug'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    doLast <span class="token punctuation">{</span>        <span class="token function">uploadPGY</span><span class="token punctuation">(</span><span class="token function">getApkPath</span><span class="token punctuation">(</span>lowversion<span class="token punctuation">,</span> <span class="token string">"debug"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="打包加固"><a href="#打包加固" class="headerlink" title="打包加固"></a>打包加固</h3><p><a href="https://juejin.im/post/5c977ead6fb9a070ea79d3f6" target="_blank" rel="noopener">https://juejin.im/post/5c977ead6fb9a070ea79d3f6</a></p><h2 id="Docker-打包"><a href="#Docker-打包" class="headerlink" title="Docker 打包"></a>Docker 打包</h2><pre class=" language-sh"><code class="language-sh">docker run --rm -v ${PWD}:/build -w /build circleci/android:api-29 bash -c "./gradlew assembleDebug"</code></pre><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>Android:api-29</p><p><a href="https://github.com/CircleCI-Public/circleci-dockerfiles/blob/master/android/images/api-29/Dockerfile" target="_blank" rel="noopener">https://github.com/CircleCI-Public/circleci-dockerfiles/blob/master/android/images/api-29/Dockerfile</a></p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Gradle </tag>
            
            <tag> 脚本 </tag>
            
            <tag> 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Custom Web 总结</title>
      <link href="/2020/04/26/web/"/>
      <url>/2020/04/26/web/</url>
      
        <content type="html"><![CDATA[<h1 id="Custom-Web-总结"><a href="#Custom-Web-总结" class="headerlink" title="Custom Web 总结"></a>Custom Web 总结</h1><h2 id="SSL-证书"><a href="#SSL-证书" class="headerlink" title="SSL 证书"></a>SSL 证书</h2><pre><code>export CF_Email=&quot;123123213@qq.com&quot;export CF_Key=&quot;12345667&quot;~/.acme.sh/acme.sh --issue --installcert -d [域名] --dns dns_cf --key-file /usr/local/nginx/conf/ssl/hw251.icu/hw251.icu.key --fullchain-file /usr/local/nginx/conf/ssl/hw251.icu/fullchain.cer</code></pre>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> https </tag>
            
            <tag> ssl </tag>
            
            <tag> tls </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络-面试</title>
      <link href="/2020/04/02/network-interview/"/>
      <url>/2020/04/02/network-interview/</url>
      
        <content type="html"><![CDATA[<h1 id="Android面试之网络"><a href="#Android面试之网络" class="headerlink" title="Android面试之网络"></a>Android面试之网络</h1><p>本文是<a href="https://juejin.im/post/5af82ee1f265da0b934865ba" target="_blank" rel="noopener">Android面试题整理</a>中的一篇，结合右下角目录食用更佳</p><h3 id="1-计算机网络的分层"><a href="#1-计算机网络的分层" class="headerlink" title="1. 计算机网络的分层"></a>1. <a href="https://blog.csdn.net/qq_29817411/article/details/51802147" target="_blank" rel="noopener">计算机网络的分层</a></h3><p>按照不同组织的标准和规范，可以有不同的分层方式</p><h4 id="OSI七层"><a href="#OSI七层" class="headerlink" title="OSI七层"></a>OSI七层</h4><blockquote><p>应用层、表示层、会话层、运输层、网络层、数据链路层、物理层</p></blockquote><p><img src="1.gif" alt=""></p><h4 id="TCP-IP（四层）"><a href="#TCP-IP（四层）" class="headerlink" title="TCP/IP（四层）"></a>TCP/IP（四层）</h4><blockquote><p>应用层、传输层、网络层、网络接口层</p></blockquote><h4 id="五层协议"><a href="#五层协议" class="headerlink" title="五层协议"></a>五层协议</h4><blockquote><ol><li>应用层：为操作系统或网络应用程序提供访问网络服务的接口；通过应用进程间的交互来完成特定网络应用，应用层协议定义的是应用进程间通信和交互规则。不同的网络应用层有不同的应用层协议，如：万维网应用的HTTP协议，电子邮件的SMTP协议，支持文件传送的FTP协议，应用层交互的数据单元称为报文。当不同的应用进程数据通信或者数据交换时，就去调用应用层的不同协议实体，让这些实体去调用TCP或者UDP层服务来进行网络传输</li><li>传输层：向两个主机中应用进程之间的通信提供通用的数据传输服务。应用进程以利用该服务传送应用层报文。运输层使用以下两种协议：传输控制协议TCP（提供面向连接的、可靠的数据传输服务，其数据传输的单位是报文段）；用户数据报协议UDP（提供无连接的、尽最大努力的数据传输服务，不保证数据传输的可靠性，单位是用户数据报）；</li><li>网络层： 数据报封装和路由寻址功能 网络互连层的主要功能是寻址和对数据报的封装以及重要的路由选择功能。 这些功能大部分都是由IP协议来完成的，再加上地址解析协议（Address Resolution Protocol，ARP）、因特网控制报文协议（Internet Control Message Protocol，ICMP）等协议从旁协助，所以IP协议是本层众多实体中的核心。下面简单介绍这几个协议。 <strong>网际协议（Internet Protocol，IP）。该协议是一个无连接的协议，主要负责将数据报从源结点转发到目的结点。也就是说，IP协议通过对每个数据报中都有的源地址和目的地址进行分析，然后进行路由选择（即选择一条到达目标的最佳路径），最后再转发到目的地。</strong>需要注意的是：IP协议只是负责对数据进行转发，并不对数据进行检查。也就是说，它不负责数据的可靠性，这样设计的主要目的是提高IP协议传送和转发数据的效率。 地址解析协议（Address Resolution Protocol，ARP）。该协议主要负责将TCP/IP网络中的IP地址解析和转换成计算机的物理地址，以便于物理设备（如网卡）按该地址来接收数据。 反向地址解析协议（Reverse Address Resolution Protocol，RARP）。该协议的作用与ARP的作用相反，它主要负责将设备的物理地址解析和转换成IP地址。 因特网控制报文协议（Internet Control Message Protocol，ICMP）。该协议主要负责发送和传递包含控制信息的数据报，这些控制信息包括哪台计算机出了什么错误、网络路由出现了什么错误等内容</li><li>数据链路层 ：两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议，数据链路层将网络层交下来IP数据报组装成数据帧，在两个相邻节点间的链路上传送帧；数据帧：（所谓数据帧（Data frame），就是数据链路层的协议数据单元，它包括三部分：帧头，数据部分，帧尾。其中，帧头和帧尾包含一些必要的控制信息，比如同步信息、地址信息、差错控制信息等；数据部分则包含网络层传下来的数据，比如IP数据包）</li><li>物理层：物理层上所传数据的单位是比特，确定要连接电缆的插头应当有多少根引脚，以及各条引脚应如何连接。传递信息所利用的是一些物理媒体，如电缆、光缆、无线信道等，并不在物理层协议之内而是在物理层协议的下面</li></ol></blockquote><h3 id="2-TCP与UDP的区别"><a href="#2-TCP与UDP的区别" class="headerlink" title="2. TCP与UDP的区别"></a>2. TCP与UDP的区别</h3><blockquote><ol><li>TCP协议是一种可靠的、面向连接的协议:保证通信主机之间有可靠的字节流传输，完成流量控制功能，协调收发双方的发送与接收速度，达到正确传输的目的</li><li>UDP是一种不可靠、无连接的协议:其特点是协议简单、额外开销小、效率较高，但是不能保证传输是否正确</li></ol></blockquote><h3 id="3-TCP对应的协议和UDP对应的协议"><a href="#3-TCP对应的协议和UDP对应的协议" class="headerlink" title="3. TCP对应的协议和UDP对应的协议"></a>3. TCP对应的协议和UDP对应的协议</h3><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><blockquote><ol><li>HTTP协议：从Web服务器传输超文本到本地浏览器的传送协议，默认使用80端口。</li><li>FTP：文件传输协议，默认使用21端口。</li><li>SMTP：简单邮件传送协议，用于发送邮件，默认使用25号端口。</li><li>POP3：和SMTP对应，POP3用于接收邮件，默认使用110端口</li><li>Telnet：一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务，默认使用23端口</li></ol></blockquote><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><blockquote><ol><li>DNS：域名解析服务，将域名地址转换为IP地址，默认使用53号端口。</li><li>TFTP(Trival File Transfer Protocal)：简单文件传输协议，默认使用69号端口。</li><li>SNMP：简单网络管理协议，默认使用161号端口，是用来管理网络设备的。</li></ol></blockquote><h3 id="4-TCP的报文段"><a href="#4-TCP的报文段" class="headerlink" title="4. TCP的报文段"></a>4. TCP的报文段</h3><p>TCP是一种面向连接的、可靠的传输层协议，通过TCP报文段进行传输，报文段分为头部和数据两个部分，头部包含了此报文段的一些基本信息，基本格式如下图。</p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="428" height="378"></svg>)</p><blockquote><ol><li>原端口和目的端口：即应用程序在客户端和服务器端所对应的端口号</li><li>序号（seq）和确认序号（ack）：是TCP可靠传输的关键部分。序号是本报文段发送的数据组的第一个字节的序号。在TCP传送的流中，每一个字节一个序号。e.g.一个报文段的序号为300，此报文段数据部分共有100字节，则下一个报文段的序号为400。所以序号确保了TCP传输的有序性。确认号，即ACK，指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。确认号只有当ACK标志为1时才有效。比如建立连接时，SYN报文的ACK标志位为0。</li><li>数据偏移／首部长度：表明报文段头部的长度。由于首部可能含有可选项内容，因此TCP报头的长度是不确定的，报头不包含任何任选字段则长度为20字节，4位首部长度字段所能表示的最大值为1111，转化为10进制为15，15*32/8 = 60，故报头最大长度为60字节。首部长度也叫数据偏移，是因为首部长度实际上指示了数据区在报文段中的起始偏移值。</li><li>保留：为将来定义新的用途保留，现在一般置0。</li><li>控制位：URG ACK PSH RST SYN FIN，共6个，每一个标志位表示一个控制功能，0无效，1有效<ol><li>URG：紧急指针标志，为1时表示紧急指针有效，为0则忽略紧急指针。</li><li>ACK：确认序号标志，为1时表示确认号有效，为0表示报文中不含确认信息，忽略确认号字段。</li><li>PSH：push标志，为1表示是带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。</li><li>RST：重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者用于拒绝非法的报文段和拒绝连接请求</li><li>SYN：同步序号，用于建立连接过程，在连接请求中，SYN=1和ACK=0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN=1和ACK=1。</li><li>FIN：finish标志，用于释放连接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。</li></ol></li><li>窗口：滑动窗口大小，用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小时一个16bit字段，因而窗口大小最大为65535。</li><li>校验和：奇偶校验，此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得。由发送端计算和存储，并由接收端进行验证</li><li>紧急指针：指向后面是优先数据的字节，在URG标志设置了时才有效。如果URG标志没有被设置，紧急域作为填充。加快处理标示为紧急的数据段。</li></ol></blockquote><h3 id="5-TCP三次握手"><a href="#5-TCP三次握手" class="headerlink" title="5. TCP三次握手"></a>5. <a href="https://www.jianshu.com/p/ef892323e68f" target="_blank" rel="noopener">TCP三次握手</a></h3><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="517" height="304"></svg>)</p><p>三次握手:TCP是通过报文段进行通信的，在建立TCP连接过程中，需要客户端和服务端总共发送3个报文段以确认连接的建立。</p><blockquote><ol><li>第一次握手：Client将标志位SYN置为1，随机产生一个序号（seq）J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</li><li>第二次握手：Server接收到报文段，生成一个新的报文段发送给Client，新报文段中：SYN = 1，ACK = 1，序号（seq）= J+1，确认序号（ack） = k（k为随机生成）；Server进入SYN_RCVD状态</li><li>第三次握手：Client收到报文段，对报文段进行校验（ACK是否为1，ack是否为J+1），校验通过生成一个新的报文段发送给Server：ACK = 1，ack = K+1，此时Client进入ESTABLISHED状态；Server对接收到的报文段校验，校验通过进入ESTABLISHED状态。</li></ol></blockquote><h3 id="6-TCP为什么是三次握手不是两次"><a href="#6-TCP为什么是三次握手不是两次" class="headerlink" title="6. TCP为什么是三次握手不是两次"></a>6. TCP为什么是三次握手不是两次</h3><blockquote><p>TCP的三次握手最主要是防止已过期的连接再次传到被连接的主机：如果使两次握手，有可能能第一次握手客户端发送的报文段过了很久才到达服务器端，此时客户端已经不需要连接了，如果服务器端建立了连接，就会造成服务器资源的浪费</p></blockquote><h3 id="7-TCP四次挥手"><a href="#7-TCP四次挥手" class="headerlink" title="7. TCP四次挥手"></a>7. TCP四次挥手</h3><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="507" height="323"></svg>)</p><p>由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。</p><blockquote><ol><li>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态</li><li>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。</li><li>第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</li><li>第四次挥手:Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</li></ol></blockquote><h3 id="8-挥手中TCP为什么要等待终止"><a href="#8-挥手中TCP为什么要等待终止" class="headerlink" title="8. 挥手中TCP为什么要等待终止"></a>8. <a href="https://www.jianshu.com/p/50b6bbeea81f" target="_blank" rel="noopener">挥手中TCP为什么要等待终止</a></h3><blockquote><ol><li>假如 Client 最后的 ACK 报文段丢失了，这时 Server 就会重新发送 FIN+ACK 报文给 Client，如果 Client 不等待 2MSL 直接关闭连接，那么 Server 就会一直处于 LAST-ACK 状态，造成了 Server 的资源浪费。而等待 2MSL，Client 就会再次收到 Server 的 FIN+ACK 报文，然后重新给 Server 发送 ACK 报文，确保双方都确认要关闭连接。</li><li>假如 ACK 报文段没有丢失，也是在网络中滞留了，这 2MSL 的等待时间可以让滞留的报文传到 Server，保证本连接持续的时间内所生产的报文都从网络中消失，以免影响下一次连接。还有如果不等待 2MSL ，报文滞留也可能导致 Server 资源浪费，原因同 (1)。</li></ol></blockquote><h3 id="9-为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"><a href="#9-为什么建立连接是三次握手，而关闭连接却是四次挥手呢？" class="headerlink" title="9. 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"></a>9. 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</h3><blockquote><p>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。</p></blockquote><h3 id="10-TCP流量控制：滑动窗口"><a href="#10-TCP流量控制：滑动窗口" class="headerlink" title="10. TCP流量控制：滑动窗口"></a>10. TCP流量控制：<a href="https://www.zhihu.com/question/32255109" target="_blank" rel="noopener">滑动窗口</a></h3><blockquote><ol><li>所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收</li><li>每次Client返回的ACK都会告知Server当前Client窗口的大小，Server会根据窗口的大小来控制发送数据和向前滑动</li></ol></blockquote><h3 id="11-TCP的拥塞控制"><a href="#11-TCP的拥塞控制" class="headerlink" title="11. TCP的拥塞控制"></a>11. <a href="https://www.zhihu.com/question/264518499/answer/315348958" target="_blank" rel="noopener">TCP的拥塞控制</a></h3><p>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提：网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。</p><blockquote><p>拥塞控制方法: 慢开始( slow-start )和拥塞避免( congestion avoidance ) 发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口的大小。 发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</p><ol><li>慢开始算法：每经过一个传输轮次，拥塞窗口 cwnd 就加倍。慢开始的”慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd=1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。 为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量（如何设置ssthresh）。慢开始门限ssthresh的用法如下： 当 cwnd &lt; ssthresh 时，使用上述的慢开始算法。 当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。 当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法。</li><li>拥塞避免算法：让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</li></ol><p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p><p>快重传算法：要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。 快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器到期。<br>快恢复过程 1.当发送方连续收到三个重复确认，就执行”乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。 2.由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（”加法增大”），使拥塞窗口缓慢地线性增大。</p></blockquote><h3 id="12-在浏览器中输入www-baidu-com-后执行的全部过程"><a href="#12-在浏览器中输入www-baidu-com-后执行的全部过程" class="headerlink" title="12. 在浏览器中输入www.baidu.com 后执行的全部过程"></a>12. 在浏览器中输入<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 后执行的全部过程</h3><blockquote><ol><li>客户端浏览器请求DNS服务器解析域名<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 对应的IP地址，然后通过这个IP地址和默认端口80，和服务器建立TCP连接，连接建立之后通过TCP将HTTP会话封装成数据包。</li><li>在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口（如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口）然后使用IP层的IP地址查找目的端。</li><li>在客户端的网络层，通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，主要是通过查找路由表来决定通过哪个路径到达服务器。</li><li>在客户端的链路层，数据包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP（地址解析协议：将ip地址解析成物理地址）的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。</li></ol></blockquote><h3 id="13-HTTP协议包括哪些请求？"><a href="#13-HTTP协议包括哪些请求？" class="headerlink" title="13. HTTP协议包括哪些请求？"></a>13. HTTP协议包括哪些请求？</h3><blockquote><p>常用的请求有：get，post，update，delete，head，options。GET：请求读取由URL所标志的数据 POST：给服务器添加或者更新数据 PUT：在给定的URL下存储一个文档 DELETE：删除给定的URL所标志的资源 OPTIONS：服务器针对特定资源所支持的HTTP请求方法 HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息</p></blockquote><h3 id="HTTP中POST与GET的区别"><a href="#HTTP中POST与GET的区别" class="headerlink" title="HTTP中POST与GET的区别"></a>HTTP中POST与GET的区别</h3><blockquote><ol><li>GET是将请求参数加到URL中，POST是将请求数据放在请求体中。</li><li>GET传送的数据量较小，不能超过2KB(1024字节?)，POST传送的数据量较大，默认为不受限制。</li></ol></blockquote><h3 id="14-HTTP协议的格式"><a href="#14-HTTP协议的格式" class="headerlink" title="14. HTTP协议的格式"></a>14. <a href="https://www.cnblogs.com/ranyonsue/p/5984001.html" target="_blank" rel="noopener">HTTP协议的格式</a></h3><h4 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h4><blockquote><ol><li>请求行：三个部分组成：第一部分是请求方法，第二部分是请求网址，第三部分是HTTP版本</li><li>请求头：请求头(request header) ；普通头(general header) ；实体头(entity header)</li><li>内容：通常来说，由于GET请求往往不包含内容实体，因此也不会有实体头。 第三部分内容只在POST请求中存在，因为GET请求并不包含任何实体</li></ol></blockquote><h4 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h4><blockquote><ol><li>状态行：第一部分是HTTP版本，第二部分是响应状态码，第三部分是状态码的描述</li><li>HTTP头：响应头(response header) ；普通头(general header) ；实体头(entity header)</li><li>内容：响应内容就是HTTP请求所请求的信息。这个信息可以是一个HTML，也可以是一个图片</li></ol></blockquote><h3 id="15-HTTP缓存"><a href="#15-HTTP缓存" class="headerlink" title="15. HTTP缓存"></a>15. HTTP缓存</h3><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="606" height="479"></svg>)</p><p>####HTTP缓存的处理流程：</p><blockquote><ol><li>请求处理 用户发起一个http请求，缓存获取到URL，根据URL查找是否有匹配的副本，这个副本可能在内存中，也可能在本地磁盘。</li><li>新鲜度检测 如果缓存中存在所请求资源的副本，则进行新鲜度检测。新鲜度检测举个简单的例子，我们在商店买了一瓶汽水，汽水瓶上肯定会标有过期时间，我们会根据这个过期时间和现在的时间做对比，看看饮料过期了没，如果没过期，我们正常喝就行了，如果已经过期，我们肯定要找商家。其实这就是一个新鲜度检测的过程，HTTP请求的新鲜度检测流程也是这样的，HTTP发起一个请求时，发现缓存中有相应的副本，接着就会检查这个副本有没有过期，如果没有过期，直接使用。如果已经过期，则进行再验证。</li><li>服务器再验证 缓存中的文档过期了并不代表它和服务器上的不一样，所以这个时候就需要问问服务器，过期的这段时间里这个文档到底有没有改变。如果改变了，缓存就会获取一份新的文档副本，然后发送给客户端。如果没有改变，缓存只需要获取新的首部，包括一个新的过期时间，并对缓存中的首部更新。</li><li>创建响应并返回 我们希望缓存看起来就像是来自原始服务器一样，缓存将已缓存的服务器响应首部作为响应首部，发送给客户端。</li></ol><p>扩展（缓存保质期的实现）：HTTP中，通过Cache-Control首部和Expires首部为文档指定了过期时间，通过对过期时间的判断，缓存就可以知道文档是不是在保质期内。Expires首部和Cache-Control:max-age 首部都是来告诉缓存文档有没有过期，为什么需要两个响应首部来做这件简单的事情了？其实这一切都是历史原因，Expires首部是HTTP 1.0中提出来的，因为他使用的是绝对日期，如果服务端和客户端时钟不同步的话（实际上这种情况非常常见），缓存可能就会认为文档已经过了保质期。 HTTP 1.1为了修正这个问题，引入了Cache-Control:max-age 首部，这个首部使用相对时间来控制保质期。</p></blockquote><h3 id="16-Http和Socket区别"><a href="#16-Http和Socket区别" class="headerlink" title="16. Http和Socket区别"></a>16. <a href="https://www.cnblogs.com/embedded-linux/p/6261894.html" target="_blank" rel="noopener">Http和Socket区别</a></h3><blockquote><ol><li>Http是一个协议，Socket是一个接口</li><li>Http可能是基于Socket的</li><li>Socket可以维持一个长连接，http是请求响应式，通常Socket效率高</li></ol></blockquote><h3 id="17-Http1-0-1-1-2-0区别"><a href="#17-Http1-0-1-1-2-0区别" class="headerlink" title="17. Http1.0 /1.1/2.0区别"></a>17. <a href="https://www.cnblogs.com/heluan/p/8620312.html" target="_blank" rel="noopener">Http1.0 /1.1/2.0区别</a></h3><blockquote><ol><li>1.1相对于1.0：<ol><li>支持长连接</li><li>增加了host域</li><li>增加了range头域，支持断点续传</li></ol></li><li>2.0 相对于1.x：<ol><li>支持多路复用</li><li>采用二进制分帧</li><li>首部压缩</li><li>服务器推送</li></ol></li></ol></blockquote><h3 id="18-HTTPS"><a href="#18-HTTPS" class="headerlink" title="18. HTTPS"></a>18. <a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">HTTPS</a></h3><p>HTTPS是安全版本的HTTP，基于SSL加密。以下是SSL建立过程：</p><blockquote><ol><li>客户端给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法</li><li>服务器确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）</li><li>客户端确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给服务器</li><li>服务器使用自己的私钥，获取客户端丝发来的随机数（即Premaster secret）</li><li>客户端和服务器根据约定的加密方法，使用前面的三个随机数，生成”对话密钥”（session key），用来加密接下来的整个对话过程</li></ol></blockquote><h3 id="19-COOKIE和SESSION有什么区别"><a href="#19-COOKIE和SESSION有什么区别" class="headerlink" title="19. COOKIE和SESSION有什么区别"></a>19. <a href="https://www.zhihu.com/question/19786827" target="_blank" rel="noopener">COOKIE和SESSION有什么区别</a></h3><blockquote><ol><li>因为HTTP是无状态的，所以需要某种机制识别用户</li><li>Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；</li><li>Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。</li></ol></blockquote><h3 id="20-Http-状态码"><a href="#20-Http-状态码" class="headerlink" title="20. Http 状态码"></a>20. <a href="https://baike.baidu.com/item/HTTP状态码/5053660?fr=aladdin" target="_blank" rel="noopener">Http 状态码</a></h3><blockquote><ol><li>1 ：继续</li><li>2 ：成功</li><li>3 ：重定向</li><li>4 ：请求错误</li><li>5： 服务器内部错误</li></ol></blockquote><h3 id="21-常见请求和响应头"><a href="#21-常见请求和响应头" class="headerlink" title="21. 常见请求和响应头"></a>21. <a href="https://blog.csdn.net/qq_30553235/article/details/79282113" target="_blank" rel="noopener">常见请求和响应头</a></h3><blockquote><ol><li>请求头：Accept/Accept—Language/Cache-Control/Cookie/User-Agent/Date/Host/Range</li><li>返回头：Accept-Ranges/Date/Cache-Control/Content-Length</li></ol></blockquote><h2 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket"></a>Websocket</h2><h3 id="WebSocket连接的生命周期"><a href="#WebSocket连接的生命周期" class="headerlink" title="WebSocket连接的生命周期"></a>WebSocket连接的生命周期</h3><p>总结一下 WebSocket 连接的生命周期：</p><ol><li>连接通过一个HTTP请求握手并建立连接。WebSocket 连接可以理解为是通过HTTP请求建立的普通TCP连接。</li><li>WebSocket 做了二进制分帧。WebSocket 连接中收发的数据以帧为单位。主要有用于连接保活的控制帧 PING 和 PONG，用于用户数据发送的 MESSAGE 帧，和用于关闭连接的控制帧 CLOSE。</li><li>连接建立之后，通过 PING 帧和 PONG 帧做连接保活。</li><li>一次 send 数据，被封为一个消息，通过一个或多个 MESSAGE帧进行发送。一个消息的帧和控制帧可以交叉发送，不同消息的帧之间不可以。</li><li>WebSocket 连接的两端相互发送一个 CLOSE 帧以最终关闭连接。</li></ol><p><a href="https://juejin.im/entry/5a73d44af265da4e721c4a9c" target="_blank" rel="noopener">OkHttp实现分析之Websocket</a></p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识 </tag>
            
            <tag> 面试 </tag>
            
            <tag> 网络 </tag>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Clash Tun in macOS</title>
      <link href="/2020/04/01/clash-macos-tun/"/>
      <url>/2020/04/01/clash-macos-tun/</url>
      
        <content type="html"><![CDATA[<h1 id="Clash-Tun-in-macOS"><a href="#Clash-Tun-in-macOS" class="headerlink" title="Clash Tun in macOS"></a>Clash Tun in macOS</h1><p><a href="https://github.com/Dreamacro/clash/releases/tag/TUN" target="_blank" rel="noopener">Clash Tun Experimental release</a></p><h2 id="Clash-Tun-Config"><a href="#Clash-Tun-Config" class="headerlink" title="Clash Tun Config"></a>Clash Tun Config</h2><h3 id="fake-ip-mode-not-under-test"><a href="#fake-ip-mode-not-under-test" class="headerlink" title="fake-ip mode (not under test)"></a>fake-ip mode (not under test)</h3><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">dns</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">listen</span><span class="token punctuation">:</span> 0.0.0.0<span class="token punctuation">:</span><span class="token number">53</span>  <span class="token key atrule">enhanced-mode</span><span class="token punctuation">:</span> fake<span class="token punctuation">-</span>ip  <span class="token key atrule">nameserver</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> 114.114.114.114<span class="token key atrule">experimental</span><span class="token punctuation">:</span>  <span class="token key atrule">interface-name</span><span class="token punctuation">:</span> en0 <span class="token comment" spellcheck="true"># your interface-name</span><span class="token key atrule">tun</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></code></pre><h3 id="real-ip-mode-recommend"><a href="#real-ip-mode-recommend" class="headerlink" title="real-ip mode (recommend)"></a>real-ip mode (recommend)</h3><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">dns</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">listen</span><span class="token punctuation">:</span> 0.0.0.0<span class="token punctuation">:</span><span class="token number">53</span>  <span class="token key atrule">ipv6</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">enhanced-mode</span><span class="token punctuation">:</span> redir<span class="token punctuation">-</span>host  <span class="token key atrule">nameserver</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> https<span class="token punctuation">:</span>//doh.rixcloud.dev/dns<span class="token punctuation">-</span>query    <span class="token punctuation">-</span> tls<span class="token punctuation">:</span>//dns.rubyfish.cn<span class="token punctuation">:</span><span class="token number">853 </span><span class="token comment" spellcheck="true"># dns over tls</span>    <span class="token punctuation">-</span> https<span class="token punctuation">:</span>//i.233py.com/dns<span class="token punctuation">-</span>query    <span class="token punctuation">-</span> https<span class="token punctuation">:</span>//dns.google/dns<span class="token punctuation">-</span>query    <span class="token punctuation">-</span> https<span class="token punctuation">:</span>//118.31.13.131/dns<span class="token punctuation">-</span>query    <span class="token punctuation">-</span> https<span class="token punctuation">:</span>//120.25.25.166/dns<span class="token punctuation">-</span>query    <span class="token punctuation">-</span> https<span class="token punctuation">:</span>//139.224.112.177/dns<span class="token punctuation">-</span>query    <span class="token punctuation">-</span> https<span class="token punctuation">:</span>//47.108.56.233/dns<span class="token punctuation">-</span>query    <span class="token punctuation">-</span> https<span class="token punctuation">:</span>//59.110.53.209/dns<span class="token punctuation">-</span>query    <span class="token punctuation">-</span> 119.28.28.28<span class="token key atrule">experimental</span><span class="token punctuation">:</span>  <span class="token key atrule">interface-name</span><span class="token punctuation">:</span> en0 <span class="token comment" spellcheck="true"># your interface-name</span><span class="token key atrule">tun</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></code></pre><h3 id="DNS-recommendations"><a href="#DNS-recommendations" class="headerlink" title="DNS recommendations"></a>DNS recommendations</h3><p>use DoT/DoH.</p><ul><li>tls://dns.rubyfish.cn:853 # dns over tls</li><li><a href="https://dns.google/dns-query" target="_blank" rel="noopener">https://dns.google/dns-query</a></li><li><a href="https://i.233py.com/dns-query" target="_blank" rel="noopener">https://i.233py.com/dns-query</a></li><li><a href="https://doh.rixcloud.dev/dns-query" target="_blank" rel="noopener">https://doh.rixcloud.dev/dns-query</a></li><li><a href="https://118.31.13.131/dns-query" target="_blank" rel="noopener">https://118.31.13.131/dns-query</a></li><li><a href="https://120.25.25.166/dns-query" target="_blank" rel="noopener">https://120.25.25.166/dns-query</a></li><li><a href="https://139.224.112.177/dns-query" target="_blank" rel="noopener">https://139.224.112.177/dns-query</a></li><li><a href="https://47.108.56.233/dns-query" target="_blank" rel="noopener">https://47.108.56.233/dns-query</a></li><li><a href="https://59.110.53.209/dns-query" target="_blank" rel="noopener">https://59.110.53.209/dns-query</a></li></ul><h3 id="Update-Config-When-Clash-is-Running"><a href="#Update-Config-When-Clash-is-Running" class="headerlink" title="Update Config When Clash  is Running"></a>Update Config When Clash  is Running</h3><pre class=" language-shell"><code class="language-shell">curl -v -X PUT -H "Accept: application/json" -H "Content-type: application/json"  -d '{"path":"/Users/xuhaoyang/clash/config.yaml"}' 127.0.0.1:9090/configs</code></pre><h3 id="Run-clash-with-sudo"><a href="#Run-clash-with-sudo" class="headerlink" title="Run clash with sudo"></a>Run clash with sudo</h3><pre class=" language-shell"><code class="language-shell">sudo ./clash -d .</code></pre><h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><h3 id="macOS-set-global-route-after-tun-start"><a href="#macOS-set-global-route-after-tun-start" class="headerlink" title="macOS set global route (after tun start)"></a>macOS set global route (after tun start)</h3><pre class=" language-shell"><code class="language-shell">sudo route -n add -net 1 198.18.0.1sudo route -n add -net 2/7 198.18.0.1sudo route -n add -net 4/6 198.18.0.1sudo route -n add -net 8/5 198.18.0.1sudo route -n add -net 16/4 198.18.0.1sudo route -n add -net 32/3 198.18.0.1sudo route -n add -net 64/2 198.18.0.1sudo route -n add -net 128.0/1 198.18.0.1networksetup -setdnsservers Wi-Fi 127.0.0.1</code></pre><h3 id="Unset"><a href="#Unset" class="headerlink" title="Unset"></a>Unset</h3><pre class=" language-shell"><code class="language-shell">sudo route -n delete -net 1 198.18.0.1sudo route -n delete -net 2/7 198.18.0.1sudo route -n delete -net 4/6 198.18.0.1sudo route -n delete -net 8/5 198.18.0.1sudo route -n delete -net 16/4 198.18.0.1sudo route -n delete -net 32/3 198.18.0.1sudo route -n delete -net 64/2 198.18.0.1sudo route -n delete -net 128.0/1 198.18.0.1networksetup -setdnsservers Wi-Fi</code></pre><p>Or close clash</p><h3 id="IP-foward"><a href="#IP-foward" class="headerlink" title="IP foward"></a>IP foward</h3><pre><code># IPv4 的转发$ sudo sysctl -w net.inet.ip.forwarding=1net.inet.ip.forwarding: 0 -&gt; 1# IPv6 的转发$ sudo sysctl -w net.inet6.ip6.forwarding=1net.inet6.ip6.forwarding: 0 -&gt; 1sudo sysctl -a | grep forward/etc/sysctl.conf </code></pre><h3 id="Shell-setting"><a href="#Shell-setting" class="headerlink" title="Shell setting"></a>Shell setting</h3><pre class=" language-shell"><code class="language-shell">fun setClashNetwork(){  OLDIFS=$IFS  IFS=$'\n'  sudo route -n add -net 1 198.18.0.1  sudo route -n add -net 2/7 198.18.0.1  sudo route -n add -net 4/6 198.18.0.1  sudo route -n add -net 8/5 198.18.0.1  sudo route -n add -net 16/4 198.18.0.1  sudo route -n add -net 32/3 198.18.0.1  sudo route -n add -net 64/2 198.18.0.1  sudo route -n add -net 128.0/1 198.18.0.1  for line in $(networksetup -listallnetworkservices)  do    if [[ "$line" != *"An asterisk"* ]]     then      echo "$line"      networksetup -setdnsservers $line "127.0.0.1"    fi  done  IFS=$OLDIFS}fun unsetClashNetwork(){  OLDIFS=$IFS  IFS=$'\n'  sudo route delete -net 1 198.18.0.1  sudo route delete -net 2/7 198.18.0.1  sudo route delete -net 4/6 198.18.0.1  sudo route delete -net 8/5 198.18.0.1  sudo route delete -net 16/4 198.18.0.1  sudo route delete -net 32/3 198.18.0.1  sudo route delete -net 64/2 198.18.0.1  sudo route delete -net 128.0/1 198.18.0.1  for line in $(networksetup -listallnetworkservices)  do    if [[ "$line" != *"An asterisk"* ]]     then      echo "$line"      networksetup -setdnsservers $line    fi  done  IFS=$OLDIFS}fun updateClashConfig(){  curl -v -X PUT -H "Accept: application/json" -H "Content-type: application/json"  -d '{"path":"/Users/xuhaoyang/clash/config/config.yaml"}' 127.0.0.1:9090/configs}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Clash </tag>
            
            <tag> macOS </tag>
            
            <tag> Tun </tag>
            
            <tag> Game Connect </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解final在Java和Android中修饰局部变量的意义</title>
      <link href="/2020/03/21/java-android-final/"/>
      <url>/2020/03/21/java-android-final/</url>
      
        <content type="html"><![CDATA[<h1 id="final在Java和Android中修饰局部变量的意义"><a href="#final在Java和Android中修饰局部变量的意义" class="headerlink" title="final在Java和Android中修饰局部变量的意义"></a>final在Java和Android中修饰局部变量的意义</h1><p>Q：为什么经常在Android项目中看到final 对变量进行修饰？</p><p><strong>在Java中，有四种内部类：</strong></p><ul><li><strong>静态内部类（static inner class）</strong></li><li><strong>成员内部类（Method inner class）</strong></li><li><strong>局部内部类（Local inner class）</strong></li><li><strong>匿名内部类（Anonymous inner class）</strong></li></ul><p>在后面两种内部类中如果访问了外部方法中的局部变量，都需要加final。为了弄清本质，我翻开了《Thinking in Java》，找到了如下这样一段话：</p><p>If you’re defining an anonymous inner class and want to use an object that’s defined outside the anonymous inner class, the compiler</p><p>requires that the argument reference be final, as you see in the argument to destination( ).</p><p>这里确实给出了结论，和我们在前面陈述的是一样的，但是没有说清楚为什么，然后我又去翻开了《Java核心卷》，这里面才找到我想要的，首先它贴出这样的代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token keyword">int</span> interval<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> beep<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">class</span> <span class="token class-name">TimePrinter</span> <span class="token keyword">implements</span> <span class="token class-name">ActionListener</span>    <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">actionPerformed</span><span class="token punctuation">(</span>ActionEvent event<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            Date now <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"At the tone, the time is "</span> <span class="token operator">+</span> now<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>beep<span class="token punctuation">)</span> Toolkit<span class="token punctuation">.</span><span class="token function">getDefaultToolkit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">beep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    ActionListener listener <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TimePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Timer t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span>interval<span class="token punctuation">,</span> listener<span class="token punctuation">)</span><span class="token punctuation">;</span>    t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>注意这个beep，在局部内部类中使用了，而且使用了final，接下来它做了一件事：反编译这个TimePrinter：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">TalkingClock</span>$1TimePrinter<span class="token punctuation">{</span>    TalkingClock$<span class="token function">1TimePrinter</span><span class="token punctuation">(</span>TalkingClock<span class="token punctuation">,</span> <span class="token keyword">boolean</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">actionPerformed</span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>awt<span class="token punctuation">.</span>event<span class="token punctuation">.</span>ActionEvent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token keyword">boolean</span> val$beep<span class="token punctuation">;</span>    <span class="token keyword">final</span> TalkingClock <span class="token keyword">this</span>$<span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>into the constructor and stored in the val$beep field. The compiler detects access of local variables, makes matching instance fields for each one of them, and copies the local variables into the constructor so that the instance fields can be initialized.</p><p>以上文档就很好的阐述了理由：原来，我们在局部内部类中访问的这些final修饰的局部变量，都会作为局部内部类的由final修饰的成员变量，并在构造中传入值初始化。</p><p>原来，编译器是这么处理的，渐渐有了眉目，但是为什么必须声明是final的呢？还是核心卷里的一段话启发了我：</p><blockquote><p>From the programmer’s point of view, local variable access is quite pleasant. It makes your inner classes simpler by reducing the instance fields that you need to program explicitly.</p></blockquote><p>也就是说，我们在局部内部类中访问的实际上是这个var$beep（它的值等于beep），它是局部变量beep一份拷贝，并不是局部变量本身，但是为了方便编程，编译器允许我们直接使用beep来指代var$beep。那到这里就能解释为什么要是final了。</p><p>我们来试想这样的场景：如果我们在局部内部类中对访问的这个局部变量进行了修改，例如在上面的actionPerformed方法中，我添加了这样的一行代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">actionPerformed</span><span class="token punctuation">(</span>ActionEvent event<span class="token punctuation">)</span><span class="token punctuation">{</span>    beep <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    Date now <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"At the tone, the time is "</span> <span class="token operator">+</span> now<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>beep<span class="token punctuation">)</span> Toolkit<span class="token punctuation">.</span><span class="token function">getDefaultToolkit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">beep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>那么这个时候，就会出现矛盾，在actionPerformed中将beep置为false，这个时候，这个beep本质上是我们前面提到的var$beep，而不是局部变量beep，那么接下来的代码中，到底以谁为准，就会造成不一致，就会给程序员带来困扰，那么这个时候规定，此时只能使用这个局部变量，而不允许修改它，<strong>因此，局部变量必须声明为final，而且内部类中的这份拷贝，这个成员变量也是final的</strong>。到这里我们已经能够解释原因了。</p><p>接下来我就把项目中遇到的问题在这里与大家分享一下：</p><p>先贴出关键代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GroupDetailAdapter</span> <span class="token keyword">extends</span> <span class="token class-name">BaseAdapter</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> UserInfo userInfo<span class="token punctuation">;</span>     <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> View <span class="token function">getView</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">int</span> position<span class="token punctuation">,</span> View convertView<span class="token punctuation">,</span> ViewGroup parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>        userInfo  <span class="token operator">=</span> mUsers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>position<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        holder<span class="token punctuation">.</span>ivGroupDetailDelete<span class="token punctuation">.</span><span class="token function">setOnClickListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">View<span class="token punctuation">.</span>OnClickListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onClick</span><span class="token punctuation">(</span>View v<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 删除群成员</span>                    mOnGroupDetailListener<span class="token punctuation">.</span><span class="token function">onDeleteMember</span><span class="token punctuation">(</span>userInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>用局部变量，如果在内部类要使用，就声明为final，但是这次就不知为啥心血来潮将这个userInfo声明为成员变量，最终导致onClick方法会出现问题，传入onDeleteMember方法里的userInfo始终是集合中最后一个。后来各种debug，最后把userInfo = mUsers.get(position);这行代码放入到onClick方法中就好了，或者将这个userInfo换成局部变量然后使用也能解决问题。为什么？先解释bug出现的原因：</p><p>由于我的userInfo是在getView方法中获取的，而getView方法只会在视图显示的时候被调用，显示完毕后，position的值肯定到达了它的最大值（即集合的size - 1，#2017.7.19修改：这个地方不严谨，position的值应该为当前页面显示列表的条目，我这刚好是一页就显示完毕，所以position的值为size - 1#），那么这个时候userInfo自然保存的就是集合中的最后一个元素，然后静静的等待着onClick方法的被回调，一旦回调就把userInfo传给onDeleteMember方法执行相应的逻辑，而userInfo此时肯定是集合中的最后一个元素，最终导致这个bug的诞生。</p><p>这实际上才是这篇博客最初的触发点，这里来分别解释下这两种解决问题的办法：</p><ul><li><p>userInfo为成员变量，userInfo = mUsers.get(position);放到onClick中：这种情况下，如果这么去使用，那么position肯定为final的，也就是这个匿名内部类中会维护这样一份拷贝，注意，这里是position的拷贝，要注意和第二种方法的区分。</p></li><li><p>userInfo为局部变量，userInfo = mUsers.get(position);还在原来的位置：这种情况下，如果这么去使用，那么userInfo肯定为final的，同样在这个匿名内部类中维护一份拷贝，但这里是userInfo的拷贝。</p></li></ul><p>谢谢这个bug，才衍生出自己这样的思考，才能理解的更加透彻！</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android面试知识</title>
      <link href="/2020/03/21/android-interview/"/>
      <url>/2020/03/21/android-interview/</url>
      
        <content type="html"><![CDATA[<h1 id="Android-Interview"><a href="#Android-Interview" class="headerlink" title="Android Interview"></a>Android Interview</h1><h3 id="Android的大体架构图"><a href="#Android的大体架构图" class="headerlink" title="Android的大体架构图"></a><a href="https://juejin.im/post/5a93a1f1f265da4e8b300059" target="_blank" rel="noopener">Android的大体架构图</a></h3><blockquote><p>分为四个层次：linux内核；libraies和Android runntime；framework；Application</p><p><img src="https://user-gold-cdn.xitu.io/2018/2/26/161d0b2cc51eff90?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p></blockquote><h3 id="Android的四大组件是哪些，它们的作用？"><a href="#Android的四大组件是哪些，它们的作用？" class="headerlink" title="Android的四大组件是哪些，它们的作用？"></a><a href="https://blog.csdn.net/shiretan/article/details/55053857" target="_blank" rel="noopener">Android的四大组件</a>是哪些，它们的作用？</h3><blockquote><ol><li>Activity：Activity是Android程序与用户交互的窗口,对用户来说是可见的</li><li>service：后台服务于Activity,是一个服务，不可见</li><li>Content Provider：对外提提供数据</li><li>BroadCast Receiver：接受一种或者多种Intent作触发事件，接受相关消息，做一些简单处理</li></ol></blockquote><h3 id="Android-中进程的优先级"><a href="#Android-中进程的优先级" class="headerlink" title="Android 中进程的优先级"></a><a href="https://blog.csdn.net/omnispace/article/details/73320950" target="_blank" rel="noopener">Android 中进程的优先级</a></h3><blockquote><ol><li>前台进程</li><li>可见进程</li><li>服务进程</li><li>后台进程</li><li>空进程</li></ol></blockquote><h3 id="Android中asset和res目录的区别"><a href="#Android中asset和res目录的区别" class="headerlink" title="Android中asset和res目录的区别"></a>Android中asset和res目录的区别</h3><blockquote><ol><li>res目录下的资源文件会在R文件中生成对应的id，asset不会\</li><li>res目录下的文件在生成apk时，除raw（即res/raw）目录下文件不进行编译外，都会被编译成二进制文件；asset目录下的文件不会进行编译</li><li>asset目录允许有子目录</li></ol></blockquote><h3 id="Android中App-是如何沙箱化的-为何要这么做"><a href="#Android中App-是如何沙箱化的-为何要这么做" class="headerlink" title="Android中App 是如何沙箱化的,为何要这么做"></a><a href="https://blog.csdn.net/ljheee/article/details/53191397" target="_blank" rel="noopener">Android中App 是如何沙箱化的,为何要这么做</a></h3><blockquote><ol><li>沙箱化可以提升安全性和效率</li><li>Android的底层内核为Linux，因此继承了Linux良好的安全性，并对其进行了优化。在Linux中，一个用户对应一个uid，而在Android中，（通常）一个APP对应一个uid，拥有独立的资源和空间，与其他APP互不干扰。如有两个APP A和B，A并不能访问B的资源，A的崩溃也不会对B造成影响，从而保证了安全性和效率</li></ol></blockquote><h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><hr><h3 id="Activity-生命周期"><a href="#Activity-生命周期" class="headerlink" title="Activity 生命周期"></a>Activity 生命周期</h3><p><img src="https://user-gold-cdn.xitu.io/2018/4/15/162c87b50447983f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="Activity在屏幕旋转时的生命周期"><a href="#Activity在屏幕旋转时的生命周期" class="headerlink" title="Activity在屏幕旋转时的生命周期"></a>Activity在屏幕旋转时的生命周期</h3><blockquote><ol><li>没有任何设置时，会调用整个生命周期方法，并且会调用onSaveInstance和onRestoreInstanceState方法</li><li>在Manifest中为Activity设置android:configChanges=”orientation”时，只调用onConfigChanges方法</li><li>android:configChanges=”orientation”属性有可能不起作用，依然会调用整个生命周期方法，这是因为不同版本处理方式可能不同，有时候还需要加上android:configChanges=”orientation|keyboardHidden|screenSize”等。</li></ol></blockquote><h3 id="onSaveInstanceState-什么时候调用"><a href="#onSaveInstanceState-什么时候调用" class="headerlink" title="onSaveInstanceState 什么时候调用"></a>onSaveInstanceState 什么时候调用</h3><blockquote><ol><li>非用户主动明确结束（按back键，自定义click方法调用finish）时都会调用onSaveInstanceState：<ol><li>屏幕旋转</li><li>按HOME键</li><li>内存不足</li><li>从一个activity启动另一个activity</li></ol></li><li>这个方法的调用时机是在onStop前，但是它和onPause没有既定的时序关系</li></ol></blockquote><h3 id="自定义View控件的状态被保存需要满足两个条件"><a href="#自定义View控件的状态被保存需要满足两个条件" class="headerlink" title="自定义View控件的状态被保存需要满足两个条件"></a>自定义View控件的状态被保存需要满足两个条件</h3><blockquote><ol><li>View有唯一的ID</li><li>View的初始化时要调用setSaveEnabled(true)</li></ol></blockquote><h3 id="configChanges属性"><a href="#configChanges属性" class="headerlink" title="configChanges属性"></a>configChanges属性</h3><blockquote><p>对Activity配置了android:configChanges=”xxx”属性之后，Activity就不会在对应变化发生时重新创建，而是调用Activity的onConfigurationChanged方法。常用的有local：设备的本地位置发生了变化，一般指切换了系统语言；keyboardHidden：键盘的可访问性发生了变化，比如用户调出了键盘；orientation：屏幕方向发生了变化，比如旋转了手机屏幕。</p></blockquote><h3 id="A-activity启动B-activity和B-activity返回A-activity的生命周期执行过程"><a href="#A-activity启动B-activity和B-activity返回A-activity的生命周期执行过程" class="headerlink" title="A activity启动B activity和B activity返回A activity的生命周期执行过程"></a>A activity启动B activity和B activity返回A activity的生命周期执行过程</h3><blockquote><ol><li>A启动B:A.onPause()→B.onCreate()→B.onStart()→B.onResume()→A.onStop</li><li>B返回A：B.onPause()→A.onRestart()/A.onCreate()→A.onStart()→A.onResume()→B.onStop()</li></ol></blockquote><h3 id="Activity执行finish后的生命周期"><a href="#Activity执行finish后的生命周期" class="headerlink" title="Activity执行finish后的生命周期"></a><a href="https://www.jianshu.com/p/ede291c83e70" target="_blank" rel="noopener">Activity执行finish后的生命周期</a></h3><blockquote><ol><li>在onCreate中执行：onCreate -&gt; onDestroy</li><li>在onStart中执行：onCreate -&gt; onStart -&gt; onStop -&gt; onDestroy</li><li>在onResume中执行：onCreate -&gt; onStart -&gt; onResume -&gt; onpause -&gt; onStop -&gt; onDestroy</li></ol></blockquote><h3 id="如果用了一些解耦的策略，怎么管理生命周期的？"><a href="#如果用了一些解耦的策略，怎么管理生命周期的？" class="headerlink" title="如果用了一些解耦的策略，怎么管理生命周期的？"></a>如果用了一些解耦的策略，怎么管理生命周期的？</h3><blockquote><ol><li><p>可以用Google的</p><p>LifeCycle框架</p><p>\0. 引入LifeCycle框架</p><ol><li>将控件实现LifecycleObserver接口</li><li>在Activity中中注册控件：getLifeCycle().addObderver(View);</li><li>在控件中使用：  @OnLifecycleEvent(Lifecycle.Event.ON_START)</li></ol></li></ol></blockquote><h3 id="Activity的启动流程"><a href="#Activity的启动流程" class="headerlink" title="Activity的启动流程"></a><a href="http://www.sohu.com/a/130814934_675634" target="_blank" rel="noopener">Activity的启动流程</a></h3><p><img src="https://user-gold-cdn.xitu.io/2018/4/25/162f87ee1dc37bf4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="Android中Activity的启动模式"><a href="#Android中Activity的启动模式" class="headerlink" title="Android中Activity的启动模式"></a><a href="https://blog.csdn.net/CodeEmperor/article/details/50481726" target="_blank" rel="noopener">Android中Activity的启动模式</a></h3><blockquote><ol><li>standard:每一次启动，都会生成一个新的实例，放入栈顶中</li><li>singleTop:通过singelTop启动Activity时，如果发现有需要启动的实例正在栈顶，责直接重用，否则生成新的实例</li><li>singleTask:通过singleTask启动Activity时，如果发现有需要启动的实例正在栈中，责直接移除它上边的实例，并重用该实例，否则生成新的实例</li><li>singleInstance:通过singleTask启动Activity时，会启用一个新的栈结构，并将新生成的实例放入栈中。</li></ol></blockquote><h3 id="TaskAffinity-属性"><a href="#TaskAffinity-属性" class="headerlink" title="TaskAffinity 属性"></a>TaskAffinity 属性</h3><blockquote><ol><li>任务相关性，标识一个Activity所需的任务栈的名字。默认情况下，所有的Activity所需的任务栈的名字是应用的包名，当然也可以单独指定TaskAffinity属性。</li><li>TaskAffinity属性主要和singleTask启动模式和allowTaskRepeating属性配对使用，在其他情况下使用没有意义</li><li>当TaskAffinity和singleTask启动模式配对使用的时候，它是具有该模式的Activity的目前任务栈的名字，待启动的Activity会运行在名字和TaskAffinity相同的任务栈中</li><li>当TaskAffinity和allowTaskReparenting结合的时候，当一个应用A启动了应用B的某个Activity C后，如果Activity C的allowTaskReparenting属性设置为true的话，那么当应用B被启动后，系统会发现Activity C所需的任务栈存在了，就将Activity C从A的任务栈中转移到B的任务栈中。</li></ol></blockquote><h3 id="Activity启动模式的TaskAffinity和allowTaskReparenting"><a href="#Activity启动模式的TaskAffinity和allowTaskReparenting" class="headerlink" title="Activity启动模式的TaskAffinity和allowTaskReparenting"></a><a href="https://blog.csdn.net/javazejian/article/details/52072131" target="_blank" rel="noopener">Activity启动模式的TaskAffinity和allowTaskReparenting</a></h3><blockquote><ol><li>TaskAffinity配合singleTask使用，指定任务栈：如果没有TaskAffinity指定的任务栈，则开启新栈</li><li>allowTaskReparenting配合standard和singleTop使用，标明该Activity的任务栈可以重新设置</li></ol></blockquote><h3 id="当前应用有两个Activity-A和B，B的-android-launchMode-设置了singleTask模式，A是默认的standard，那么A-startActivity启动B，B会新启一个Task吗？如果不会，那么startActivity的Intent加上FLAG-ACTIVITY-NEW-TASK这个参数会不会呢？"><a href="#当前应用有两个Activity-A和B，B的-android-launchMode-设置了singleTask模式，A是默认的standard，那么A-startActivity启动B，B会新启一个Task吗？如果不会，那么startActivity的Intent加上FLAG-ACTIVITY-NEW-TASK这个参数会不会呢？" class="headerlink" title="当前应用有两个Activity A和B，B的 android:launchMode 设置了singleTask模式，A是默认的standard，那么A startActivity启动B，B会新启一个Task吗？如果不会，那么startActivity的Intent加上FLAG_ACTIVITY_NEW_TASK这个参数会不会呢？"></a>当前应用有两个Activity A和B，B的 android:launchMode 设置了singleTask模式，A是默认的standard，那么A startActivity启动B，B会新启一个Task吗？如果不会，那么startActivity的Intent加上FLAG_ACTIVITY_NEW_TASK这个参数会不会呢？</h3><blockquote><p>设置了singleTask启动模式的Activity，它在启动的时会先在系统中查看属性值affinity等于它的属性值taskAffinity ( taskAffinity默认为包名 ) 的任务栈是否存在。如果存在这样的任务栈，它就会在这个任务栈中启动，否则就会在新任务栈中启动。</p></blockquote><blockquote><p>当Intent对象包含FLAG_ACTIVITY_NEW_TASK标记时，系统在查找时仍然按Activity的taskAffinity属性进行匹配，如果找到一个任务栈的taskAffinity与之相同，就将目标Activity压入此任务栈中，如果找不到则创建一个新的任务栈。</p></blockquote><blockquote><p>设置了singleTask启动模式的Activity在已有的任务栈中已经存在相应的Activity实例，再启动它时会把这个Activity实例上面的Activity全部结束掉。也就是说singleTask自带clear top的效果。</p></blockquote><h3 id="IntentFilter的匹配规则"><a href="#IntentFilter的匹配规则" class="headerlink" title="IntentFilter的匹配规则"></a>IntentFilter的匹配规则</h3><blockquote><p>IntentFilter中的过滤信息有action、category、data，为了匹配过滤列表，需要同时匹配过滤列表中的action、category、data信息，否则匹配失败。</p></blockquote><h3 id="验证是否有当前Activity"><a href="#验证是否有当前Activity" class="headerlink" title="验证是否有当前Activity"></a>验证是否有当前Activity</h3><blockquote><ol><li>PackageManager的resolveActivity方法或者Intent的resolveActivity方法：如果找不到就会返回null</li><li>PackageManager的queryIntentActivities方法：它返回所有成功匹配的Activity信息</li></ol></blockquote><h3 id="如何获取当前屏幕Activity的对象？"><a href="#如何获取当前屏幕Activity的对象？" class="headerlink" title="如何获取当前屏幕Activity的对象？"></a><a href="https://blog.csdn.net/vfush/article/details/51483436" target="_blank" rel="noopener">如何获取当前屏幕Activity的对象？</a></h3><blockquote><p>通过在Application中注册Activity生命周期的监听函数Application.registerActivityLifecycleCallbacks()</p></blockquote><h3 id="onNewIntent调用时机"><a href="#onNewIntent调用时机" class="headerlink" title="onNewIntent调用时机"></a><a href="https://blog.csdn.net/calvin_zhou/article/details/51913413" target="_blank" rel="noopener">onNewIntent调用时机</a></h3><blockquote><p>一个Activity已经启动，当再次启动它时，如果他的启动模式（如SingleTask，SingleTop）标明不需要重新启动，会调用onNewIntent</p></blockquote><h3 id="除了用Intent-去启动一个Activity，还有其他方法吗"><a href="#除了用Intent-去启动一个Activity，还有其他方法吗" class="headerlink" title="除了用Intent 去启动一个Activity，还有其他方法吗"></a>除了用Intent 去启动一个Activity，还有其他方法吗</h3><blockquote><p>使用adb shell am 命令 :如adb shell am start com.example.fuchenxuan/.MainActivity 或者 adb shell am broadcast -a magcomm.action.TOUCH_LETTER</p></blockquote><h3 id="Android中子线程更新UI的方式"><a href="#Android中子线程更新UI的方式" class="headerlink" title="Android中子线程更新UI的方式"></a>Android中子线程更新UI的方式</h3><blockquote><ol><li>activity.runOnUiThread(runnable)</li><li>通过主线程中的Handler进行更新</li><li>通过View的post（）或者postDelayed方法进行更新</li></ol></blockquote><h3 id="Activity之间的通信方式"><a href="#Activity之间的通信方式" class="headerlink" title="Activity之间的通信方式"></a><a href="https://juejin.im/post/5a9509ef6fb9a06337575d4b" target="_blank" rel="noopener">Activity之间的通信方式</a></h3><blockquote><ol><li>Intent</li><li>BroadCast或者LocalBroadCast</li><li>数据存储的方式</li><li>静态变量</li></ol></blockquote><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><hr><h3 id="Service的启动方式"><a href="#Service的启动方式" class="headerlink" title="Service的启动方式"></a><a href="https://juejin.im/post/5a96533ef265da4e967425ce" target="_blank" rel="noopener">Service的启动方式</a></h3><blockquote><ol><li>start</li><li>bind</li></ol></blockquote><h3 id="Service生命周期"><a href="#Service生命周期" class="headerlink" title="Service生命周期"></a>Service生命周期</h3><p><img src="https://user-gold-cdn.xitu.io/2018/4/30/163164ff001a01e3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="Service-和Activity-的通信方式"><a href="#Service-和Activity-的通信方式" class="headerlink" title="Service 和Activity 的通信方式"></a>Service 和Activity 的通信方式</h3><blockquote><ol><li>如上Activity和Activity的通信方式</li><li><a href="https://www.cnblogs.com/JMatrix/p/8296364.html" target="_blank" rel="noopener">bind方式启动时可以通过ServiceConnection通信</a>：在SerVice的onBind方法中返回一个binder，该binder可以是AIDL方法产生的，也可以是Messenger方法产生的</li></ol></blockquote><h3 id="Service和Thread的区别"><a href="#Service和Thread的区别" class="headerlink" title="Service和Thread的区别"></a>Service和Thread的区别</h3><blockquote><ol><li>这是没用任何关系的两个概念，servie是系统的组件，Thread是CPU运行的最小单元</li><li>Service不可见，我们可以把Service当成是不可见的Activity，用于在后台执行一些服务；</li><li>Service可以运行在任意线程上，如果我们生成它时没有做特殊说明，那么它运行在主线程上</li><li>很多时候我们需要在Activity中开启一个Service，再在Service中开启一个线程，这么做的原因是Service只会初始化一次，我们可以随时找到Service中生成的thread，使用场景举例：<ol><li>如我们需要在多个Activity中对同一个thread进行控制时；</li><li>如果你的 Thread 需要不停地隔一段时间就要连接服务器做某种同步的话，该 Thread 需要在 Activity 没有start的时候也在运行。这个时候当你 start 一个 Activity 就没有办法在该 Activity 里面控制之前创建的 Thread。因此你便需要创建并启动一个 Service ，在 Service 里面创建、运行并控制该 Thread，这样便解决了该问题</li></ol></li></ol></blockquote><h3 id="为什么有时需要在Service中创建子线程而不是Activity中"><a href="#为什么有时需要在Service中创建子线程而不是Activity中" class="headerlink" title="为什么有时需要在Service中创建子线程而不是Activity中"></a><a href="http://www.cnblogs.com/yejiurui/archive/2013/11/18/3429451.html" target="_blank" rel="noopener">为什么有时需要在Service中创建子线程而不是Activity中</a></h3><blockquote><p>这是因为Activity很难对Thread进行控制，当Activity被销毁之后，就没有任何其它的办法可以再重新获取到之前创建的子线程的实例。而且在一个Activity中创建的子线程，另一个Activity无法对其进行操作。但是Service就不同了，所有的Activity都可以与Service进行关联，然后可以很方便地操作其中的方法，即使Activity被销毁了，之后只要重新与Service建立关联，就又能够获取到原有的Service中Binder的实例。因此，使用Service来处理后台任务，Activity就可以放心地finish，完全不需要担心无法对后台任务进行控制的情况。</p></blockquote><h3 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a><a href="https://www.jianshu.com/p/332b6daf91f0" target="_blank" rel="noopener">IntentService</a></h3><blockquote><ol><li>IntentService 是继承自 Service,内部通过HandlerThread启动一个新线程处理耗时操作么，可以看做是Service和HandlerThread的结合体，在完成了使命之后会自动停止，适合需要在工作线程处理UI无关任务的场景</li><li>如果启动 IntentService 多次，那么每一个耗时操作会以工作队列的方式在 IntentService 的 onHandleIntent 回调方法中执行，依次去执行，使用串行的方式，执行完自动结束。</li></ol></blockquote><h3 id="IntentService生命周期是怎样的"><a href="#IntentService生命周期是怎样的" class="headerlink" title="IntentService生命周期是怎样的"></a>IntentService生命周期是怎样的</h3><blockquote><ol><li>在所有任务执行完毕后，自动结束生命</li></ol></blockquote><h2 id="BroadCast"><a href="#BroadCast" class="headerlink" title="BroadCast"></a>BroadCast</h2><hr><h3 id="BroadCast的注册方式与区别"><a href="#BroadCast的注册方式与区别" class="headerlink" title="BroadCast的注册方式与区别"></a>BroadCast的注册方式与区别</h3><blockquote><ol><li>在manifest中静态注册:广播是常驻的，App关闭后仍能接收广播，唤醒App</li><li>动态的注册和注销:动态注册的广播生命周期和他的宿主相同，或者调用注销方法注销广播</li></ol></blockquote><h3 id="Android中发送BroadCast的方式"><a href="#Android中发送BroadCast的方式" class="headerlink" title="Android中发送BroadCast的方式"></a><a href="https://www.jianshu.com/p/ea5e233d9f43" target="_blank" rel="noopener">Android中发送BroadCast的方式</a></h3><blockquote><ol><li>无序广播：通过mContext.sendBroadcast(Intent)或mContext.sendBroadcast(Intent, String)发送的是无序广播(后者加了权限)；</li><li>通过mContext.sendOrderedBroadcast(Intent, String, BroadCastReceiver, Handler, int, String, Bundle)发送的是有序广播（不再推荐使用）。</li><li>在无序广播中，所有的Receiver会接收到相同广播；而在有序广播中，我们可以为Receiver设置优先级，优先级高的先接收广播，并有权对广播进行处理和决定要不要继续向下传送</li></ol></blockquote><h3 id="BroadCastReceiver处理耗时操作"><a href="#BroadCastReceiver处理耗时操作" class="headerlink" title="BroadCastReceiver处理耗时操作"></a>BroadCastReceiver处理耗时操作</h3><blockquote><ol><li>BroadcastReceiver的生命周期只有一个回调方法onReceive(Context context, Intent intent)；无法进行耗时操作，即使启动线程处理，也是出于非活动状态，有可能被系统杀掉。</li><li>如果需要进行耗时操作，可以启动一个service处理。</li></ol></blockquote><h3 id="广播发送和接收的原理了解吗"><a href="#广播发送和接收的原理了解吗" class="headerlink" title="广播发送和接收的原理了解吗"></a>广播发送和接收的原理了解吗</h3><blockquote><ol><li>继承BroadcastReceiver，重写onReceive()方法。</li><li>通过Binder机制向ActivityManagerService注册广播。</li><li>通过Binder机制向ActivityMangerService发送广播。</li><li>ActivityManagerService查找符合相应条件的广播（IntentFilter/Permission）的BroadcastReceiver，将广播发送到BroadcastReceiver所在的消息队列中。</li><li>BroadcastReceiver所在消息队列拿到此广播后，回调它的onReceive()方法。</li></ol></blockquote><h3 id="广播传输的数据是否有限制，是多少，为什么要限制？"><a href="#广播传输的数据是否有限制，是多少，为什么要限制？" class="headerlink" title="广播传输的数据是否有限制，是多少，为什么要限制？"></a>广播传输的数据是否有限制，是多少，为什么要限制？</h3><blockquote><ol><li>广播是通过Intent携带需要传递的数据的</li><li>Intent是通过Binder机制实现的</li><li>Binder对数据大小有限制，不同room不一样，一般为1M</li></ol></blockquote><h3 id="Localbroadcast"><a href="#Localbroadcast" class="headerlink" title="Localbroadcast"></a><a href="https://blog.csdn.net/u013614207/article/details/46536047" target="_blank" rel="noopener">Localbroadcast</a></h3><p>本地广播，只有本进程中的receivers能接收到此广播</p><blockquote><p>实现原理（监听者模式）：</p><ol><li>LocalBroadcastManager是一个单例</li><li>在LocalBroadcastManager实例中维护一个Action和ReceiverRecord的Map.(ReceiverRecord是reveiver和intentfilter的组合)</li><li>当调用LocalBroadcastManager的sendBroadcast方法时，会从2中的map找到合适的receiver，让后加到待执行的队列mPendingBroadcasts，并通过Handler发送一个空消息（此Handler运行在主线程中，是创建manager时创建的）</li><li>handler 的handle方法收到消息，从mPendingBroadcasts取出receiver并调用onreceive方法<br> 其他：删除方法是通过一个辅助的hashmap实现的，hashmap存储了receiver和receiverRecord</li></ol></blockquote><h2 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h2><hr><h3 id="请介绍下ContentProvider是如何实现数据共享的"><a href="#请介绍下ContentProvider是如何实现数据共享的" class="headerlink" title="请介绍下ContentProvider是如何实现数据共享的"></a><a href="https://blog.csdn.net/u011240877/article/details/72848608" target="_blank" rel="noopener">请介绍下ContentProvider是如何实现数据共享的</a></h3><blockquote><ol><li>准确的说，ContentProvider是一个APP间共享数据的接口。一个程序可以通过实现一个Content provider的抽象接口将自己的数据完全暴露出去，数据可以是SqLite中的，也可以是文件或者其他类型。</li><li>使用方式：<ol><li>在A APP中实现建ContentProvider，并在Manifest中生命它的Uri和权限</li><li>在B APP中注册权限，并通过ContentResolver和Uri进行增删改查</li></ol></li><li><a href="https://www.2cto.com/kf/201407/317150.html" target="_blank" rel="noopener">扩展</a>：ContentProvider底层是通过Binder机制来实现跨进程间通信，通过匿名共享内存方式进行数据的传输 一个应用进程有16个Binder线程去和远程服务进行交互，而每个线程可占用的缓存空间是128KB，超过会报异常。</li></ol></blockquote><h3 id="每个ContentProvider的操作是在哪个线程中运行的呢（其实我们关心的是UI线程和工作线程）？比如我们在UI线程调用getContentResolver-query查询数据，而当数据量很大时（或者需要进行较长时间的计算）会不会阻塞UI线程呢？"><a href="#每个ContentProvider的操作是在哪个线程中运行的呢（其实我们关心的是UI线程和工作线程）？比如我们在UI线程调用getContentResolver-query查询数据，而当数据量很大时（或者需要进行较长时间的计算）会不会阻塞UI线程呢？" class="headerlink" title="每个ContentProvider的操作是在哪个线程中运行的呢（其实我们关心的是UI线程和工作线程）？比如我们在UI线程调用getContentResolver().query查询数据，而当数据量很大时（或者需要进行较长时间的计算）会不会阻塞UI线程呢？"></a>每个ContentProvider的操作是在哪个线程中运行的呢（其实我们关心的是UI线程和工作线程）？比如我们在UI线程调用getContentResolver().query查询数据，而当数据量很大时（或者需要进行较长时间的计算）会不会阻塞UI线程呢？</h3><blockquote><ol><li>ContentProvider和调用者在同一个进程，ContentProvider的方法（query/insert/update/delete等）和调用者在同一线程中</li><li>ContentProvider和调用者在不同的进程，ContentProvider的方法会运行在它自身所在进程的一个Binder线程中</li></ol></blockquote><h3 id="ContentProvider、ContentResolver与ContentObserver之间的关系是什么？"><a href="#ContentProvider、ContentResolver与ContentObserver之间的关系是什么？" class="headerlink" title="ContentProvider、ContentResolver与ContentObserver之间的关系是什么？"></a>ContentProvider、ContentResolver与ContentObserver之间的关系是什么？</h3><blockquote><ol><li>ContentProvider：管理数据，提供数据的增删改查操作，数据源可以是数据库、文件、XML、网络等，ContentProvider为这些数据的访问提供了统一的接口，可以用来做进程间数据共享。</li><li>ContentResolver：ContentResolver可以不同URI操作不同的ContentProvider中的数据，外部进程可以通过ContentResolver与ContentProvider进行交互。</li><li>ContentObserver：观察ContentProvider中的数据变化，并将变化通知给外界。</li></ol></blockquote><h2 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h2><hr><h3 id="Fragment生命周期"><a href="#Fragment生命周期" class="headerlink" title="Fragment生命周期"></a>Fragment生命周期</h3><blockquote><p>onAttach -&gt; onCreate  -&gt; onCreateView -&gt; onActivityCreate -&gt; onStart -&gt; onResume -&gt; onPause -&gt; onStop -&gt; onDestoryView -&gt; onDestory -&gt; onDetach</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/4/15/162c87b504f15f0d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="遇到过哪些关于Fragment的问题，如何处理的"><a href="#遇到过哪些关于Fragment的问题，如何处理的" class="headerlink" title="遇到过哪些关于Fragment的问题，如何处理的"></a>遇到过哪些关于Fragment的问题，如何处理的</h3><blockquote><p>举例：getActivity()空指针：这种情况一般发生在在异步任务里调用getActivity()，而Fragment已经onDetach()。</p></blockquote><h3 id="Fragment-有什么优点，-Fragment和View可以相互替换嘛"><a href="#Fragment-有什么优点，-Fragment和View可以相互替换嘛" class="headerlink" title="Fragment 有什么优点， Fragment和View可以相互替换嘛"></a>Fragment 有什么优点， Fragment和View可以相互替换嘛</h3><blockquote><ol><li>Fragment为了解决Andriod碎片化而产生的</li><li>Fragment和View都有助于界面复用</li><li>Fragment的复用粒度更大，包含生命周期和业务逻辑，通常包含好几个View</li><li>View通常更关注视图的实现</li></ol></blockquote><h3 id="Fragment-add-replace-区别"><a href="#Fragment-add-replace-区别" class="headerlink" title="Fragment add replace 区别"></a>Fragment add replace 区别</h3><ol><li>replace 先删除容器中的内容，再添加</li><li>add直接添加，可以配合hide适用</li></ol><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><hr><h3 id="0-Android中数据存储的方式有哪些"><a href="#0-Android中数据存储的方式有哪些" class="headerlink" title="0. Android中数据存储的方式有哪些"></a>0. <a href="https://juejin.im/post/5a93ade7f265da4e6f1805d6" target="_blank" rel="noopener">Android中数据存储的方式有哪些</a></h3><blockquote><ol><li>File</li><li>SharedPreferences</li><li>SQlite</li><li>网络</li><li>ContentProvider</li></ol></blockquote><h3 id="1-SharedPreference是进程同步的嘛，有没有什么方法进程同步"><a href="#1-SharedPreference是进程同步的嘛，有没有什么方法进程同步" class="headerlink" title="1. SharedPreference是进程同步的嘛，有没有什么方法进程同步"></a>1. <a href="https://www.jianshu.com/p/875d13458538" target="_blank" rel="noopener">SharedPreference是进程同步的嘛，有没有什么方法进程同步</a></h3><blockquote><ol><li>默认不是</li><li>可以设置模式MODE_MULTI_PROCESS做到进程同步，但因为该模式有很多坑，已经被Google弃用</li><li>官方建议使用ContentProvider</li></ol></blockquote><h3 id="2-SharedPreferences-commit和apply的区别"><a href="#2-SharedPreferences-commit和apply的区别" class="headerlink" title="2. SharedPreferences commit和apply的区别"></a>2. SharedPreferences commit和apply的区别</h3><blockquote><ol><li>commit是同步的提交，这种方式很常用，在比较早的SDK版本中就有了。这种提交方式会阻塞调用它的线程，并且这个方法会返回boolean值告知保存是否成功（如果不成功，可以做一些补救措施）。</li><li>apply是异步的提交方式，目前Android Studio也会提示大家使用这种方式</li></ol></blockquote><h3 id="3-文件存储路径与权限和权限"><a href="#3-文件存储路径与权限和权限" class="headerlink" title="3. 文件存储路径与权限和权限"></a>3. <a href="https://blog.csdn.net/u010937230/article/details/73303034" target="_blank" rel="noopener">文件存储路径与权限</a>和<a href="https://www.cnblogs.com/whoislcj/p/6137398.html" target="_blank" rel="noopener">权限</a></h3><blockquote><ol><li>文件存储分为内部存储和外部存储</li><li>内部存储<ol><li>Environment.getDataDirectory() = /data //这个方法是获取内部存储的根路径</li><li>getFilesDir().getAbsolutePath() = /data/user/0/packname/files //这个方法是获取某个应用在内部存储中的files路径</li><li>getCacheDir().getAbsolutePath() = /data/user/0/packname/cache  //这个方法是获取某个应用在内部存储中的cache路径</li><li>getDir(“myFile”, MODE_PRIVATE).getAbsolutePath() = /data/user/0/packname/app_myFile</li></ol></li><li>外部存储<ol><li>Environment.getExternalStorageDirectory().getAbsolutePath() = /storage/emulated/0  //这个方法是获取外部存储的根路径</li><li>Environment.getExternalStoragePublicDirectory(“”).getAbsolutePath() = /storage/emulated/0 这个方法是获取外部存储的根路径 3. getExternalFilesDir(“”).getAbsolutePath() = /storage/emulated/0/Android/data/packname/files 这个方法是获取某个应用在外部存储中的files路径 4. getExternalCacheDir().getAbsolutePath() = /storage/emulated/0/Android/data/packname/cache 这个方法是获取某个应用在外部存储中的cache路径</li></ol></li><li>清楚数据和卸载APP时， 内外存储的file和cache都会被删除</li><li>内部存储file和cache不需要权限；外部存储低版本上（19以下）file和cache需要权限，高版本不需要权限；Environment.getExternalStorageDirectory()需要权限</li></ol></blockquote><h3 id="4-SQLite"><a href="#4-SQLite" class="headerlink" title="4. SQLite"></a>4. <a href="https://www.jianshu.com/p/b6634c0c8c0b" target="_blank" rel="noopener">SQLite</a></h3><blockquote><ol><li>SQLite每个数据库都是以单个文件（.db）的形式存在，这些数据都是以B-Tree的数据结构形式存储在磁盘上。</li><li>使用SQLiteDatabase的insert，delete等方法或者execSQL方法默认都开启了事务，如果操作顺利完成才会更新.db数据库。事务的实现是依赖于名为rollback journal文件，借助这个临时文件来完成原子操作和回滚功能。在/data/data//databases/目录下看到一个和数据库同名的.db-journal文件。</li></ol></blockquote><blockquote><p><a href="https://www.jianshu.com/p/2398aad3bd61" target="_blank" rel="noopener">如何对SQLite数据库中进行大量的数据插入?</a><br> <a href="https://www.imooc.com/article/14069" target="_blank" rel="noopener">显示的开启事务</a></p></blockquote><pre><code>db.beginTransaction();try {   ...   db.setTransactionSuccessful();} finally {   db.endTransaction();  }复制代码</code></pre><h3 id="5-数据库的升级"><a href="#5-数据库的升级" class="headerlink" title="5. 数据库的升级"></a>5. <a href="https://blog.csdn.net/qq_35114086/article/details/53319093" target="_blank" rel="noopener">数据库的升级</a></h3><blockquote><ol><li>Android中提供了SqLiteOpenHelper类，当版本更新时，会自动调用onUpgrade方法，我们在此方法中升级</li><li>如果修改已有表，可以才有临时表的方法：<ol><li>将已有表重命名成一个临时表</li><li>创建新表</li><li>拷贝</li><li>删除临时表</li></ol></li></ol></blockquote><h3 id="6-如何导入外部数据库"><a href="#6-如何导入外部数据库" class="headerlink" title="6. 如何导入外部数据库"></a>6. 如何导入外部数据库</h3><blockquote><ol><li>把数据库db文件放在res/raw下打包进apk</li><li>通过FileInputStream读取db文件，通过FileOutputStream将文件写入/data/data/包名/database下</li></ol></blockquote><h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><hr><h3 id="0-android-gravity与android-layout-gravity的区别"><a href="#0-android-gravity与android-layout-gravity的区别" class="headerlink" title="0. android:gravity与android:layout_gravity的区别"></a>0. android:gravity与android:layout_gravity的区别</h3><blockquote><ol><li>gravity是控制当前View内布局的位置</li><li>layout_gravity是控制View在父布局中的位置</li></ol></blockquote><h3 id="1-View的绘制流程"><a href="#1-View的绘制流程" class="headerlink" title="1. View的绘制流程"></a>1. View的绘制流程</h3><blockquote><p>从ViewRootImpl的performTraversals开始，经过measure，layout,draw 三个流程。draw流程结束以后就可以在屏幕上看到view了。</p></blockquote><h3 id="2-View的measureSpec-由谁决定-顶级view呢"><a href="#2-View的measureSpec-由谁决定-顶级view呢" class="headerlink" title="2. View的measureSpec 由谁决定?顶级view呢"></a>2. View的measureSpec 由谁决定?顶级view呢</h3><blockquote><ol><li>View的MeasureSpec由父容器的MeasureSpec和其自身的LayoutParams共同确定，</li><li>而对于DecorView是由它的MeasureSpec由窗口尺寸和其自身的LayoutParams共同确定。</li></ol></blockquote><h3 id="3-View和ViewGroup的基本绘制流程"><a href="#3-View和ViewGroup的基本绘制流程" class="headerlink" title="3. View和ViewGroup的基本绘制流程"></a>3. <a href="https://blog.csdn.net/u011155781/article/details/52584044" target="_blank" rel="noopener">View和ViewGroup的基本绘制流程</a></h3><h4 id="View-1"><a href="#View-1" class="headerlink" title="View"></a>View</h4><blockquote><ol><li>measure -&gt; onMeasure</li><li>layout（onLayout方法是空的，因为他没有child了）</li><li>draw -&gt; ondraw</li></ol></blockquote><h4 id="ViewGroup"><a href="#ViewGroup" class="headerlink" title="ViewGroup"></a>ViewGroup</h4><blockquote><ol><li>measure -&gt; onMeasure (onMeasure中需要调用childView的measure计算大小)</li><li>layout -&gt; onLayout （onLayout方法中调用childView的layout方法）</li><li>draw -&gt; onDraw （ViewGroup一般不绘制自己，ViewGroup默认实现dispatchDraw去绘制孩子）</li></ol></blockquote><h3 id="4-draw方法-大概有几个步骤"><a href="#4-draw方法-大概有几个步骤" class="headerlink" title="4. draw方法 大概有几个步骤"></a>4. draw方法 大概有几个步骤</h3><blockquote><ol><li>drawbackground</li><li>如果要视图显示渐变框，这里会做一些准备工作</li><li>draw自身内容</li><li>drawChild</li><li>如果需要, 绘制当前视图在滑动时的边框渐变效果</li><li>绘制装饰，如滚动条</li></ol></blockquote><h3 id="5-怎么控制另外一个进程的View显示"><a href="#5-怎么控制另外一个进程的View显示" class="headerlink" title="5. 怎么控制另外一个进程的View显示"></a>5. 怎么控制另外一个进程的View显示</h3><blockquote><p>RemoteView：RemoteViews实现了Parcelable接口，通过binder机制传递给远程进程，进程间view的显示</p></blockquote><h3 id="6-两指缩放"><a href="#6-两指缩放" class="headerlink" title="6. 两指缩放"></a>6. <a href="https://www.jianshu.com/p/0c863bbde8eb" target="_blank" rel="noopener">两指缩放</a></h3><blockquote><ol><li>为了解决多点触控问题，android在MotionEvent中引入了pointer概念</li><li>通过ACTION_DOWN、ACTION_POINTER_DOWN、ACTION_MOVE、ACTION_POINTER_UP、ACTION_UP来检测手机的动作</li><li>每个手指的位置可以通过getX（pointIndex）来获得，这样我们就能判断出滑动的距离</li><li>缩放有多种实现： 1. ImageView可以通过setImageMatrix（martix）来实现 2. 自定义View可以缩放Canvas的大小 3. 还可以设置LayoutParams来改变大小</li></ol></blockquote><h3 id="7-Scroller"><a href="#7-Scroller" class="headerlink" title="7. Scroller"></a>7. <a href="https://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&mid=2247484893&idx=1&sn=5874130932d4533064e40045055d0185&chksm=96cda490a1ba2d86491a65f34513e50b80a5d0ccbedae644225bc0a3d262505d43381b603310#rd" target="_blank" rel="noopener">Scroller</a></h3><blockquote><ol><li>Scroller 通常用来实现平滑的滚动</li><li>实现平滑滚动：<ol><li>新建Scroller，并设置合适的插值器</li><li>在View的computeScroll方法中调用scroller，查看当前应该滑动到的位置，并调用view的scrollTo或者scrollBy方法滑动</li><li>调用Scroller的start方法开始滑动</li></ol></li></ol></blockquote><h3 id="8-ScrollView时候滑动到底部"><a href="#8-ScrollView时候滑动到底部" class="headerlink" title="8. ScrollView时候滑动到底部"></a>8. <a href="https://blog.csdn.net/wang2963973852/article/details/60135960" target="_blank" rel="noopener">ScrollView时候滑动到底部</a></h3><blockquote><ol><li>滑动时会调用onScrollChange方法，在该方法中监听状态</li><li>判断childView.getMeasureHeight（总高度） == getScrollY（滑动的高度） + chilView.getHeight(可见高度)</li></ol></blockquote><h3 id="9-View事件的分发"><a href="#9-View事件的分发" class="headerlink" title="9. View事件的分发"></a>9. <a href="https://www.jianshu.com/p/38015afcdb58" target="_blank" rel="noopener">View事件的分发</a></h3><blockquote><ol><li>思想：委托子View处理，子View不能处理则自己处理</li><li>委托过程：activity -&gt; window -&gt; viewGroup -&gt; view</li><li>处理事件方法的优先级：onTouchListener &gt; onTouchEvent &gt; onClickListener</li></ol></blockquote><pre><code>伪代码public boolean dispatchTouchEvent(MotionEvent ev){boolean consume = false;if(onInterceptTouchEvent(ev)){  consume = onTouchEvent(ev)} else {  consume = child.dispatchTouchEvent(ev);}return consume;}复制代码</code></pre><blockquote><ol><li>完整的事件通常包括Down、Move、Up，当down事件被拦截下来以后，move和up就不再走intercept方法，而是直接被传递给当前view处理</li></ol></blockquote><h3 id="10-什么时候执行ACTION-CANCEL"><a href="#10-什么时候执行ACTION-CANCEL" class="headerlink" title="10. 什么时候执行ACTION_CANCEL"></a>10. <a href="https://www.jianshu.com/p/8360d7150786" target="_blank" rel="noopener">什么时候执行ACTION_CANCEL</a></h3><blockquote><ol><li>一个点击或者活动事件包含ACTION_DOWN，ACTION_MOVE,ACTION_UP等</li><li>当子View处理了ACTION_DOWN事件之后，后续的ACTION_MOVE,ACTION_UP都会直接交由这个子View处理</li><li>如果此时父View拦截了ACTION_MOVE,ACTION_UP，那么子View会收到一个ACTION_CANCEL</li><li>场景举例：点击一个控件，并滑动到控件外，此时次控件会收到一个ACTION_CALNCEL</li></ol></blockquote><h3 id="11-滑动冲突"><a href="#11-滑动冲突" class="headerlink" title="11. 滑动冲突"></a>11. 滑动冲突</h3><blockquote><p>外部拦截：重写onInterceptTouchEvent方法<br> 内部拦截：重写dispatchTouchEvent方法，同时配合requestDisAllowInterceptTouchEvent方法</p></blockquote><h3 id="12-ListView怎么优化（举例）"><a href="#12-ListView怎么优化（举例）" class="headerlink" title="12. ListView怎么优化（举例）"></a>12. <a href="https://www.jianshu.com/p/b7741023bc6f" target="_blank" rel="noopener">ListView怎么优化</a>（举例）</h3><blockquote><ol><li>复用convertView，对convetView进行判空，当convertView不为空时重复使用，为空则初始化，从而减少了很多不必要的View的创建、减少findViewById的次数，</li><li>采用ViewHolder模式缓存item条目的引用</li><li>避免在getview方法中做耗时操作</li><li>避免使用半透明或者在活动中取消半透明</li><li>图片异步加载，待滑动停止后再加载</li><li>局部刷新</li></ol></blockquote><h3 id="13-RecyclerView"><a href="#13-RecyclerView" class="headerlink" title="13. RecyclerView"></a>13. <a href="https://blog.csdn.net/xx326664162/article/details/61199895" target="_blank" rel="noopener">RecyclerView</a></h3><p>RecyclerView 与 ListView 类似，都是通过缓存view提高性能，但是RecyclerView有更高的可定制性。下面是使用时的一些设置，通过这些设置来达到对view样式的自定义：其中1、2是必须设置的，3、4可选</p><blockquote><ol><li>想要控制其item们的排列方式，请使用布局管理器LayoutManager</li><li>如果要创建一个适配器，请使用RecyclerView.Adapter （Adapter通过范型的方式，帮助我们生成ViewHolder）</li><li>想要控制Item间的间隔，请使用RecyclerView.ItemDecoration</li><li>想要控制Item增删的动画，请使用RecyclerView.ItemAnimator<br> 扩展：RecyclerView可以很方便的进行局部刷新（notifyItemChanged（））</li></ol></blockquote><h3 id="14-RecyclerView绘制流程"><a href="#14-RecyclerView绘制流程" class="headerlink" title="14. RecyclerView绘制流程"></a>14. <a href="https://blog.csdn.net/hfyd_/article/details/53910631?_t_t_t=0.81394347618334" target="_blank" rel="noopener">RecyclerView绘制流程</a></h3><blockquote><p>RecyclerView的Measure和Layout是委托LayoutManager进行的</p></blockquote><h3 id="15-RecyclerView的局部刷新"><a href="#15-RecyclerView的局部刷新" class="headerlink" title="15. RecyclerView的局部刷新"></a>15. RecyclerView的局部刷新</h3><blockquote><ol><li>调用notifyItemChange方法</li><li>如果想刷新某个item的局部，可以有两种方法<ol><li><a href="https://blog.csdn.net/jdsjlzx/article/details/52893469" target="_blank" rel="noopener">notifyItemRangeChanged方法</a></li><li><a href="https://www.jianshu.com/p/c5ca75d3a78c" target="_blank" rel="noopener">根据position获取对应的ViewHolder，更新其View</a></li></ol></li></ol></blockquote><h3 id="16-RecyclerView的缓存"><a href="#16-RecyclerView的缓存" class="headerlink" title="16. RecyclerView的缓存"></a>16. <a href="https://zhuanlan.zhihu.com/p/23339185" target="_blank" rel="noopener">RecyclerView的缓存</a></h3><blockquote><ol><li>RecyclerView采用四级缓存，ListView采用两级缓存</li><li>四级缓存:<ol><li>mAttachedScrap：用于屏幕内的itemView快速复用，不需要create和bind</li><li>mCacheViews：用于屏幕外的itemView快速复用，默认为两个，通过postion查找，不需要create和bind</li><li>mViewCacheExtentsion：需要用户定制，默认不实现</li><li>mRecyclerPool：默认上限5个；不需要create，需要bind；多个RecyclerView可以共用一个pool</li></ol></li><li>总结：缓存方面和ListView最大区别是mCacheViews可以缓存屏幕外的item，并且不需要重新bind</li></ol></blockquote><h3 id="17-RecyclerView-自定义LayoutManager"><a href="#17-RecyclerView-自定义LayoutManager" class="headerlink" title="17. RecyclerView 自定义LayoutManager"></a>17. <a href="https://blog.csdn.net/qibin0506/article/details/52676670" target="_blank" rel="noopener">RecyclerView 自定义LayoutManager</a></h3><blockquote><ol><li>重写onLayoutChildren方法<ol><li>调用detachAndScrapAttachedViews方法，缓存View</li><li>计算并设置每个children的位置</li><li>调用fill方法</li></ol></li><li>重写fill方法进行布局</li><li>重写canScrollVertically和scrollVerticallyBy方法，支持滑动</li></ol></blockquote><h3 id="18-SurfaceView与View的区别"><a href="#18-SurfaceView与View的区别" class="headerlink" title="18. SurfaceView与View的区别"></a>18. <a href="https://blog.csdn.net/Picasso_L/article/details/49817725" target="_blank" rel="noopener">SurfaceView</a>与View的区别</h3><blockquote><ol><li>View主要适用于主动更新的情况下，而SurfaceView主要适用于被动更新，例如频繁地刷新；</li><li>View在主线程中对画面进行刷新，而SurfaceView通常会通过一个子线程来进行页面刷新</li><li>而SurfaceView在底层实现机制中就已经实现了<a href="https://bbs.csdn.net/topics/390834677" target="_blank" rel="noopener">双缓冲机制</a></li></ol></blockquote><h3 id="19-view-的布局"><a href="#19-view-的布局" class="headerlink" title="19. view 的布局"></a>19. view 的布局</h3><p>布局全都继承自ViewGroup</p><blockquote><ol><li>FrameLayout(框架布局) ：没有对child view的摆布进行控制，这个布局中所有的控件都会默认出现在视图的左上角。</li><li>LinearLayout(线性布局)：横向或竖向排列内部View</li><li>RelativeLayout(相对布局)：以view的相对位置进行布局</li><li>TableLayout（表格布局）：将子元素的位置分配到行或列中，一个TableLayout由许多的TableRow组成</li><li>GridLayout:和TableLayout类似</li><li>ConstraintLayout（约束布局）：和RelativeLayout类似，还可以通过GuideLine辅助布局，适合图形化操作<strong>推荐使用</strong></li><li>AbsoluteLayout（绝对布局）：已经被废弃</li></ol></blockquote><h3 id="20-线性布局-相对布局-效率哪个高"><a href="#20-线性布局-相对布局-效率哪个高" class="headerlink" title="20. 线性布局 相对布局 效率哪个高"></a>20. <a href="https://www.jianshu.com/p/8a7d059da746" target="_blank" rel="noopener">线性布局 相对布局 效率哪个高</a></h3><blockquote><p>相同层次下，因为相对布局会调用两次measure，所以线性高 当层次较多时，建议使用相对布局</p></blockquote><h3 id="21-View-的invalidate-postInvalidate-requestLayout方法"><a href="#21-View-的invalidate-postInvalidate-requestLayout方法" class="headerlink" title="21. View 的invalidate\postInvalidate\requestLayout方法"></a>21. View 的invalidate\postInvalidate\requestLayout方法</h3><blockquote><ol><li>invalidate 会调用onDraw进行重绘，只能在主线程</li><li>postInvalidate 可以在其他线程</li><li>requestLayout会调用onLayout和onMeasure，不一定会调用onDraw</li></ol></blockquote><h3 id="22-更新UI方式"><a href="#22-更新UI方式" class="headerlink" title="22. 更新UI方式"></a>22. 更新UI方式</h3><blockquote><ol><li>Activity.runOnUiThread(Runnable)</li><li>View.post(Runnable),View.postDelay(Runnable,long)</li><li>Handler</li></ol></blockquote><h3 id="23-postDelayed原理"><a href="#23-postDelayed原理" class="headerlink" title="23. postDelayed原理"></a>23. <a href="https://blog.csdn.net/qingtiantianqing/article/details/72783952" target="_blank" rel="noopener">postDelayed原理</a></h3><blockquote><ol><li>不管是view的postDelayed方法，还是Handler的post方法，通过包装后最终都会走Handler的sendMessageAtTime方法</li><li>随后会通过MessageQueue的enqueueMessage方法将message加入队列，加入时按时间排序，我们可以理解成Message是一个有序队列，时间是其排序依据</li><li>当Looper从MessageQueue中调用next方法取出message时，如果还没有到时间，就会阻塞等待</li><li>2中当有新的message加完成后，会检查当前有没有3中设置的阻塞，需不需要唤起，如果需要唤起则唤起</li></ol></blockquote><h3 id="24-当一个TextView的实例调用setText-方法后执行了什么"><a href="#24-当一个TextView的实例调用setText-方法后执行了什么" class="headerlink" title="24. 当一个TextView的实例调用setText()方法后执行了什么"></a>24. 当一个TextView的实例调用setText()方法后执行了什么</h3><blockquote><ol><li>setText后会对text做一些处理，如设置AutoLink，Ellipsize等</li><li>在合适的位置调用TextChangeListener</li><li>调用requestLayout和invalidate方法</li></ol></blockquote><h3 id="25-自定义View执行invalidate-方法-为什么有时候不会回调onDraw"><a href="#25-自定义View执行invalidate-方法-为什么有时候不会回调onDraw" class="headerlink" title="25. 自定义View执行invalidate()方法,为什么有时候不会回调onDraw()"></a>25. 自定义View执行invalidate()方法,为什么有时候不会回调onDraw()</h3><blockquote><ol><li>View 的draw方法会根据很多标识位来决定是否需要调用onDraw，包括是否绑定在当前窗口等</li></ol></blockquote><h3 id="26-View-的生命周期"><a href="#26-View-的生命周期" class="headerlink" title="26. View 的生命周期"></a>26. <a href="https://www.jianshu.com/p/08e6dab7886e" target="_blank" rel="noopener">View 的生命周期</a></h3><blockquote><ol><li>构造方法</li><li>onFinishInflate：该方法当View及其子View从XML文件中加载完成后会被调用。</li><li>onVisibilityChanged</li><li>onAttachedToWindow</li><li>onMeasure</li><li>onSizeChanged</li><li>onLayout</li><li>onDraw</li><li>onWindowFocusChanged</li><li>onWindowVisibilityChanged</li><li>onDetachedFromWindow</li></ol></blockquote><h3 id="27-ListView针对多种item的缓存是如何实现的"><a href="#27-ListView针对多种item的缓存是如何实现的" class="headerlink" title="27. ListView针对多种item的缓存是如何实现的"></a>27. <a href="https://www.cnblogs.com/wangzehuaw/p/5383600.html" target="_blank" rel="noopener">ListView针对多种item的缓存是如何实现的</a></h3><blockquote><ol><li>维护一个缓存view的数组，数组长度是 adapter的getViewItemTypeCount</li><li>通过getItemViewType获得缓存view 的数组，取出缓存的view</li></ol></blockquote><h3 id="28-Canvas-save-跟Canvas-restore-的调用时机"><a href="#28-Canvas-save-跟Canvas-restore-的调用时机" class="headerlink" title="28. Canvas.save()跟Canvas.restore()的调用时机"></a>28. <a href="https://blog.csdn.net/u014788227/article/details/52250208" target="_blank" rel="noopener">Canvas.save()跟Canvas.restore()的调用时机</a></h3><blockquote><p>save：用来保存Canvas的状态。save之后，可以调用Canvas的平移、放缩、旋转、错切、裁剪等操作。 restore：用来恢复Canvas之前保存的状态。防止save后对Canvas执行的操作对后续的绘制有影响。</p></blockquote><h2 id="WebView"><a href="#WebView" class="headerlink" title="WebView"></a>WebView</h2><hr><h3 id="0-WebView-优化"><a href="#0-WebView-优化" class="headerlink" title="0. WebView 优化"></a>0. <a href="https://www.jianshu.com/p/95d4d73be3d1" target="_blank" rel="noopener">WebView 优化</a></h3><blockquote><ol><li>替换内核：不同的rom厂商对webview的优化不同，可能出现兼容性和速度问题，可以替换成X5内核等来解决兼容性问题，同时提高加载速度</li><li>WebView初始化提前：WebView初始化是一个耗时的过程，我们可以预先将WebView初始化好，例如使用全局webview</li><li>开启缓存，可以明显提升第二次加载的速度</li><li>优化dns解析速度：使用和api一样的域名，这样dns不用二次解析，可以提高速度</li><li>预加载：将需要的文件资源通过native方法提前加载好或者打包进apk，需要使用时直接使用</li><li>延迟加载：延迟加载部分资源，在界面要显示的数据加载完成后再加载，如图片资源，js等</li><li>对于webview内存泄漏：单独开一个进程，Activity销毁时手动回收资源</li></ol></blockquote><h3 id="1-WebView与Native交互"><a href="#1-WebView与Native交互" class="headerlink" title="1. WebView与Native交互"></a>1. WebView与Native交互</h3><blockquote><ol><li><p>WebView中拦截网址：设置setWebViewClient，重写shouldOverrideUrlLoading</p></li><li><p>js与native交互</p><p>：</p><ol><li>mWebView.getSettings().setJavaScriptEnabled(true);</li><li>mWebView.addJavascriptInterface(new JSInterface(), “jsInterface”);</li><li>其他js调用Native方案：通过prompt, alert等，在webClient中重写拦截相应的方法</li></ol></li></ol></blockquote><h2 id="性能相关"><a href="#性能相关" class="headerlink" title="性能相关"></a>性能相关</h2><hr><h3 id="0-Android中ViewHolder，Handler等为什么要被声明成静态内部类（static）"><a href="#0-Android中ViewHolder，Handler等为什么要被声明成静态内部类（static）" class="headerlink" title="0. Android中ViewHolder，Handler等为什么要被声明成静态内部类（static）"></a>0. <a href="https://juejin.im/post/5a951f615188257a61326473" target="_blank" rel="noopener">Android中ViewHolder，Handler等为什么要被声明成静态内部类（static）</a></h3><blockquote><p>非静态内部类会持有外部类的引用，在一些情况下很可能造成内存泄漏，所以一般声明为静态内部类，但并不是说一定要生命成静态内部类。</p></blockquote><h3 id="1-Android中捕获-App崩溃和重启"><a href="#1-Android中捕获-App崩溃和重启" class="headerlink" title="1. Android中捕获 App崩溃和重启"></a>1. <a href="https://blog.csdn.net/jiaweihaoku/article/details/78053403" target="_blank" rel="noopener">Android中捕获 App崩溃和重启</a></h3><blockquote><ol><li>实现Thread.UncaughtExceptionHandler()接口，在uncaughtException方法中完成对崩溃的上报和对App的重启。</li><li>实现自定义Application，并在Application中注册1中Handler实例。</li></ol></blockquote><h3 id="2-LruCache实现原理"><a href="#2-LruCache实现原理" class="headerlink" title="2. LruCache实现原理"></a>2. <a href="https://www.cnblogs.com/tianzhijiexian/p/4248677.html" target="_blank" rel="noopener">LruCache实现原理</a></h3><blockquote><p>最近最少使用算法：内部通过LinkedHashMap来实现</p></blockquote><h3 id="3-Parcelable和Serializable"><a href="#3-Parcelable和Serializable" class="headerlink" title="3. Parcelable和Serializable"></a>3. Parcelable和Serializable</h3><blockquote><ol><li>都是序列化的方式</li><li>Serializable只需实现Serializable接口即可</li><li>Parcelable需要实现Parcelable接口，并重写writeToParcel和describeContents方法，并且实现一个Creator</li><li>Serializable虽然操作简单，但是需要大量IO操作，效率慢；Parcelable自已实现封送和解封（marshalled &amp;unmarshalled）操作不需要用反射，数据也存放在Native内存中，效率要快很多，在Android中更推荐使用Parcelable</li><li>由于不同版本Parcelable可能存在不同，在网络和磁盘存储时，推荐使用Parcelable</li></ol></blockquote><h3 id="4-加载合适比例的Bitmap到内存中"><a href="#4-加载合适比例的Bitmap到内存中" class="headerlink" title="4. 加载合适比例的Bitmap到内存中"></a>4. 加载合适比例的Bitmap到内存中</h3><pre><code>public static Bitmap decodeSampledBitmapFromResource(Resources res, int resId,        int reqWidth, int reqHeight) {    // 首先只解析图片资源的边界    final BitmapFactory.Options options = new BitmapFactory.Options();    options.inJustDecodeBounds = true;    BitmapFactory.decodeResource(res, resId, options);    //计算缩放值    options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);    // 用计算出来的缩放值解析图片    options.inJustDecodeBounds = false;    return BitmapFactory.decodeResource(res, resId, options);}public static int calculateInSampleSize(            BitmapFactory.Options options, int reqWidth, int reqHeight) {    // Raw height and width of image    final int height = options.outHeight;    final int width = options.outWidth;    int inSampleSize = 1;    if (height &gt; reqHeight || width &gt; reqWidth) {        final int halfHeight = height / 2;        final int halfWidth = width / 2;        // Calculate the largest inSampleSize value that is a power of 2 and keeps both        // height and width larger than the requested height and width.        while ((halfHeight / inSampleSize) &gt; reqHeight                &amp;&amp; (halfWidth / inSampleSize) &gt; reqWidth) {            inSampleSize *= 2;        }    }    return inSampleSize;}</code></pre><h3 id="5-图片的三级缓存"><a href="#5-图片的三级缓存" class="headerlink" title="5. 图片的三级缓存"></a>5. <a href="https://www.jianshu.com/p/2cd59a79ed4a" target="_blank" rel="noopener">图片的三级缓存</a></h3><blockquote><ol><li>首次加载 Android App 时，肯定要通过网络交互来获取图片，之后我们可以将图片保存至本地SD卡和内存中</li><li>之后运行 App 时，优先访问内存中的图片缓存</li><li>若内存中没有，则加载本地SD卡中的图片</li></ol></blockquote><h3 id="6-App保活"><a href="#6-App保活" class="headerlink" title="6. App保活"></a>6. <a href="https://segmentfault.com/a/1190000006251859" target="_blank" rel="noopener">App保活</a></h3><p>随着Google对Android系统的更新，以及国内厂商堆Room的定制，一些保活的手段已经失效或者不再适用，这里列举一些保活手段,实际中常常是多个方式并用</p><blockquote><ol><li>联系Room厂商加入白名单（或者引导用户手动加入白名单）</li><li>利用系统漏洞root进行提权，或者直接把本应用变成系统应用</li><li>Service设置成START_STICKY:kill 后会被重启（等待5秒左右），重传Intent，保持与重启前一样</li><li>提升service优先级:通过android:priority = “1000”这个属性设置最高优先级（可能已经失效）</li><li>onDestroy方法里重启service（效果不好）</li><li>监听广播（除了监听系统广播外，还可以利用友盟等第三方sdk做到应用相互唤起）</li><li>启动两个进程service相互监听，互相唤起（大部分room上失效）</li><li>在屏幕上保留1像素</li><li>注册系统同步服务</li><li>创建Native进程，双进程互相监听保活（5.0 以上失效）</li><li>利用JobSheduler保活</li></ol></blockquote><h3 id="7-如何判断APP被强杀"><a href="#7-如何判断APP被强杀" class="headerlink" title="7. 如何判断APP被强杀"></a>7. 如何判断APP被强杀</h3><blockquote><p><a href="https://www.jianshu.com/p/bce1164b83d8" target="_blank" rel="noopener">这里所说的强杀场景如这篇文章</a></p><ol><li>在Application中定义一个static常量，赋值为－1</li><li>在欢迎界面改为0</li><li>在BaseActivity判断该常量的值</li></ol></blockquote><h3 id="8-常见的内存泄漏（举例）"><a href="#8-常见的内存泄漏（举例）" class="headerlink" title="8. 常见的内存泄漏（举例）"></a>8. 常见的内存泄漏（举例）</h3><blockquote><ol><li>不恰当的使用static变量（或者向static集合中添加数据却忘了必要时移除数据）</li><li>忘记关闭各种连接，如IO流等</li><li><a href="https://github.com/francistao/LearningNotes/blob/master/Part1/Android/Handler内存泄漏分析及解决.md" target="_blank" rel="noopener">不恰当的内部类</a>：因为内部类持有外部类的引用，当内部类存活时间较长时，导致外部类也不能正确的回收（常发生在使用Handler的时候）</li><li>不恰当的单例模式：例如错误的将某个Activity给单例持有，或者在不该使用单例的地方使用了单例</li><li>使用错误的Context：Application 和 Activity的context生命周期不一样</li><li>webview造成的内存泄漏</li></ol></blockquote><h3 id="9-OOM异常是否可以被try…catch捕获"><a href="#9-OOM异常是否可以被try…catch捕获" class="headerlink" title="9. OOM异常是否可以被try…catch捕获"></a>9. OOM异常是否可以被try…catch捕获</h3><blockquote><ol><li>在发生地点可以捕获</li><li>但是OOM往往是由于内存泄漏造成的，泄漏的部分多数情况下不在try语句块里，所以catch后不久就会再次发生OOM</li><li>对待OOM的方案应该是找到内存泄漏的地方以及优化内存的占用</li></ol></blockquote><h3 id="10-什么是ANR，如何避免它"><a href="#10-什么是ANR，如何避免它" class="headerlink" title="10. 什么是ANR，如何避免它"></a>10. <a href="https://blog.csdn.net/a332324956/article/details/77800315" target="_blank" rel="noopener">什么是ANR，如何避免它</a></h3><blockquote><ol><li>ANR是Application Not Responding 的缩写,当应用程序无响应时，会弹出ANR窗口，让用户选择继续等待还是关闭应用。</li><li>处理超过时间会造成ANR的地方：触摸操作等（5s）；BroadCast（10s）；Service（20s）</li><li>避免：不要在主线程中做耗时操作</li></ol></blockquote><h3 id="11-什么情况会导致Force-Close-？如何避免？能否捕获导致其的异常？"><a href="#11-什么情况会导致Force-Close-？如何避免？能否捕获导致其的异常？" class="headerlink" title="11. 什么情况会导致Force Close ？如何避免？能否捕获导致其的异常？"></a>11. 什么情况会导致Force Close ？如何避免？能否捕获导致其的异常？</h3><blockquote><ol><li>出现运行时异常（如nullpointer/数组越界等），而我们又没有try catch捕获，可能造成Force Close</li><li>避免：需要我们在编程时谨慎处理逻辑，提高代码健壮性。如对网络传过来的未知数据先判空，再处理；此外还可以通过静态代码检查来帮助我们提高代码质量</li><li>此外，我们还可以在Application初始化时注册<a href="https://www.jianshu.com/p/84eba8efa45e" target="_blank" rel="noopener">UncaultExceptionHandler</a>，来捕捉这些异常重启我们的程序</li></ol></blockquote><h3 id="12-DDMS和TraceView"><a href="#12-DDMS和TraceView" class="headerlink" title="12. DDMS和TraceView"></a>12. DDMS和TraceView</h3><blockquote><ol><li>DDMS是一个程序执行查看器，在里面可以看见线程和堆栈等信息</li><li>TraceView是一个性能分析器<br> 扩展： Android Studio 3 中用Profiler代替了DDMS，可以监视分析CPU，网络，内存的实时情况，更加方便</li></ol></blockquote><h3 id="13-LRUCache原理"><a href="#13-LRUCache原理" class="headerlink" title="13. LRUCache原理"></a>13. LRUCache原理</h3><blockquote><ol><li>通过LinkedHashMap实现的</li><li>LinkedHashMap的特性：LinkedHashMap是一个双向链表，当构造函数中accessOrder为true时：调用put()方法，会在集合头部添加元素时，会调用trimToSize()判断缓存是否已满，如果满了就用LinkedHashMap的迭代器删除队尾元素，即近期最少访问的元素。当调用get()方法访问缓存对象时，就会调用LinkedHashMap的get()方法获得对应集合元素，同时会更新该元素到队头</li></ol></blockquote><h3 id="14-模块化的好处"><a href="#14-模块化的好处" class="headerlink" title="14. 模块化的好处"></a>14. 模块化的好处</h3><blockquote><ol><li>不同模块间解偶，方便复用</li><li>单个模块支持独立编译，并行开发，提高开发和测试效率</li></ol></blockquote><h3 id="15-组件化"><a href="#15-组件化" class="headerlink" title="15. 组件化"></a>15. 组件化</h3><blockquote><ol><li>组件化是已复用为目的的</li><li>多个团队可能公用一个组件</li></ol></blockquote><h3 id="16-SparseArray"><a href="#16-SparseArray" class="headerlink" title="16. SparseArray"></a>16. SparseArray</h3><blockquote><ol><li>SparseArray通过两个数组实现，key为int型，value为Object型</li><li>适用于数据量较小时</li><li>通过二分法插入和删除数据</li></ol></blockquote><h3 id="17-APP启动耗时"><a href="#17-APP启动耗时" class="headerlink" title="17. APP启动耗时"></a>17. <a href="https://www.jianshu.com/p/c967653a9468" target="_blank" rel="noopener">APP启动耗时</a></h3><blockquote><ol><li>启动分为冷启动（包含初始化Application）和热启动，冷启动又可以分为第一次启动（会有额外的初始化数据库等操作）和不是第一次启动</li><li>开发时本地可以用adb命令获取启动时常：adb shell am start -w packagename/activity</li><li>线上可以在各个关键地方埋点统计时常</li></ol></blockquote><h3 id="18-Android启动优化"><a href="#18-Android启动优化" class="headerlink" title="18. Android启动优化"></a>18. <a href="https://www.jianshu.com/p/f5514b1a826c" target="_blank" rel="noopener">Android启动优化</a></h3><blockquote><ol><li>启动优化的目的是提高用户感知的启动速度</li><li>可以采用TraceView等分析耗时，找出优化方向</li><li>优化的思路：<ol><li>利用提前展示出来的Window，设置Theme，快速展示出来一个界面，给用户快速反馈的体验（启动后再改变回来）</li><li>异步初始化一些第三方SDK</li><li>延迟初始化</li><li>针对性的优化算法，减少耗时</li></ol></li></ol></blockquote><h3 id="19-性能调优"><a href="#19-性能调优" class="headerlink" title="19. 性能调优"></a>19. <a href="http://www.trinea.cn/android/performance/" target="_blank" rel="noopener">性能调优</a></h3><blockquote><ol><li>性能调优包括很多方面：包括代码执行效率、网络、布局、内存、数据库、业务逻辑，打包速度等</li><li>需要针对具体问题具体分析，找到性能瓶颈：</li><li>善于借助工具，例如使用traceview跟踪，或者打点统计，profiler，leak canary等</li></ol></blockquote><h4 id="网络优化："><a href="#网络优化：" class="headerlink" title="网络优化："></a><a href="http://www.trinea.cn/android/mobile-performance-optimization/" target="_blank" rel="noopener">网络优化</a>：</h4><blockquote><ol><li>不用域名,用ip直连</li><li>请求合并与拆分</li><li>请求数据的缩小：删除无用数据，开启Gzip压缩</li><li>精简的数据格式：json/webp/根据设备和网络环境的不同采用不同分辨率图片</li><li>数据缓存</li><li>预加载</li><li>连接的复用：使用http2.0 (效率提升30%)<br> 扩展：<a href="https://mp.weixin.qq.com/s/N16jX2zRT3mlaJF4ixDhMg" target="_blank" rel="noopener">JD Android客户端网络性能调优之HTTP/2协议升级 </a></li></ol></blockquote><h4 id="布局优化"><a href="#布局优化" class="headerlink" title="布局优化"></a><a href="http://www.trinea.cn/android/layout-performance/" target="_blank" rel="noopener">布局优化</a></h4><blockquote><ol><li>合理的使用include/merge/viewstub等</li><li>减少布局层次，减少不必要的view和节点</li><li>使用布局缓存，避免重复inflate<br> 其他：可以用hierarchy viewer等工具进行分析</li></ol></blockquote><h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a><a href="http://www.trinea.cn/android/java-android-performance/" target="_blank" rel="noopener">代码优化</a></h4><blockquote><ol><li>降低执行时间：如优化算法和数据结构/利用多线程/缓存(包括对象缓存、线程池、IO 缓存、网络缓存等)/JNI/需求优化</li><li>同步改异步：例如使用surfaceview</li><li>错峰：提前或者延迟操作，比如启动中第三方sdk的加载</li></ol></blockquote><h4 id="APK瘦身"><a href="#APK瘦身" class="headerlink" title="APK瘦身"></a><a href="https://blog.csdn.net/vfush/article/details/52266843" target="_blank" rel="noopener">APK瘦身</a></h4><blockquote><ol><li>分析APK<ol><li>使用Android Studio的分析器分析apk结构</li><li>使用lint分析无用代码和资源</li><li>或者使用第三方工具，如NimbleDroid/ClassShark</li></ol></li><li>删除无用资源<ol><li>对无用资源和代码删除</li><li>优化结构，对重复资源去重</li><li>对依赖去重，依赖多个功能类似的sdk时，只保留一个</li><li>去除不需要的依赖，如语言support包可能包含多种语言，配置只保留我们需要的资源等</li><li>开启gradle的ProGuard/Code shrinking/minifyEnabled等，自动去除不需要的资源和代码】</li></ol></li><li>压缩已用资源<ol><li>选取适当的图片格式，如webp</li><li>对图片进行压缩</li><li>选取合适的依赖包，而不是直接依赖V7包等</li><li>使用微信的打包插件AndResGuard对图片进行压缩</li><li>使用facebook的ReDex对dex文件进行压缩</li></ol></li><li>通过网络按需加载</li></ol></blockquote><h3 id="20-有什么提高编译速度的方法"><a href="#20-有什么提高编译速度的方法" class="headerlink" title="20. 有什么提高编译速度的方法"></a>20. 有什么提高编译速度的方法</h3><blockquote><ol><li>提高电脑配置</li><li>优化Android studio配置<ol><li>加大内存；</li><li>使用守护进程；</li><li>开启instant Run</li><li>使用离线gradle</li><li>使用新版的gradle</li></ol></li><li>优化项目<ol><li>使用第三方编译如[阿里的Freeline](<a href="https://www.freelinebuild.com/docs/zh_cn/###" target="_blank" rel="noopener">https://www.freelinebuild.com/docs/zh_cn/###</a></li><li>debug模式下可以不开启混淆等</li><li><a href="http://stormzhang.com/android/2015/03/01/android-reference-local-aar/" target="_blank" rel="noopener">模块化</a>，多模块时使用aar包避免反复编译</li></ol></li></ol></blockquote><h3 id="21-延迟加载的实现"><a href="#21-延迟加载的实现" class="headerlink" title="21. 延迟加载的实现"></a>21. <a href="https://www.jianshu.com/p/a0e242d57360" target="_blank" rel="noopener">延迟加载的实现</a></h3><blockquote><ol><li>myHandler.postDelayed(mLoadingRunnable, DEALY_TIME);</li><li></li></ol></blockquote><pre><code> getWindow().getDecorView().post(new Runnable() {    @Override   public void run() {        myHandler.post(mLoadingRunnable);   }  });复制代码</code></pre><blockquote><ol><li><a href="https://www.jianshu.com/p/545cf65c4f5e" target="_blank" rel="noopener">监听MessageQueue，当空闲时执行任务</a></li></ol></blockquote><pre><code> // 拿到主线程的MessageQueue Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {       @Override public boolean queueIdle() {            // 在这里去处理你想延时加载的东西            delayLoad();            // 最后返回false，后续不用再监听了。           return false;            }   });复制代码</code></pre><h3 id="22-ArrayMap"><a href="#22-ArrayMap" class="headerlink" title="22. ArrayMap"></a>22. <a href="https://www.jianshu.com/p/ba65a0aeec44" target="_blank" rel="noopener">ArrayMap</a></h3><blockquote><ol><li>ArrayMap 是Android中的一种用时间换空间的容器，用来替代HashMap</li><li>不适合大量数据或者有大量删除</li><li>采用二分查找</li><li>原理： 0. 使用两个数组进行存储<ol><li>数组1储存key的HashCode</li><li>数组2储存key和value；value位置为key位置左移1位再加1</li><li>hash冲突的解决：寻找下一个空位，因为查询时会比较hashcode和key，所以不会有问题</li></ol></li></ol></blockquote><h3 id="23-Bitmap没有必要主动recycle"><a href="#23-Bitmap没有必要主动recycle" class="headerlink" title="23. Bitmap没有必要主动recycle"></a>23. Bitmap没有必要主动recycle</h3><p><a href="https://developer.android.com/topic/performance/graphics/manage-memory" target="_blank" rel="noopener">Google Guide-manage bitmap manager</a></p><p><a href="https://developer.android.com/topic/performance/graphics/cache-bitmap.html" target="_blank" rel="noopener">Google Guide-Cache Bitmap</a></p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * Free the native object associated with this bitmap, and clear the     * reference to the pixel data. This will not free the pixel data synchronously;     * it simply allows it to be garbage collected if there are no other references.     * The bitmap is marked as "dead", meaning it will throw an exception if     * getPixels() or setPixels() is called, and will draw nothing. This operation     * cannot be reversed, so it should only be called if you are sure there are no     * further uses for the bitmap. This is an advanced call, and normally need     * not be called, since the normal GC process will free up this memory when     * there are no more references to this bitmap.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">recycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>mRecycled <span class="token operator">&amp;&amp;</span> mNativePtr <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">nativeRecycle</span><span class="token punctuation">(</span>mNativePtr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// return value indicates whether native pixel object was actually recycled.</span>                <span class="token comment" spellcheck="true">// false indicates that it is still in use at the native level and these</span>                <span class="token comment" spellcheck="true">// objects should not be collected now. They will be collected later when the</span>                <span class="token comment" spellcheck="true">// Bitmap itself is collected.</span>                mBuffer <span class="token operator">=</span> null<span class="token punctuation">;</span>                mNinePatchChunk <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            mRecycled <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>“<em>This will not free the pixel data synchronously; it simply allows it to be garbage collected if there are no other references.</em>”。<br>recycle确实不是立即回收对应bitmap的内存，因为不是synchronously</p><h2 id="系统实现及原理"><a href="#系统实现及原理" class="headerlink" title="系统实现及原理"></a>系统实现及原理</h2><hr><h3 id="0-AsyncTask"><a href="#0-AsyncTask" class="headerlink" title="0. AsyncTask"></a>0. AsyncTask</h3><blockquote><ol><li>为我们封装了thread和handler，并在内部实现了线程池，是一个轻量级的线程方案</li><li>缺点：不同版本实现方式可能不一样，例如线程池有可能是串行的（最新版本是并行的）</li><li>缺点：可定制化程度不高，例如我们不能很方便地cancel线程</li></ol></blockquote><h3 id="1-AsyncTask是顺序执行么，for循环中执行200次new-AsyncTask并execute，会有异常吗"><a href="#1-AsyncTask是顺序执行么，for循环中执行200次new-AsyncTask并execute，会有异常吗" class="headerlink" title="1. AsyncTask是顺序执行么，for循环中执行200次new AsyncTask并execute，会有异常吗"></a>1. <a href="https://www.jianshu.com/p/79cc3c5fc9a3" target="_blank" rel="noopener">AsyncTask是顺序执行么</a>，for循环中执行200次new AsyncTask并execute，会有异常吗</h3><blockquote><ol><li>不同版本的AsyncTask 不一样，最新版本中是串行的</li><li>不会，因为串行执行时用的是一个ArrayDeque来存放Runnable</li><li>扩展：AsyncTask内部有并行的ThreadPoolExecutor，储存队列用的是LinkedBlockingQueue，大小是128；如果我们并行执行，会抛出运行时异常</li></ol></blockquote><h3 id="2-Android-渲染机制"><a href="#2-Android-渲染机制" class="headerlink" title="2. Android 渲染机制"></a>2. <a href="https://www.jianshu.com/p/1ef2a9e5aa91" target="_blank" rel="noopener">Android 渲染机制</a></h3><blockquote><ol><li>CPU对视图进行必要的计算：measure等</li><li>通过OpenGL 将CPU 处理过的数据交给GPU</li><li>GPU进行栅格化并存入缓存</li><li>Android 系统每隔16.6ms发出一个垂直同步信号，通知渲染</li></ol></blockquote><h3 id="3-Android中Application和Activity的Context对象的区别"><a href="#3-Android中Application和Activity的Context对象的区别" class="headerlink" title="3. Android中Application和Activity的Context对象的区别"></a>3. <a href="https://juejin.im/post/5a9514e25188257a865d9b5a" target="_blank" rel="noopener">Android中Application和Activity的Context对象的区别</a></h3><blockquote><ol><li>生命周期不一样</li><li>Application 不能showDialog</li><li>Application startActivity时必须new一个Task</li><li>Application layoutInflate直接使用默认主题，可能与当前主题不一样</li></ol></blockquote><h3 id="4-Zygote的启动过程"><a href="#4-Zygote的启动过程" class="headerlink" title="4. Zygote的启动过程"></a>4. <a href="https://www.jianshu.com/p/edeac788d60c" target="_blank" rel="noopener">Zygote的启动过程</a></h3><blockquote><ol><li>注册Zygote的socket监听端口，应用接收启动应用程序的消息</li><li>调用preload()方法加载系统资源，包括预加载类，Framework资源等</li><li>调用startSystemServer()方法启动SystemServer进程</li><li>调用runSelectLoop()方法进入监听和接收消息循环</li></ol></blockquote><h3 id="5-Handler、Looper、Message、MessageQueue"><a href="#5-Handler、Looper、Message、MessageQueue" class="headerlink" title="5. Handler、Looper、Message、MessageQueue"></a>5. <a href="https://blog.csdn.net/u012827296/article/details/51236614" target="_blank" rel="noopener">Handler、Looper、Message、MessageQueue</a></h3><p>它们的存在主要是为了线程间通信，通信的方式为：</p><blockquote><ol><li>在线程中调用Looper.prepare方法，生成一个looper与当前线程绑定（在生成looper的过程中，其构造方法在其内部创建了一个MessageQueue）</li><li>调用looper.loop方法，使当前线程循环读取MessageQueue中的message，并调用 msg.target.dispatchMessage方法，交由target处理（这里target是一个Handler实例）</li><li>new 一个Handler，在创建Handler时，需要为他指定looper（若不指定则是当前线程的looper），Handler会取出looper中的MessageQueue也作为自己的MessageQueue。</li><li>调用Handler的sendMessage方法发送Message信息（这个方法将Message的target设置成当前handler，并把它加入到MessageQueue中）</li></ol></blockquote><h3 id="6-为什么主线程Looper-loop不会ANR"><a href="#6-为什么主线程Looper-loop不会ANR" class="headerlink" title="6. 为什么主线程Looper.loop不会ANR"></a>6. <a href="https://www.jianshu.com/p/cfe50b8b0a41" target="_blank" rel="noopener">为什么主线程Looper.loop不会ANR</a></h3><blockquote><ol><li>ANR是应用程序无响应，原因是有事件在主线程运行时间过长造成新的事件无法处理，或者当前事件运行时间太长</li><li>Looper.loop会循环处理到来的Message，当MessageQueue为空是，线程处于阻塞状态，释放cpu资源</li></ol></blockquote><h3 id="7-Messenger-和-AIDL"><a href="#7-Messenger-和-AIDL" class="headerlink" title="7. Messenger 和 AIDL"></a>7. <a href="https://blog.csdn.net/u011974987/article/details/51243539" target="_blank" rel="noopener">Messenger</a> 和 AIDL</h3><blockquote><p>都是进城间通信的方式，AIDL使用Binder通信，Messenger通过AIDL实现</p><p>Messenger原理：Handler内部持有一个IMessenger实例，IMssenger时一个aidl的接口，Messenger初始化时这个IMssenger实例也传给了Messenger</p><p><a href="https://blog.csdn.net/jiwangkailai02/article/details/48098087" target="_blank" rel="noopener">区别</a>：1.Messenger是对AIDL的封装，使用简单；2.Messenger通过Handler处理传过来的Message，只能运行在一个线程中，我们在AIDL中可以运行多个线程；3.Messenger客户端调取服务方法的结果只能异步回调给客户端，AIDL可以同步回调</p></blockquote><h3 id="8-Binder"><a href="#8-Binder" class="headerlink" title="8. Binder"></a>8. <a href="https://www.jianshu.com/p/adaa1a39a274" target="_blank" rel="noopener">Binder</a></h3><p>瞎jj写点凑个数吧</p><blockquote><ol><li>Binder是Android中的一种进程间通信方式</li><li>Binder通信是通过驱动来实现的，原理是在内核空间中进行内存映射，以为只有一次内存拷贝，所以速度较快</li><li>Binder会验证权限，鉴定UID/PID来验证身份，保证了进程通信的安全性</li><li>系统的Service会想ServiceManager注册，使用时向ServiceManager获取</li><li>Service/Client同ServiceManager通信的过程本身也是通过binder驱动实现的</li><li>android中<a href="https://www.jianshu.com/p/04ad8a12d808" target="_blank" rel="noopener">Service</a>的bind通信是通过ActivityManagerService实现的</li><li>Binder中的代理模式：<ol><li>客户端代理对象和服务端实现统一接口</li><li>客户端获取服务端的引用，如果位于同一进程，那么获取的是服务端本身，如果是不同进程，获取到的是服务端的代理</li><li>通过代理请向服务端请求</li><li>服务端接收请求并处理，返回给客户端</li></ol></li></ol></blockquote><h3 id="9-AIDL"><a href="#9-AIDL" class="headerlink" title="9. AIDL"></a>9. <a href="https://blog.csdn.net/u011240877/article/details/72765136" target="_blank" rel="noopener">AIDL</a></h3><blockquote><ol><li>全称：Android Interface Define Language（Android接口定义语言）</li><li>目的是为了进行进程间通信</li><li>使用方式：定义aidl文件，编译器编译时会帮我们生成对应的JAVA代码；通过调用生成的java代码，来进行进程间通信</li><li>原理：通过Binder方式进行通信</li></ol></blockquote><h3 id="10-Window、WindowManager以及Activity"><a href="#10-Window、WindowManager以及Activity" class="headerlink" title="10. Window、WindowManager以及Activity"></a>10. <a href="https://blog.csdn.net/yhaolpz/article/details/68936932" target="_blank" rel="noopener">Window、WindowManager以及Activity</a></h3><blockquote><ol><li>Window 0. Window有三类：系统Window、应用Window、子Window<ol><li>Window是接口，具体实现类是PhoneWindow</li><li>Window 是一个抽象概念，我们并不能直接操作window</li><li>Activity在创建的时候attach方法中会创建Window并使之与Activity关联</li><li>Window中会创建Decorview，并通过ViewRootImpl与View交互</li></ol></li><li>WindowManager 0. 在Activity启动时，handleResumeActivity方法中启动activity的时候，会将主窗口加入到WindowManager中<ol><li>我们并不能直接操作window，而是通过WindowManager</li><li>WindowManagerImpl是其实现类，他将view增删改的操作交给 WindowManagerGlobal处理</li><li>WindowManagerGlobal 中会调用 ViewRootImpl的方法</li><li>ViewRootImpl通过IWindowSession与WindowManagerService交互</li></ol></li></ol></blockquote><h3 id="11-理解Window和WindowManager"><a href="#11-理解Window和WindowManager" class="headerlink" title="11. 理解Window和WindowManager"></a>11. 理解Window和WindowManager</h3><blockquote><ol><li>Window用于显示View和接收各种事件，Window有三种类型：应用Window(每个Activity对应一个Window)、子Window(不能单独存在，附属于特定Window)、系统window(Toast和状态栏)</li><li>Window分层级，应用Window在1-99、子Window在1000-1999、系统Window在2000-2999.WindowManager提供了增删改View三个功能。</li><li>Window是个抽象概念：每一个Window对应着一个View和ViewRootImpl，Window通过ViewRootImpl来和View建立联系，View是Window存在的实体，只能通过WindowManager来访问Window。</li><li>WindowManager的实现是WindowManagerImpl其再委托给WindowManagerGlobal来对Window进行操作，其中有四个List分别储存对应的View、ViewRootImpl、WindowManger.LayoutParams和正在被删除的View</li><li>Window的实体是存在于远端的WindowMangerService中，所以增删改Window在本端是修改上面的几个List然后通过ViewRootImpl重绘View，通过WindowSession(每个应用一个)在远端修改Window。</li><li>Activity创建Window：Activity会在attach()中创建Window并设置其回调(onAttachedToWindow()、dispatchTouchEvent()),Activity的Window是由Policy类创建PhoneWindow实现的。然后通过Activity#setContentView()调用PhoneWindow的setContentView。</li></ol></blockquote><h3 id="12-Window添加的过程"><a href="#12-Window添加的过程" class="headerlink" title="12. Window添加的过程"></a>12. <a href="https://blog.csdn.net/kebelzc24/article/details/53888931" target="_blank" rel="noopener">Window添加的过程</a></h3><blockquote><ol><li>ActivityThread做为APP的入口，会执行 handleLaunchActivity -&gt; performLaunchActivity</li><li>performLaunchActivity中通过ClassLoader创建Activity对象 -&gt; 调用Activity.attach方法 -&gt; callActivityOnCreate</li><li>在Activity.attach方法中会创建一个Window实例PhoneWindow，并将activity作为callback传递给window</li><li>在Activity的onCreate方法中，会调用setContentView，setContentView会调用PhoneWindow 的 setContentView</li><li>PhoneWindow 的 setContentView会创建DecorView，并把我们自己设置的ContentView和DecorView绑定</li><li>performLaunchActivity至此走完，之后的performResumeActivity会调用handleResumeActivity方法</li><li>在handleResumeActivity中，会调用Activity的getWindowManager()获取一个WindowManager，接着调用WindowManager的addView方法</li><li>addView实际执行的是WindowManagerGlobal的addView()，这里会创建一个ViewRootImpl，并调用ViewRootImpl的setView方法</li><li>在setView这个方法内部，会通过跨进程的方式向WMS（WindowManagerService）发起一个调用，从而将DecorView最终添加到Window上</li></ol></blockquote><h3 id="13-APK的安装流程"><a href="#13-APK的安装流程" class="headerlink" title="13. APK的安装流程"></a>13. APK的安装流程</h3><p><img src="https://user-gold-cdn.xitu.io/2018/5/4/16329f99d3a4b73a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><blockquote><ol><li>解压文件到data/app目录下</li><li>资源管理器加载资源文件</li><li>解析解析AndroidManifest文件，并在/data/data/目录下创建对应的应用数据目录。</li><li>然后对dex文件进行优化，并保存在dalvik-cache目录下。</li><li>将AndroidManifest文件解析出的四大组件信息注册到PackageManagerService中。</li><li>安装完成后，发送广播。</li></ol></blockquote><h3 id="14-双亲委托模式类加载的过程"><a href="#14-双亲委托模式类加载的过程" class="headerlink" title="14. 双亲委托模式类加载的过程"></a>14. <a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/" target="_blank" rel="noopener">双亲委托模式类加载的过程</a></h3><blockquote><ol><li>调用当前类加载器的loadClass加载类</li><li>loadClass中先调用findLoadedClass查看类是否已加载，已加载-&gt;over</li><li>还没有加载，调用父类加载器的loadClass，父类加载器加载完成 -&gt; over</li><li>如果父类加载器没有加载，调用本类加载器的findClass,并在findClass中调用·defineClass方法加载</li></ol></blockquote><h3 id="15-Android中ClassLoader"><a href="#15-Android中ClassLoader" class="headerlink" title="15. Android中ClassLoader"></a>15. Android中ClassLoader</h3><blockquote><ol><li>Android中加载的是Dex文件</li><li>ClassLoader 是个抽象类，其具体实现的子类有 BaseDexClassLoader 和SecureClassLoader，（SecureClassLoader 的子类是 URLClassLoader ，其只能用来加载 jar 文件，这在 Android 的 Dalvik/ART 上没法使用的）</li><li>BaseDexClassLoader 的子类是 PathClassLoader 和 DexClassLoader 。</li><li>PathClassLoader 在应用启动时创建，从 data/app/… 安装目录下加载 apk 文件。</li><li>DexClassLoader 则没有此限制，可以从 SD 卡或网络加载包含 class.dex 的 .jar 和 .apk 文件，这也是插件化和热修复的基础</li></ol></blockquote><h2 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h2><hr><h3 id="0-点击AndroidStudio的build按钮后发生了什么"><a href="#0-点击AndroidStudio的build按钮后发生了什么" class="headerlink" title="0. 点击AndroidStudio的build按钮后发生了什么"></a>0. <a href="https://juejin.im/post/5a939fdd5188257a585109ff" target="_blank" rel="noopener">点击AndroidStudio的build按钮后发生了什么</a></h3><p>build过程即执行gradle task 打包生成apk的过程：</p><blockquote><ol><li>通过appt工具，将资源文件生成R.java文件；将aild文件转换成对应的java文件</li><li>编译java文件，生成.class文件</li><li>将.class文件转换成Android虚拟机支持的.dex文件</li><li>通过apkbuilder将dex文件和编译后的资源文件生成apk文件</li><li>对apk进行签名和对齐</li></ol></blockquote><h3 id="1-Android-Debug和Release状态的不同"><a href="#1-Android-Debug和Release状态的不同" class="headerlink" title="1. Android Debug和Release状态的不同"></a>1. Android Debug和Release状态的不同</h3><p>调试模式允许我们为优化代码而添加许多额外的功能，这些功能在Release时都应该去掉；Release包可以为了安全等做一些额外的优化，这些优化可能比较耗时，在Debug时是不需要的</p><blockquote><ol><li>log日志只在debug时输入，release时应该关掉（为了安全）</li><li>签名/混淆/压缩等在debug编译时可以加入，减少打包时间</li><li>可以在debug包中加入一些额外的功能辅助我们开发，如直接打印网络请求的控件，内存泄漏检测工具LeakCanary等</li><li>在打Release包时，除了混淆等操作，往往还需要加固操作，保证APP的安全</li></ol></blockquote><h3 id="2-Dalvik和Art"><a href="#2-Dalvik和Art" class="headerlink" title="2. Dalvik和Art"></a>2. <a href="https://blog.csdn.net/jason0539/article/details/50440669" target="_blank" rel="noopener">Dalvik和Art</a></h3><blockquote><ol><li>Dalvik 是 Android 中使用的虚拟机，执行dex字节码</li><li>Dalvik 与 JVM 相比<ol><li>JVM执行class字节码文件，Dalvik执行dex字节码文件，dex文件做了优化，提及更小</li><li>Dalvik是基于寄存器的，VM基于栈</li></ol></li><li>Art是Dalvik虚拟机的升级版，Dalvik是解释型的，Art是翻译型的<ol><li>Dalvik虚拟机执行的是dex字节码，ART虚拟机执行的是本地机器码</li><li>相对于Dalvik，Art安装占用内存更大，安装时间更长，但是运行速度会有提升</li></ol></li></ol></blockquote><h3 id="3-解决方法数超过65535的方法"><a href="#3-解决方法数超过65535的方法" class="headerlink" title="3. 解决方法数超过65535的方法"></a>3. 解决方法数超过65535的方法</h3><blockquote><ol><li>代码混淆(原理是减小方法数)</li><li>sdk裁减(原理是减小方法数)</li><li>multi-dex（原理是打包成多个dex）</li></ol></blockquote><h3 id="4-multi-dex-问题"><a href="#4-multi-dex-问题" class="headerlink" title="4. multi-dex 问题"></a>4. <a href="https://www.jianshu.com/p/79a14d340cb0" target="_blank" rel="noopener">multi-dex</a> 问题</h3><blockquote><p>引入multi-dex后，在5.0以下手机上，第一次安装后启动速度可能变慢甚至anr，需要进行优化:如单独开一个线程；修改keep文件等</p></blockquote><h3 id="5-App签名"><a href="#5-App签名" class="headerlink" title="5. App签名"></a>5. <a href="https://mp.weixin.qq.com/s/6GV5HFnzZnY_qJlV9scVrw" target="_blank" rel="noopener">App签名</a></h3><blockquote><ol><li>原理：先计算出hash值，再对hash值进行非对称加密</li><li>V1版本签名生成的APK中与签名有关的文件：<ol><li>MANIFEST.MF: jar 包的文件清单，在 apk 中我们用来记录所有非目录文件的 数据指纹</li><li>CERT.SF:根据MANIFEST.MF生成的文件</li><li>CERT.RSA：这里会把之前生成的CERT.SF文件，用私钥计算出签名, 然后将签名以及包含公钥信息的数字证书一同写入CERT.RSA 中保存</li></ol></li><li>V1版本存在安全漏洞，google推出了v2版</li></ol></blockquote><h3 id="6-常用的adb-和-adb-shell命令"><a href="#6-常用的adb-和-adb-shell命令" class="headerlink" title="6. 常用的adb 和 adb shell命令"></a>6. <a href="http://www.jb51.net/article/112562.htm" target="_blank" rel="noopener">常用的adb 和 adb shell命令</a></h3><blockquote><p>查看当前连接的设备：adb devices<br> 结束adb连接： adb kill-server<br> 安装apk： adb install test.apk<br> 从手机获取文件和推送文件到手机：adb push &lt;本地文件&gt; &lt;远程路径&gt;  ；  adb pull &lt;远程路径&gt; &lt;本地路径&gt;<br> 获取log信息：adb logcat &gt; log.txt</p></blockquote><blockquote><p>启动Activity： adb shell am start -n 包名/包名＋类名<br> 显示系统Activity栈信息：adb shell dumpsys activity<br> 发送广播：adb shell am broadcast -a “android.intent.action.AdupsFota.WriteCommandReceiver”<br> 查看进程信息：adb shell ps &lt;package_name|PID&gt;<br> 杀掉某个进程：adb shell kill pidNumber<br> 查看内存占用：adb shell dumpsys meminfo &lt;package_name|PID&gt;</p></blockquote><h3 id="7-jar和aar的区别"><a href="#7-jar和aar的区别" class="headerlink" title="7. jar和aar的区别"></a>7. jar和aar的区别</h3><blockquote><p>Jar包里面只有代码，aar里面不光有代码还包括代码还包括资源文件，比如 drawable 文件，xml 资源文件。对于一些不常变动的 Android Library，我们可以直接引用 aar，加快编译速度</p></blockquote><h3 id="8-不同的CPU架构对APP的影响"><a href="#8-不同的CPU架构对APP的影响" class="headerlink" title="8. 不同的CPU架构对APP的影响"></a>8. <a href="https://www.jianshu.com/p/cb05698a1968" target="_blank" rel="noopener">不同的CPU架构对APP的影响</a></h3><blockquote><ol><li>cpu的架构有armeabi、armeabi-v7a、x86等</li><li>针对不同的CPU，使用不同的so包，可以使性能最大化</li><li>如果a.so提供了armeabi、armeabi-v7a、x86格式，那么b.so也要提供这几个格式，否则可能崩溃</li><li>当没有对应cpu的so时，会选择其他so，但执行速度会变慢：当一个应用安装在设备上，只有该设备支持的CPU架构对应的.so文件会被安装。在x86设备上，libs/x86目录中如果存在.so文件的话，会被安装，如果不存在，则会选择armeabi-v7a中的.so文件，如果也不存在，则选择armeabi目录中的.so文件（因为x86设备也支持armeabi-v7a和armeabi）</li></ol></blockquote><h3 id="9-compileSdkVersion，minSdkVersion，targetSdkVersion-都是啥"><a href="#9-compileSdkVersion，minSdkVersion，targetSdkVersion-都是啥" class="headerlink" title="9. compileSdkVersion，minSdkVersion，targetSdkVersion 都是啥"></a>9. <a href="https://blog.csdn.net/u010286855/article/details/54691614" target="_blank" rel="noopener">compileSdkVersion，minSdkVersion，targetSdkVersion</a> 都是啥</h3><blockquote><ol><li>compileSdkVersion ：编译所依赖的版本，它可以让我们在写代码时调用最新的api，告知我们过时的api</li><li>minSdkVersion：最小的可安装此App的版本，意味着我们不用做低于此版本的兼容</li><li>targetSdkVersion: 目标版本，可以让我们虽然运行在最新的手机上，但是行为和target版本一致，比如：如果targetSdkVersion小于Android 6.0，那么即使我们的app运行在6.0系统上，也不需要运行时权限</li></ol></blockquote><h3 id="10-低版本SDK实现高版本api"><a href="#10-低版本SDK实现高版本api" class="headerlink" title="10. 低版本SDK实现高版本api"></a>10. 低版本SDK实现高版本api</h3><blockquote><ol><li>使用@TargetApi 来标明api版本，这样编译器就不会报错了</li><li>在代码逻辑中判断版本，在低版本上调用替代api或自己实现的算法。</li></ol></blockquote><h2 id="部分功能的实现"><a href="#部分功能的实现" class="headerlink" title="部分功能的实现"></a>部分功能的实现</h2><hr><h3 id="0-怎样退出终止自己的APP"><a href="#0-怎样退出终止自己的APP" class="headerlink" title="0. 怎样退出终止自己的APP"></a>0. <a href="https://blog.csdn.net/fzkf9225/article/details/73480469" target="_blank" rel="noopener">怎样退出终止自己的APP</a></h3><blockquote><ol><li>记录启动的activity</li><li>需要退出时调用存活activity的finish方法，并调用System.exit(0)方法</li></ol></blockquote><h3 id="1-Android中启动线程的几种方式"><a href="#1-Android中启动线程的几种方式" class="headerlink" title="1. Android中启动线程的几种方式"></a>1. Android中启动线程的几种方式</h3><blockquote><ol><li>java中可以用实现Runnable接口、实现Callable接口、继承Thread类三种方式</li><li>Android中还可以用<a href="https://www.jianshu.com/p/3b839d7a3fcf" target="_blank" rel="noopener">AsyncTask</a>、<a href="https://www.jianshu.com/p/4a57de01c8f5" target="_blank" rel="noopener">HandlerThread</a>、<a href="https://blog.csdn.net/matrix_xu/article/details/7974393" target="_blank" rel="noopener">IntendService</a></li></ol></blockquote><h3 id="2-长链接-心跳包"><a href="#2-长链接-心跳包" class="headerlink" title="2. 长链接+心跳包"></a>2. <a href="https://blog.csdn.net/u010072711/article/details/76099776" target="_blank" rel="noopener">长链接+心跳包</a></h3><blockquote><ol><li>长连接：App 与服务器建立一个生命周期很长的连接，服务器通过push向App推送消息</li><li>心跳包：App 每隔一段时间就会向服务器查询是否有新的消息</li><li>长连接可能因为各种原因被打断，心跳包接收消息可能不及时，所以我们可以采取长连接+心跳包的方式：通过Socket建立一个长连接，并通过心跳包检测这个长连接是否存活，长连接中断的话则重新建立</li></ol></blockquote><h3 id="3-Android-中XML的解析"><a href="#3-Android-中XML的解析" class="headerlink" title="3. Android 中XML的解析"></a>3. <a href="https://www.jianshu.com/p/e636f4f8487b" target="_blank" rel="noopener">Android 中XML的解析</a></h3><blockquote><p>Androi中主要有DOM，SAX，PULL三种方式<br> DOM将文件都加载到内存中，比较消耗内存；SAX和PULL节省内存，PULL使用比SAX更简单</p></blockquote><h3 id="4-系统上安装了多种浏览器，能否指定某浏览器访问指定页面？请说明原由。"><a href="#4-系统上安装了多种浏览器，能否指定某浏览器访问指定页面？请说明原由。" class="headerlink" title="4. 系统上安装了多种浏览器，能否指定某浏览器访问指定页面？请说明原由。"></a>4. 系统上安装了多种浏览器，能否指定某浏览器访问指定页面？请说明原由。</h3><blockquote><ol><li>指定浏览器：intent.setClassName(“com.android.browser”,”com.android.browser.BrowserActivity”);</li><li>指定网址： Uri uriBrowsers = Uri.parse(“<a href="http://www.sina.com.cn”" target="_blank" rel="noopener">http://www.sina.com.cn”</a>); intent.setData(uriBrowsers);</li></ol></blockquote><h3 id="5-java中如何引用本地语言"><a href="#5-java中如何引用本地语言" class="headerlink" title="5. java中如何引用本地语言"></a>5. java中如何引用本地语言</h3><blockquote><p>可以用JNI（java native interface  java 本地接口）接口</p></blockquote><h3 id="6-JNI的使用方式"><a href="#6-JNI的使用方式" class="headerlink" title="6. JNI的使用方式"></a>6. <a href="https://blog.csdn.net/kevindgk/article/details/52813258" target="_blank" rel="noopener">JNI的使用方式</a></h3><blockquote><ol><li><p>下载NDK，配置环境变量，配置gradle文件</p></li><li><p>JAVA中声明native 方法如private native String printJNI(String inputStr);</p></li><li><p>生成或写对应的头文件</p></li><li><p>编写对应文件实现代码</p></li><li><p>编译成so文件</p></li><li><p>使用</p></li><li><p>扩展：</p><p>native调用java代码</p><ol><li>获取你需要访问的Java对象的类</li></ol></li></ol></blockquote><pre><code>jclass cls = (*env)-&gt;GetObjectClass(env, obj);       //使用GetObjectClass方法获取obj对应的jclass。   class cls = (*env)-&gt;FindClass(“android/util/log”) //直接搜索类名，需要是static修饰的类。  复制代码</code></pre><blockquote><ol><li>获取MethodID：</li></ol></blockquote><pre><code>methodID mid = (*env)-&gt;GetMethodID(env, cls, &quot;callback&quot;, &quot;(I)V&quot;); //GetStaticMethodID(…)，获取静态方法的ID使用GetMethdoID方法获取你要使用的方法的MethdoID  复制代码</code></pre><blockquote><ol><li>调用：</li></ol></blockquote><pre><code>    (*env)-&gt;CallVoidMethod(env, obj, mid, depth);// CallStaticIntMethod(….) ， 调用静态方法  复制代码</code></pre><h3 id="7-NDK是什么"><a href="#7-NDK是什么" class="headerlink" title="7. NDK是什么"></a>7. NDK是什么</h3><blockquote><p>NDK 是Native Development Kit 的缩写，是一些列工具的集合，帮助开发者迅速的开发C/C++的动态库</p></blockquote><h3 id="8-什么是JVM"><a href="#8-什么是JVM" class="headerlink" title="8. 什么是JVM"></a>8. <a href="https://segmentfault.com/a/1190000002579346" target="_blank" rel="noopener">什么是JVM</a></h3><blockquote><ol><li>JVM是JAVA虚拟机，保证了java语言的跨平台性，是编译后的 Java 程序（.class文件）和硬件系统之间的接口</li><li>JVM = 类加载器 classloader + 执行引擎 execution engine + 运行时数据区域 runtime data area</li></ol></blockquote><h3 id="9-视频加密"><a href="#9-视频加密" class="headerlink" title="9. 视频加密"></a>9. <a href="https://github.com/gwuhaolin/blog/issues/10" target="_blank" rel="noopener">视频加密</a></h3><p>视频加密根据场景的不同有很多种方式</p><blockquote><ol><li>如仅对地址加密，可以起到防盗链的目的，可以与其他方法一起使用</li><li>对整个文件加密，加解密时间长，不实用</li><li>对文件的头中尾加密，播放器可以直接跳过，破解简单,不实用</li><li>对视频流加密(<a href="https://github.com/hauk0101/video-hls-encrypt" target="_blank" rel="noopener">基于苹果HLS协议的加密</a>     <a href="https://github.com/gwuhaolin/blog/issues/10" target="_blank" rel="noopener">基于RTPE协议</a>)</li><li>关键帧加密</li></ol></blockquote><h3 id="10-绘制印章"><a href="#10-绘制印章" class="headerlink" title="10. 绘制印章"></a>10. <a href="https://blog.csdn.net/loser_li/article/details/48005683" target="_blank" rel="noopener">绘制印章</a></h3><blockquote><ol><li>创建一个bitmap，拿到canvas</li><li>在canvas上绘制圆，绘制五角星，绘制文字，返回bitmap</li></ol></blockquote><h3 id="11-文字阴影和描边的实现"><a href="#11-文字阴影和描边的实现" class="headerlink" title="11. 文字阴影和描边的实现"></a>11. <a href="https://blog.csdn.net/figo0423/article/details/51464116" target="_blank" rel="noopener">文字阴影和描边的实现</a></h3><blockquote><ol><li>阴影：shadow属性</li><li>描边：两个TextView叠加；或者重写onDraw方法</li></ol></blockquote><h3 id="12-Android生成设备唯一标识符"><a href="#12-Android生成设备唯一标识符" class="headerlink" title="12. Android生成设备唯一标识符"></a>12. <a href="https://www.jianshu.com/p/b6f4b0aca6b0" target="_blank" rel="noopener">Android生成设备唯一标识符</a></h3><blockquote><p>选取 DeviceId，AndroidId，Serial Number，Mac，蓝牙地址等中的一个或者几个作为种子，生成UUID。</p></blockquote><h3 id="13-实现客户端的自动登录"><a href="#13-实现客户端的自动登录" class="headerlink" title="13. 实现客户端的自动登录"></a>13. <a href="https://blog.csdn.net/xiaopihair123/article/details/53150201" target="_blank" rel="noopener">实现客户端的自动登录</a></h3><blockquote><ol><li>第一次登录时保存两个token，一个长效一个短效</li><li>短效token用于每次网络请求的用户标识</li><li>长效token用于当短效token失效时自动登录，重新获取token</li></ol></blockquote><h3 id="14-Android如何在不压缩的情况下加载高清大图"><a href="#14-Android如何在不压缩的情况下加载高清大图" class="headerlink" title="14. Android如何在不压缩的情况下加载高清大图"></a>14. <a href="https://www.jianshu.com/p/b0e2be9e0f8c" target="_blank" rel="noopener">Android如何在不压缩的情况下加载高清大图</a></h3><blockquote><p>使用BitmapRegionDecoder</p></blockquote><h3 id="15-SSL证书的验证"><a href="#15-SSL证书的验证" class="headerlink" title="15. SSL证书的验证"></a>15. SSL证书的验证</h3><blockquote><ol><li><p>在使用Https时，我们需要对SSL证书做验证以确保有效</p></li><li><p>证书需要验证证书有效性，时效，域名等</p></li><li><p>Android中WebView可以重写onReceivedSslError方法来处理ssl证书不对时的情况</p></li><li><p>OkHttp设置证书验证</p><p>：</p><ol><li>验证可以是双向的，也可以是单向的</li><li>单向：将服务器对应的Server.cer文件打包进Apk中，通过cer文件生成SSLSocketFactory，并将其设置给okHttpClient</li><li>双向：用Server.cer和Client.key生成SSLSocketFactory，并将其设置给okHttpClient</li></ol></li></ol></blockquote><h3 id="16-计算一张100px-100px的图片在内存中会占用多大内存"><a href="#16-计算一张100px-100px的图片在内存中会占用多大内存" class="headerlink" title="16. 计算一张100px*100px的图片在内存中会占用多大内存"></a>16. <a href="https://www.cnblogs.com/YuangPong/p/6694512.html" target="_blank" rel="noopener">计算一张100px*100px的图片在内存中会占用多大内存</a></h3><blockquote><ol><li>内存大小 = 100<em>100</em>像素点大小</li><li>像素点大小和编码方式有关：ARGB_8888占8+8+8+8=32bit；ARGB_4444占4+4+4+4 = 16bit；</li></ol></blockquote><h3 id="17-如何实现动态代理"><a href="#17-如何实现动态代理" class="headerlink" title="17. 如何实现动态代理"></a>17. <a href="https://blog.csdn.net/hello2mao/article/details/52346205" target="_blank" rel="noopener">如何实现动态代理</a></h3><blockquote><ol><li>创建一个实现InvocationHandler接口的类，它必须实现invoke方法</li><li>调用Proxy的静态方法newProxyInstance，创建一个代理类</li></ol></blockquote><h3 id="18-Android中有哪些方法实现定时和延时任务？它们的适用场景是什么？"><a href="#18-Android中有哪些方法实现定时和延时任务？它们的适用场景是什么？" class="headerlink" title="18. Android中有哪些方法实现定时和延时任务？它们的适用场景是什么？"></a>18. Android中有哪些方法实现定时和延时任务？它们的适用场景是什么？</h3><blockquote><ol><li>倒计时类:用CountDownTimer</li><li>延迟类: 1. CountDownTimer，可巧妙的将countDownInterval设成和millisInFuture一样，这样就只会调用一次onTick和一次onFinish 2. handler.sendMessageDelayed,可参考CountDownTimer的内部实现，简化一下，个人比较推荐这个 3. TimerTask，代码写起来比较乱 4. Thread.sleep，感觉这种不太好</li><li>定时类: 1. 参照延迟类的，自己计算好要延迟多少时间 2. handler.sendMessageAtTime 3. AlarmManager，适用于定时比较长远的时间，例如闹铃</li></ol></blockquote><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><hr><h3 id="0-Json有什么优势"><a href="#0-Json有什么优势" class="headerlink" title="0. Json有什么优势"></a>0. Json有什么优势</h3><p>有比较才会有优势，我们通常将Json与Xml进行比较，Json更加轻量。我觉得在某些程度上讲，这是一个仁者见仁智者见智的问题。例如有些人认为Json相比Xml更易读，有些人责认为不然，这里大致列举几条，仅供参考</p><blockquote><ol><li>结构简单，可读性更强，读写更加容易</li><li>格式是压缩的，占用带宽小</li><li>支持多种语言</li><li>因为JSON格式能够直接为服务器端代码使用,大大简化了服务器端和客户端的代码开发量</li></ol></blockquote><h3 id="1-MVC"><a href="#1-MVC" class="headerlink" title="1. MVC"></a>1. <a href="https://www.cnblogs.com/Claire6649/p/6091061.html" target="_blank" rel="noopener">MVC</a></h3><blockquote><p>MVC是model,view,controller的缩写</p></blockquote><blockquote><ol><li>模型（model）对象：是应用程序的主体部分，所有的业务逻辑都应该写在该层;</li><li>视图（view）对象(<strong>对应Android中的布局xml文件</strong>)：是应用程序中负责生成用户界面的部分。也是在整个mvc架构中用户唯一可以看到的一层，接收用户的输入，显示处理结果; </li><li>控制器（control）对象（<strong>对应Android中的Activity</strong>）：是根据用户的输入，控制用户界面数据显示及更新model对象状态的部分，控制器更重要的一种导航功能，响应用户出发的相关事件，交给m层处理。 扩展：和MVP最大的区别是View和Model可以直接交互</li></ol></blockquote><h3 id="2-什么是控制反转（IOC-Inversion-of-Control）"><a href="#2-什么是控制反转（IOC-Inversion-of-Control）" class="headerlink" title="2. 什么是控制反转（IOC Inversion of Control）"></a>2. <a href="http://www.jb51.net/article/118316.htm" target="_blank" rel="noopener">什么是控制反转（IOC Inversion of Control）</a></h3><blockquote><ol><li>在Java开发中，IoC意 味着将你设计好的类交给系统去控制，而不是在你的类内部控制</li><li>是框架的重要特征</li><li>Android中Activity 的生命周期都是框架控制的，是一种控制反转</li></ol></blockquote><h3 id="3-Android中的IOC（控制反转）框架"><a href="#3-Android中的IOC（控制反转）框架" class="headerlink" title="3. Android中的IOC（控制反转）框架"></a>3. <a href="https://www.jianshu.com/p/3968ffabdf9d" target="_blank" rel="noopener">Android中的IOC（控制反转）框架</a></h3><blockquote><ol><li>控制反转：将对象的创建交给框架去做</li><li>常用的框架：ButterNife/Android Annotation</li><li>2中两个框架都是通过java的注释框架实现的，并且都是作用在编译期</li></ol></blockquote><h3 id="4-请解释下Android程序运行时权限与文件系统权限的区别"><a href="#4-请解释下Android程序运行时权限与文件系统权限的区别" class="headerlink" title="4. 请解释下Android程序运行时权限与文件系统权限的区别"></a>4. 请解释下Android程序运行时权限与文件系统权限的区别</h3><blockquote><ol><li>运行时权限是APP启动后由Android虚拟机（如Dalvik）控制的</li><li>文件系统权限是Linux内核授权</li></ol></blockquote><h3 id="5-AOP-面向切面编程"><a href="#5-AOP-面向切面编程" class="headerlink" title="5. AOP 面向切面编程"></a>5. <a href="https://www.cnblogs.com/ganchuanpu/p/8594877.html" target="_blank" rel="noopener">AOP 面向切面编程</a></h3><blockquote><ol><li>面向切面编程是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术</li><li>例如很多功能需要先登陆，登陆在这里就是一个切面。</li></ol></blockquote><h3 id="6-MVP-架构中-Presenter-定义为接口有什么好处"><a href="#6-MVP-架构中-Presenter-定义为接口有什么好处" class="headerlink" title="6. MVP 架构中 Presenter 定义为接口有什么好处"></a>6. MVP 架构中 Presenter 定义为接口有什么好处</h3><blockquote><ol><li>在goole官方的demo中，通过一个Contract把将View和Presenter管理起来，强化其一一对应的关系，便于操作</li><li>[但是也有人认为不应该将Presenter定义为接口]<a href="http://www.infoq.com/cn/articles/do-not-give-the-prensenter-in-mvp-interface)，因为这并不会方便测试，还会增加复杂性" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/do-not-give-the-prensenter-in-mvp-interface)，因为这并不会方便测试，还会增加复杂性</a></li></ol></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><hr><h3 id="0-Android中的几种动画"><a href="#0-Android中的几种动画" class="headerlink" title="0. Android中的几种动画"></a>0. <a href="https://www.cnblogs.com/ldq2016/p/5407061.html" target="_blank" rel="noopener">Android中的几种动画</a></h3><blockquote><ol><li>普通动画（视图动画、补间动画）</li><li><a href="https://www.jianshu.com/p/2412d00a0ce4" target="_blank" rel="noopener">属性动画</a></li><li>帧动画</li><li>物理动画（Android 8.0）</li></ol></blockquote><h3 id="1-HttpClient和HttpURLConnection的区别"><a href="#1-HttpClient和HttpURLConnection的区别" class="headerlink" title="1. HttpClient和HttpURLConnection的区别"></a>1. <a href="https://www.jianshu.com/p/a32d6980227b" target="_blank" rel="noopener">HttpClient和HttpURLConnection的区别</a></h3><h4 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h4><blockquote><ol><li>Apache公司提供的库</li><li>拥有丰富的API，但也因为这个原因，在不破坏兼容性的前提下，其庞大的API也使人难以改进</li><li>Android 6.0中抛弃了Http Client，替换成OkHttp</li></ol></blockquote><h4 id="HttpURLConnection"><a href="#HttpURLConnection" class="headerlink" title="HttpURLConnection"></a>HttpURLConnection</h4><blockquote><ol><li>Sun公司提供的库</li><li>功能比较简单，可拓展性强</li><li>直接支持GZIP压缩，并且在Android 4.0 以上支持cache缓存，提高了网络效率</li></ol></blockquote><h3 id="2-Intent"><a href="#2-Intent" class="headerlink" title="2. Intent"></a>2. Intent</h3><blockquote><ol><li>Intent是Android中的信使，可以启动Activity，Service等</li><li>Intent可以设置的几项值：Action, Category, Data/Type,Component</li><li>当设定Component时，是显式调用，其余是隐式调用</li></ol></blockquote><h3 id="3-IntentFilter"><a href="#3-IntentFilter" class="headerlink" title="3. IntentFilter"></a>3. <a href="https://blog.csdn.net/mynameishuangshuai/article/details/51673273" target="_blank" rel="noopener">IntentFilter</a></h3><blockquote><ol><li>IntentFilter 在AndroidMainifest中注册，用来帮助系统选出用户定义的隐式Intent对应的Activity /Service等</li><li>Android是通过Intent的action、data、category这三个属性来进行匹配判断的<ol><li>action：隐式启动需要给Intent设置Action，如果没有设置这条匹配则自动通过；必须给IntentFilter设置一个action</li><li>data：如果Intent没有提供type，系统将从data中得到数据类型。同action类似，只要Intent的data只要与Intent Filter中的任一个data声明完全相同，data方面就完全匹配成功。</li><li>category：Intent的Category可以有多个，每一个都需要和IntentFilter匹配才能算匹配上，不设置Intent的category时是默认的（DEFAULT）</li><li>总结：只有一个Intent的action、data、category匹配上IntenFilter中的一组数据时，才算匹配成功。</li></ol></li></ol></blockquote><h3 id="4-Intent-Bundle支持传送哪种类型的数据"><a href="#4-Intent-Bundle支持传送哪种类型的数据" class="headerlink" title="4. Intent/Bundle支持传送哪种类型的数据"></a>4. Intent/Bundle支持传送哪种类型的数据</h3><blockquote><ol><li>基本类型及其数组</li><li>实现了Serializable或者Parcelable的类型及其数组</li></ol></blockquote><h3 id="5-Manifest-xml文件中主要包括哪些信息"><a href="#5-Manifest-xml文件中主要包括哪些信息" class="headerlink" title="5. Manifest.xml文件中主要包括哪些信息"></a>5. Manifest.xml文件中主要包括哪些信息</h3><blockquote><ol><li>manifest：根节点，描述了包名，版本号等。</li><li>application：包含package中application级别组件声明的根节点。</li><li>activity：Activity是用来与用户交互的主要工具。</li><li>receiver：IntentReceiver能使的application获得数据的改变或者发生的操作，即使它当前不在运行。</li><li>service：Service是能在后台运行任意时间的组件。</li><li>provider：ContentProvider是用来管理持久化数据并发布给其他应用程序使用的组件。</li><li>uses-permission：请求你的package正常运作所需赋予的安全许可。</li><li>permission： 声明了安全许可来限制哪些程序能你package中的组件和功能。</li><li>uses-feature:使用到的硬件信息，如nfc</li><li>upports-screens：支持的屏幕类型</li><li>meta-data：data数据</li><li><a href="https://blog.csdn.net/a19891024/article/details/54342799" target="_blank" rel="noopener">instrumentation</a>：声明了用来测试此package或其他package指令组件的代码。</li></ol></blockquote><h3 id="6-dp-dip-dpi-px-sp是什么意思"><a href="#6-dp-dip-dpi-px-sp是什么意思" class="headerlink" title="6. dp, dip, dpi, px, sp是什么意思"></a>6. <a href="https://blog.csdn.net/binyao02123202/article/details/8090607" target="_blank" rel="noopener">dp, dip, dpi, px, sp是什么意思</a></h3><blockquote><ol><li>dp = dip（device independent pixels）,是设备独立像素</li><li>sp:scaled pixels(放大像素)，主要用于字体显示。</li><li>px（pixel）：像素</li><li>dpi（dot per inch）</li></ol></blockquote><h3 id="7-dp与px的换算公式"><a href="#7-dp与px的换算公式" class="headerlink" title="7. dp与px的换算公式"></a>7. <a href="https://blog.csdn.net/benbenxiongyuan/article/details/52920746" target="_blank" rel="noopener">dp与px的换算公式</a></h3><blockquote><ol><li>px = dp*像素密度/160</li></ol></blockquote><pre><code> public static int dp2px(Context context, float dpValue) {        final float scale = context.getResources().getDisplayMetrics().density;        return (int) (dpValue * scale + 0.5f);    }复制代码</code></pre><h3 id="8-layout-sw400dp-layout-w400dp分别代表什么意思"><a href="#8-layout-sw400dp-layout-w400dp分别代表什么意思" class="headerlink" title="8. layout-sw400dp, layout-w400dp分别代表什么意思"></a>8. <a href="https://blog.csdn.net/wxx614817/article/details/50975265" target="_blank" rel="noopener">layout-sw400dp, layout-w400dp分别代表什么意思</a></h3><blockquote><ol><li>layout-w400dp:当屏幕相对宽度大于400dp时，来这里取layout（与横竖屏有关）</li><li>layout-sw400dp:当屏幕绝对宽度大于400dp时，来这里取layout（与横竖屏无关）</li></ol></blockquote><h3 id="9-Android-样式和主题"><a href="#9-Android-样式和主题" class="headerlink" title="9. Android 样式和主题"></a>9. <a href="https://blog.csdn.net/ahou2468/article/details/78965839" target="_blank" rel="noopener">Android 样式和主题</a></h3><blockquote><ol><li>样式（Styles）:可以理解成是针对View或者窗口(Window)设置外观或者格式的一个属性集合</li><li>主题（Themes）：主题相比单个视图而言，是应用到整个 Activity 或者 application 的样式</li><li>区别：<ol><li>Theme作用域是Activity或者Application，Stytle针对View或者窗口(Window)</li><li>某些主题样式不可以在View中使用，例如”@android:style/Theme.NoTitleBar” 等 扩展： 属性（Attributes）:你也可以将单个属性应用到 Android 样式上,通常会在自定义View 的时候，自定义属性。</li></ol></li></ol></blockquote><h3 id="10-Android-P的新特性（2018-5-5）"><a href="#10-Android-P的新特性（2018-5-5）" class="headerlink" title="10. Android P的新特性（2018/5/5）"></a>10. Android P的新特性（2018/5/5）</h3><blockquote><ol><li>Goole 下个Android版本的预览已经放出，代号p</li><li>支持wifi室内定位</li><li>适配刘海屏</li><li>通知栏改进：可以显示对话，附加照片和表情等</li><li>多摄像头API</li><li>神经网络API 1.1</li></ol></blockquote><h3 id="11-热修复原理"><a href="#11-热修复原理" class="headerlink" title="11. 热修复原理"></a>11. <a href="https://blog.csdn.net/csdn_lqr/article/details/78534065" target="_blank" rel="noopener">热修复原理</a></h3><p>热修复的原理是让我们的新类替换掉原来类的加载，从而达到修复的目的，以下是一种思路：</p><blockquote><ol><li>java中通过PathClassLoader和DexClassLoader来加载类，类加载的方式是双亲委派模式</li><li>PathClassLoader和DexClassLoader都继承自BaseDexClassLoader</li><li>BaseDexClassLoader中维护了一个dex的数组</li><li>我们可以通过DexClassLoader加载类，然后通过反射的机制将加载进来的数组添加到path数组的前面</li><li>加载的时候找到我们需要的class后，就不再继续向后找了，所以可以达到修复的目的</li></ol></blockquote><h3 id="12-Android中的进程间通信（IPC）"><a href="#12-Android中的进程间通信（IPC）" class="headerlink" title="12. Android中的进程间通信（IPC）"></a>12. Android中的进程间通信（IPC）</h3><blockquote><ol><li>Bundle : 只支持四大组件</li><li>文件共享：不适合并发</li><li>Messenger：封装了AIDL</li><li>AIDL：通过binder实现</li><li>ContentProvider：共享数据</li><li>Socket：适用于网络等</li></ol></blockquote><h3 id="13-解决Android7-0-更新安装包时不能自动安装问题"><a href="#13-解决Android7-0-更新安装包时不能自动安装问题" class="headerlink" title="13. 解决Android7.0 更新安装包时不能自动安装问题"></a>13. <a href="https://www.jianshu.com/p/c58aa241688c" target="_blank" rel="noopener">解决Android7.0 更新安装包时不能自动安装问题</a></h3><blockquote><ol><li>Android 7.0中私有目录访问会被限制，导致不能自动安装</li><li>可以使用FileProvider来解决</li></ol></blockquote><h3 id="如何开启多进程-应用是否可以开启N个进程？"><a href="#如何开启多进程-应用是否可以开启N个进程？" class="headerlink" title="如何开启多进程?应用是否可以开启N个进程？"></a><a href="https://www.jianshu.com/p/11da30127823" target="_blank" rel="noopener">如何开启多进程</a>?应用是否可以开启N个进程？</h3><blockquote><ol><li>通过在AndroidManifest中给Activity设置process属性开启新的进程</li><li>可以开启N个进程，例如给webview单独开启一个进程，但要处理多进程间通信和多次初始化Handler问题</li></ol></blockquote><h3 id="Service先start再bind如何关闭service"><a href="#Service先start再bind如何关闭service" class="headerlink" title="Service先start再bind如何关闭service"></a><a href="https://www.jianshu.com/p/ee224f18a4bd" target="_blank" rel="noopener">Service先start再bind如何关闭service</a></h3><blockquote><p>先unbind,再stop</p></blockquote><h3 id="为什么bindService可以跟Activity生命周期联动"><a href="#为什么bindService可以跟Activity生命周期联动" class="headerlink" title="为什么bindService可以跟Activity生命周期联动"></a>为什么bindService可以跟Activity生命周期联动</h3><blockquote><ol><li>在Activity退出时调用unbind方法，service会销毁</li><li>如果不调用unbind方法，service也会销毁，但是<a href="https://www.cnblogs.com/vokie/archive/2013/04/15/3602088.html" target="_blank" rel="noopener">会抛出leaked serviceConnection 异常</a> (<a href="https://yiweifen.com/v-1-335376.html" target="_blank" rel="noopener">参考2</a>)</li></ol></blockquote><h3 id="子线程中如何使用Handler"><a href="#子线程中如何使用Handler" class="headerlink" title="子线程中如何使用Handler"></a><a href="https://www.cnblogs.com/lang-yu/p/6228832.html" target="_blank" rel="noopener">子线程中如何使用Handler</a></h3><blockquote><ol><li>使用HandlerThread,新建Handler时通过调用HandlerThread 的 getLooper方法拿到looper</li><li>原理：HandlerThread在run时会为我们生成一个looper，getLooper方法会阻塞等待直到 looper！=null 才返回。</li></ol></blockquote><h3 id="如何进行单元测试"><a href="#如何进行单元测试" class="headerlink" title="如何进行单元测试"></a>如何进行单元测试</h3><blockquote><ol><li><a href="https://www.jianshu.com/p/79addb29b06d" target="_blank" rel="noopener">Junit</a>:不需要依赖android环境，适合于逻辑测试</li><li><a href="https://www.oschina.net/question/54100_27061" target="_blank" rel="noopener">Instrumentation</a>:依赖android环境，可以启动Activity，模拟内存回收，获取组件等，模拟点击等。需要在AndroidManifest中进行配置，适合于更复杂的测试</li></ol></blockquote><h3 id="TabLayout如何设置指示器的宽度"><a href="#TabLayout如何设置指示器的宽度" class="headerlink" title="TabLayout如何设置指示器的宽度"></a><a href="https://blog.csdn.net/qq_34664695/article/details/78535572" target="_blank" rel="noopener">TabLayout如何设置指示器的宽度</a></h3><blockquote><p>通过反射拿到对应的指示器，设置LayoutParams</p></blockquote><h3 id="Android中如何查看一个对象的回收情况"><a href="#Android中如何查看一个对象的回收情况" class="headerlink" title="Android中如何查看一个对象的回收情况"></a>Android中如何查看一个对象的回收情况</h3><blockquote><ol><li>外部：通过adb shell 命令导出内存，借助工具分析</li><li>内部：通过将对象加入WeakReference，配合RefernceQueue观察对象是否被回收，被回收的对象会被加入到RefernceQueue中</li></ol></blockquote><h3 id="回形打印二维数组"><a href="#回形打印二维数组" class="headerlink" title="回形打印二维数组"></a><a href="https://www.jianshu.com/p/35e618aec35f" target="_blank" rel="noopener">回形打印二维数组</a></h3><blockquote><p>思路：递归实现，分别打印每一圈</p></blockquote><h3 id="APK内容"><a href="#APK内容" class="headerlink" title="APK内容"></a>APK内容</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/3/163c5cfdf016c8bc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="class文件如何转化成dex"><a href="#class文件如何转化成dex" class="headerlink" title="class文件如何转化成dex"></a><a href="https://www.jianshu.com/p/2eb518941681" target="_blank" rel="noopener">class文件如何转化成dex</a></h3><blockquote><p>使用build tools 下的dx工具</p></blockquote><pre><code>class 和dex文件对比:1. 都是二进制文件2. class文件存在容与，dex文件将整个工程的类信息整合到了一起，去掉了冗余复制代码</code></pre><h3 id="硬件加速"><a href="#硬件加速" class="headerlink" title="硬件加速"></a><a href="https://www.jianshu.com/p/40f660e17a73" target="_blank" rel="noopener">硬件加速</a></h3><blockquote><ol><li>随便写点凑个数吧=-=</li><li>硬件加速的四个级别：Application/Activity/Window/View</li></ol></blockquote><h3 id="为什么选择Binder作为通信方式"><a href="#为什么选择Binder作为通信方式" class="headerlink" title="为什么选择Binder作为通信方式"></a><a href="https://blog.csdn.net/starter110/article/details/49616701" target="_blank" rel="noopener">为什么选择Binder作为通信方式</a></h3><blockquote><ol><li>binder效率更高：socket是一个通用接口，效率低；管道和队列内存拷贝两次，效率低；共享内存控制复杂</li><li>binder更加安全：binder可以建立私有通道，通过uid/pid验证身份</li></ol></blockquote><h2 id="LeakCanary原-理"><a href="#LeakCanary原-理" class="headerlink" title="LeakCanary原  理"></a>LeakCanary<a href="https://blog.csdn.net/cloud_huan/article/details/53081120" target="_blank" rel="noopener">原</a>  <a href="https://www.jianshu.com/p/5ee6b471970e" target="_blank" rel="noopener">理</a></h2><hr><blockquote><ol><li>在Application中注册一个ActivityLifecycleCallbacks来监听Activity的销毁</li><li>通过IdleHandler在主线程空闲时进行检测</li><li><a href="https://www.cnblogs.com/huanyi0723/p/7050555.html" target="_blank" rel="noopener">检测是通过WeakReference实现的，如果没有被回收会再次调用gc再确认一遍</a></li><li>确认有泄漏后，dump hprof文件，并开启一个进程IntentService通过HAHA进行分析</li></ol></blockquote><h2 id="OkHttp（基于3-9版本）"><a href="#OkHttp（基于3-9版本）" class="headerlink" title="OkHttp（基于3.9版本）"></a>OkHttp（基于3.9版本）</h2><hr><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a><a href="http://liuwangshu.cn/application/network/5-okhttp2x.html" target="_blank" rel="noopener">使用</a></h3><h4 id="1-在gradle中添加依赖"><a href="#1-在gradle中添加依赖" class="headerlink" title="1. 在gradle中添加依赖"></a>1. 在gradle中添加依赖</h4><pre><code>compile &#39;com.squareup.okhttp3:okhttp:3.9.0&#39;compile &#39;com.squareup.okio:okio:1.13.0&#39;复制代码</code></pre><h4 id="2-创建OkHttpClient，并对timeout等进行设置"><a href="#2-创建OkHttpClient，并对timeout等进行设置" class="headerlink" title="2. 创建OkHttpClient，并对timeout等进行设置"></a>2. 创建OkHttpClient，并对timeout等进行设置</h4><pre><code>File sdcache = getExternalCacheDir();int cacheSize = 10 * 1024 * 1024;OkHttpClient.Builder builder = new OkHttpClient.Builder()        .connectTimeout(15, TimeUnit.SECONDS)        .writeTimeout(20, TimeUnit.SECONDS)        .readTimeout(20, TimeUnit.SECONDS)        .cache(new Cache(sdcache.getAbsoluteFile(), cacheSize));OkHttpClient mOkHttpClient=builder.build();复制代码</code></pre><h4 id="3-创建Request"><a href="#3-创建Request" class="headerlink" title="3. 创建Request"></a>3. 创建Request</h4><ul><li>get请求</li></ul><pre><code>Request request = new Request.Builder()            .url(&quot;http://www.baidu.com&quot;)            .build();复制代码</code></pre><ul><li>post请求（post需要传入requsetBody）</li></ul><pre><code>RequestBody formBody = new FormEncodingBuilder()            .add(&quot;size&quot;, &quot;10&quot;)            .build();    Request request = new Request.Builder()            .url(&quot;http://api.1-blog.com/biz/bizserver/article/list.do&quot;)            .post(formBody)            .build();复制代码</code></pre><h4 id="4-创建Call并执行（okHttp的返回结果并没有在ui线程）"><a href="#4-创建Call并执行（okHttp的返回结果并没有在ui线程）" class="headerlink" title="4. 创建Call并执行（okHttp的返回结果并没有在ui线程）"></a>4. 创建Call并执行（okHttp的返回结果并没有在ui线程）</h4><pre><code>Call call = mOkHttpClient.newCall(request);复制代码</code></pre><ul><li>同步执行</li></ul><pre><code>Response mResponse=call.execute();        if (mResponse.isSuccessful()) {                return mResponse.body().string();       } else {           throw new IOException(&quot;Unexpected code &quot; + mResponse);       }复制代码</code></pre><ul><li>异步执行</li></ul><pre><code>call.enqueue(new Callback() {        @Override        public void onFailure(Request request, IOException e) {        }        @Override        public void onResponse(Response response) throws IOException {            String str = response.body().string();            Log.i(&quot;wangshu&quot;, str);            runOnUiThread(new Runnable() {                @Override                public void run() {                    Toast.makeText(getApplicationContext(), &quot;请求成功&quot;, Toast.LENGTH_SHORT).show();                }            });        }    });复制代码</code></pre><h4 id="4-封装"><a href="#4-封装" class="headerlink" title="4. 封装"></a>4. 封装</h4><p>因为以下原因，所以我们需要封装：</p><ul><li>避免重复代码编写</li><li>请求的回调改为UI线程</li><li>其他需要的逻辑：例如加解密等</li></ul><h3 id="OkHttp中的设计模式"><a href="#OkHttp中的设计模式" class="headerlink" title="OkHttp中的设计模式"></a>OkHttp中的设计模式</h3><ol><li>Builder模式：OkHttpClient 和Request等都是通过Builder模式创建的</li><li>责任链模式：拦截器通过责任链模式进行工作</li><li>门面模式：整体采用门面模式，OkHttpClient为门面，向子系统委派任务</li><li>享元模式：连接池等采用了享元模式</li><li>其他：工厂模式、代理模式等</li></ol><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a><a href="http://liuwangshu.cn/application/network/7-okhttp3-sourcecode.html" target="_blank" rel="noopener">源码分析</a></h3><h4 id="1-Call"><a href="#1-Call" class="headerlink" title="1. Call"></a>1. Call</h4><ul><li>Call的实现类为RealCall</li><li>在执行execute或者enqueue时，会取出okHttpClient中的Dispatcher执行对应的方法</li></ul><pre><code>client.dispatcher().enqueue(new AsyncCall(responseCallback, forWebSocket));复制代码</code></pre><h4 id="2-Diapatcher"><a href="#2-Diapatcher" class="headerlink" title="2. Diapatcher"></a>2. Diapatcher</h4><ul><li>Diapatcher在OkHttpClient build时进行初始化</li><li>Dispatcher负责进行任务调度，内部维护一个线程池，处理并发请求</li><li>Dispatcher内部有三个队列</li></ul><pre><code>/** 将要运行的异步请求队列 */private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();/**正在运行的异步请求队列 */private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();/** 正在运行的同步请求队列 */private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();复制代码</code></pre><ul><li>执行时，线程会调用AsyncCall的excute方法</li></ul><h4 id="3-AsyncCall"><a href="#3-AsyncCall" class="headerlink" title="3. AsyncCall"></a>3. AsyncCall</h4><ul><li>AsyncCall是RealCall的一个内部类，实现了Runnalbe接口</li><li>AsyncCall 通过 getResponseWithInterceptorChain方法取得Response</li><li>执行完毕后通过client.dispatcher().finished(this)；将自身从dispatcher队列中取出，并取出下一个加入相应队列</li></ul><pre><code>//AsyncCall 的excute方法@Override protected void execute() {  boolean signalledCallback = false;  try {    Response response = getResponseWithInterceptorChain(forWebSocket);    if (canceled) {      signalledCallback = true;      responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));    } else {      signalledCallback = true;      responseCallback.onResponse(RealCall.this, response);    }  } catch (IOException e) {    if (signalledCallback) {      // Do not signal the callback twice!      logger.log(Level.INFO, &quot;Callback failure for &quot; + toLoggableString(), e);    } else {      responseCallback.onFailure(RealCall.this, e);    }  } finally {    client.dispatcher().finished(this);  }}复制代码</code></pre><h4 id="4-getResponseWithInterceptorChain"><a href="#4-getResponseWithInterceptorChain" class="headerlink" title="4. getResponseWithInterceptorChain"></a>4. getResponseWithInterceptorChain</h4><p>getResponseWithInterceptorChain是用责任链的方式，执行拦截器，对请求和请求结果进行处理</p><ul><li>getResponseWithInterceptorChain 中创建拦截器，并创建第一个RealInterceptorChain，执行其proceed方法</li></ul><pre><code>Response getResponseWithInterceptorChain() throws IOException {    // Build a full stack of interceptors.    List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();    interceptors.addAll(client.interceptors());    interceptors.add(retryAndFollowUpInterceptor);    interceptors.add(new BridgeInterceptor(client.cookieJar()));    interceptors.add(new CacheInterceptor(client.internalCache()));    interceptors.add(new ConnectInterceptor(client));    if (!forWebSocket) {      interceptors.addAll(client.networkInterceptors());    }    interceptors.add(new CallServerInterceptor(forWebSocket));    Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,        originalRequest, this, eventListener, client.connectTimeoutMillis(),        client.readTimeoutMillis(), client.writeTimeoutMillis());    return chain.proceed(originalRequest);  }复制代码</code></pre><ul><li>RealInterceptorChain的proceed方法中，会取出拦截器，并创建下一个Chain，将其作为参数传给拦截器的intercept方法</li></ul><pre><code>  // If there&#39;s another interceptor in the chain, call that.  if (index &lt; client.interceptors().size()) {    Interceptor.Chain chain = new ApplicationInterceptorChain(index + 1, request, forWebSocket);    //从拦截器列表取出拦截器    Interceptor interceptor = client.interceptors().get(index);    Response interceptedResponse = interceptor.intercept(chain);    if (interceptedResponse == null) {      throw new NullPointerException(&quot;application interceptor &quot; + interceptor          + &quot; returned null&quot;);    }    return interceptedResponse;  }  // No more interceptors. Do HTTP.  return getResponse(request, forWebSocket);}复制代码</code></pre><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><h4 id="1-自定义拦截器"><a href="#1-自定义拦截器" class="headerlink" title="1. 自定义拦截器"></a>1. <a href="https://www.jianshu.com/p/d04b463806c8" target="_blank" rel="noopener">自定义拦截器</a></h4><ul><li>自定义拦截器分为两类，interceptor和networkInterceptor（区别：networkInterceptor处理网络相关任务，如果response直接从缓存返回了，那么有可能不会执行networkInterceptor）</li><li>自定义方式：实现Interceptor，重写intercept方法，并注册拦截器</li></ul><h4 id="2-系统拦截器"><a href="#2-系统拦截器" class="headerlink" title="2. 系统拦截器"></a>2. <a href="https://blog.csdn.net/lepaitianshi/article/details/72457928" target="_blank" rel="noopener">系统拦截器</a></h4><ul><li>RetryAndFollowUpInterceptor：进行失败重试和重定向</li><li>BridgeInterceptor：添加头部信息</li><li>CacheInterceptor：处理缓存</li><li>ConnectInterceptor：获取可用的connection实例</li><li>CallServerInterceptor：发起请求</li></ul><h3 id="连接池复用"><a href="#连接池复用" class="headerlink" title="连接池复用"></a><a href="http://liuwangshu.cn/application/network/8-okhttp3-sourcecode2.html" target="_blank" rel="noopener">连接池复用</a></h3><p>在ConnectInterceptor中，我们获取到了connection的实例，该实例是从ConnectionPool中取得</p><h4 id="1-Connection"><a href="#1-Connection" class="headerlink" title="1. Connection"></a>1. Connection</h4><ul><li>Connection 是客户端和服务器建立的数据通路，一个Connection上可能存在几个链接</li><li>Connection的实现类是RealConnection，是socket物理连接的包装</li><li>Connection内部维持着一个List<Reference>引用</li></ul><h4 id="2-StreamAllocation"><a href="#2-StreamAllocation" class="headerlink" title="2. StreamAllocation"></a>2. StreamAllocation</h4><p>StreamAllocation是Connection维护的连接，以下是类内注解</p><pre><code> &lt;ul&gt; *     &lt;li&gt;&lt;strong&gt;Connections:&lt;/strong&gt; physical socket connections to remote servers. These are *         potentially slow to establish so it is necessary to be able to cancel a connection *         currently being connected. *     &lt;li&gt;&lt;strong&gt;Streams:&lt;/strong&gt; logical HTTP request/response pairs that are layered on *         connections. Each connection has its own allocation limit, which defines how many *         concurrent streams that connection can carry. HTTP/1.x connections can carry 1 stream *         at a time, HTTP/2 typically carry multiple. *     &lt;li&gt;&lt;strong&gt;Calls:&lt;/strong&gt; a logical sequence of streams, typically an initial request and *         its follow up requests. We prefer to keep all streams of a single call on the same *         connection for better behavior and locality. * &lt;/ul&gt;复制代码</code></pre><h4 id="3-ConnectionPool"><a href="#3-ConnectionPool" class="headerlink" title="3. ConnectionPool"></a>3. ConnectionPool</h4><p>ConnectionPool通过Address等来查找有没有可以复用的Connection，同时维护一个线程池，对Connection做回收工作</p><h2 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h2><hr><p>Retrofit帮助我们对OkHttp进行了封装，使网络请求更加方便</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a><a href="https://www.jianshu.com/p/a3e162261ab6" target="_blank" rel="noopener">使用</a></h3><h4 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1. 添加依赖"></a>1. 添加依赖</h4><pre><code>dependencies {    compile &#39;com.squareup.retrofit2:retrofit:2.0.2&#39;  }复制代码</code></pre><h4 id="2-创建Retrofit实例"><a href="#2-创建Retrofit实例" class="headerlink" title="2. 创建Retrofit实例"></a>2. 创建Retrofit实例</h4><pre><code>Retrofit retrofit = new Retrofit.Builder()  .baseUrl(&quot;http://fanyi.youdao.com/&quot;) // 设置网络请求的Url地址 .addConverterFactory(GsonConverterFactory.create()) // 设置数据解析器  .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) // 支持RxJava平台 .build();复制代码</code></pre><h4 id="3-创建网络接口"><a href="#3-创建网络接口" class="headerlink" title="3. 创建网络接口"></a>3. 创建网络接口</h4><pre><code>@GET(&quot;user&quot;)Call&lt;User&gt; getUser(@Header(&quot;Authorization&quot;) String authorization)复制代码</code></pre><h4 id="4-创建Call"><a href="#4-创建Call" class="headerlink" title="4. 创建Call"></a>4. 创建Call</h4><pre><code> GetRequest_Interface request = retrofit.create(GetRequest_Interface.class);//对 发送请求 进行封装Call&lt;Reception&gt; call = request.getCall();复制代码</code></pre><h4 id="5-执行Call的请求方法"><a href="#5-执行Call的请求方法" class="headerlink" title="5. 执行Call的请求方法"></a>5. 执行Call的请求方法</h4><pre><code>//发送网络请求(异步) call.enqueue(new Callback&lt;Translation&gt;() { //请求成功时回调 @Override public void onResponse(Call&lt;Translation&gt; call, Response&lt;Translation&gt; response) {    //请求处理,输出结果    response.body().show();  }  //请求失败时候的回调  @Override  public void onFailure(Call&lt;Translation&gt; call, Throwable throwable) {      System.out.println(&quot;连接失败&quot;);  }  }); // 发送网络请求（同步） Response&lt;Reception&gt; response = call.execute();复制代码</code></pre><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a><a href="https://www.jianshu.com/p/0c055ad46b6c" target="_blank" rel="noopener">源码解析</a></h3><h4 id="1-Retrofit"><a href="#1-Retrofit" class="headerlink" title="1. Retrofit"></a>1. Retrofit</h4><p>Retrofit 通过builder模式创建，我们可以对其进行各种设置：</p><ul><li>baseUrl：请求地址的头部，必填</li><li>callFactory：网络请求工厂（不进行设置的话默认会生成一个OkHttpClient）</li><li>adapterFactories：网络请求适配器工厂的集合，这里有适配器因为Retrofit不仅支持Android，还支持Ios等其他平台（不进行设置的话会根据平台自动生成）</li><li>converterFactories：数据转换器工厂的集合（将网络返回的数据转换成我们需要的类）</li><li>callbackExecutor：回调方法执行器（Android平台默认通过Handler发送到主线程执行）</li></ul><h4 id="2-Call"><a href="#2-Call" class="headerlink" title="2. Call"></a>2. Call</h4><p>我们的每个method对应一个Call， Call的创建分为两步：</p><ul><li>retorfit.create(myInfterfaceClass.class)创建我们网络请求接口类的实例</li><li>调用对应方法拿到对应网络请求的Call</li></ul><p>关键在第一步，第一步是通过动态代理实现的</p><pre><code>public &lt;T&gt; T create(final Class&lt;T&gt; service) {  Utils.validateServiceInterface(service);  if (validateEagerly) {    eagerlyValidateMethods(service);  }  return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] { service },      new InvocationHandler() {        private final Platform platform = Platform.get();        @Override public Object invoke(Object proxy, Method method, Object... args)            throws Throwable {          // If the method is a method from Object then defer to normal invocation.          if (method.getDeclaringClass() == Object.class) {            return method.invoke(this, args);          }          if (platform.isDefaultMethod(method)) {            return platform.invokeDefaultMethod(method, service, proxy, args);          }          ServiceMethod serviceMethod = loadServiceMethod(method);//1          OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);          return serviceMethod.callAdapter.adapt(okHttpCall);        }      });}复制代码</code></pre><ul><li>通过loadServiceMethod方法生成mehtod对应的ServiceMethod</li><li>将ServiceMethod和方法参数传进OkHttpCall生成OkHttpCall</li><li>调用callAdapter方法对OkHttpCall进行处理并返回</li></ul><h5 id="1-ServiceMethod"><a href="#1-ServiceMethod" class="headerlink" title="1. ServiceMethod"></a>1. ServiceMethod</h5><p>loadServiceMethod方法会首先在缓存里查找是否有该method对应的ServiceMethod，没有的话调用build方法创建一个</p><pre><code>ServiceMethod loadServiceMethod(Method method) { ServiceMethod result;  // 设置线程同步锁  synchronized (serviceMethodCache) {  result = serviceMethodCache.get(method);  // ServiceMethod类对象采用了单例模式进行创建   // 即创建ServiceMethod对象前，先看serviceMethodCache有没有缓存之前创建过的网络请求实例   // 若没缓存，则通过建造者模式创建   serviceMethod 对象 if (result == null) {   // 下面会详细介绍ServiceMethod生成实例的过程   result = new ServiceMethod.Builder(this, method).build();   serviceMethodCache.put(method, result);    }   }  return result;}复制代码</code></pre><p>ServiceMethod的创建过程即是对method的解析过程，解析过程包括：对注解的解析，寻找合适的CallAdapter和Convert等</p><h5 id="2-OkHttpCall"><a href="#2-OkHttpCall" class="headerlink" title="2. OkHttpCall"></a>2. OkHttpCall</h5><p>OkHttpCall实现了Call接口，当执行excute或enqueue请求命令时，内部通过传入的CallFactory（OkHttpClient）执行网络请求</p><h5 id="3-callAdapter"><a href="#3-callAdapter" class="headerlink" title="3. callAdapter"></a>3. callAdapter</h5><p>如果我们没有对CallAdapter进行设置，它的值将是Android平台的默认设置，其adapt方法如下</p><pre><code>public &lt;R&gt; Call&lt;R&gt; adapt(Call&lt;R&gt; call) {     return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call); } ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) { this.delegate = delegate;  // 把上面创建并配置好参数的OkhttpCall对象交给静态代理delegate  // 静态代理和动态代理都属于代理模式  // 静态代理作用：代理执行被代理者的方法，且可在要执行的方法前后加入自己的动作，进行对系统功能的拓展  this.callbackExecutor = callbackExecutor;  // 传入上面定义的回调方法执行器  // 用于进行线程切换 }复制代码</code></pre><p>ExecutorCallbackCall对OkHttpCall进行了装饰，会调用CallBackExcutor对OkHttpCall执行的返回结果进行处理，使其位于主线程</p><h3 id="自定义Convert和CallAdapter"><a href="#自定义Convert和CallAdapter" class="headerlink" title="自定义Convert和CallAdapter"></a><a href="https://www.jianshu.com/p/308f3c54abdd" target="_blank" rel="noopener">自定义Convert和CallAdapter</a></h3><h2 id="Fresco"><a href="#Fresco" class="headerlink" title="Fresco"></a><a href="https://www.fresco-cn.org/" target="_blank" rel="noopener">Fresco</a></h2><hr><p>Fresco是一个图片加载库，可以帮助我们加载图片显示，控制多线程，以及管理缓存和内存等</p><h3 id="Fresco使用"><a href="#Fresco使用" class="headerlink" title="Fresco使用"></a><a href="https://www.fresco-cn.org/docs/index.html" target="_blank" rel="noopener">Fresco使用</a></h3><ol><li>引入依赖</li></ol><pre><code>dependencies {  // 其他依赖  compile &#39;com.facebook.fresco:fresco:0.12.0&#39;   // 在 API &lt; 14 上的机器支持 WebP 时，需要添加  compile &#39;com.facebook.fresco:animated-base-support:0.12.0&#39;  // 支持 GIF 动图，需要添加  compile &#39;com.facebook.fresco:animated-gif:0.12.0&#39;  // 支持 WebP （静态图+动图），需要添加  compile &#39;com.facebook.fresco:animated-webp:0.12.0&#39;  compile &#39;com.facebook.fresco:webpsupport:0.12.0&#39;  // 仅支持 WebP 静态图，需要添加  compile &#39;com.facebook.fresco:webpsupport:0.12.0&#39;}复制代码</code></pre><ol><li>初始化</li></ol><pre><code>Fresco.initialize(Context context);复制代码</code></pre><ol><li>使用SimpleView</li></ol><pre><code>&lt;com.facebook.drawee.view.SimpleDraweeView    android:id=&quot;@+id/my_image_view&quot;    android:layout_width=&quot;130dp&quot;    android:layout_height=&quot;130dp&quot;    fresco:placeholderImage=&quot;@drawable/my_drawable&quot;  /&gt;复制代码</code></pre><ol><li>加载图片</li></ol><pre><code>Uri uri = Uri.parse(&quot;https://raw.githubusercontent.com/facebook/fresco/gh-pages/static/logo.png&quot;);SimpleDraweeView draweeView = (SimpleDraweeView) findViewById(R.id.my_image_view);draweeView.setImageURI(uri);复制代码</code></pre><ol><li>以上是Fresco的基本加载流程，此外，我们可以定制加载和显示的各个环节</li></ol><p>Fresco由两部分组成，Drawees负责图片的呈现，ImagePipeline负责图片的下载解码和内存管理</p><h3 id="Drawees"><a href="#Drawees" class="headerlink" title="Drawees"></a><a href="https://www.fresco-cn.org/docs/concepts.html" target="_blank" rel="noopener">Drawees</a></h3><p>Drawees 负责图片的呈现。它由三个元素组成，有点像MVC模式。</p><h4 id="DraweeView"><a href="#DraweeView" class="headerlink" title="DraweeView"></a>DraweeView</h4><ul><li>继承于 View, 负责图片的显示。</li><li>一般情况下，使用 SimpleDraweeView 即可。 你可以在 XML 或者在 Java 代码中使用它，通过 setImageUri 给它设置一个 URI 来使用，这里有简单的入门教学：开始使用</li><li>你可以使用 XML属性来达到各式各样的效果。</li></ul><h4 id="DraweeHierarchy"><a href="#DraweeHierarchy" class="headerlink" title="DraweeHierarchy"></a>DraweeHierarchy</h4><ul><li>DraweeHierarchy 用于组织和维护最终绘制和呈现的 Drawable 对象，相当于MVC中的M。</li><li>你可以通过它来在Java代码中自定义图片的展示</li></ul><h4 id="DraweeController"><a href="#DraweeController" class="headerlink" title="DraweeController"></a>DraweeController</h4><ul><li>DraweeController 负责和 image loader 交互（ Fresco 中默认为 image pipeline, 当然你也可以指定别的），可以创建一个这个类的实例，来实现对所要显示的图片做更多的控制。</li><li>如果你还需要对Uri加载到的图片做一些额外的处理，那么你会需要这个类的。</li></ul><h4 id="DraweeControllerBuilder"><a href="#DraweeControllerBuilder" class="headerlink" title="DraweeControllerBuilder"></a>DraweeControllerBuilder</h4><ul><li>DraweeControllers 由 DraweeControllerBuilder 采用 Builder 模式创建，创建之后，不可修改。具体参见: 使用ControllerBuilder。</li></ul><h4 id="Listeners"><a href="#Listeners" class="headerlink" title="Listeners"></a>Listeners</h4><ul><li>使用 ControllerListener 的一个场景就是设置一个 Listener监听图片的下载。</li></ul><h3 id="ImagePipeline"><a href="#ImagePipeline" class="headerlink" title="ImagePipeline"></a>ImagePipeline</h3><ul><li>Fresco 的 Image Pipeline 负责图片的获取和管理。图片可以来自远程服务器，本地文件，或者Content Provider，本地资源。压缩后的文件缓存在本地存储中，Bitmap数据缓存在内存中。</li><li>在5.0系统以下，Image Pipeline 使用 pinned purgeables 将Bitmap数据避开Java堆内存，存在ashmem中。这要求图片不使用时，要显式地释放内存</li><li>SimpleDraweeView自动处理了这个释放过程，所以没有特殊情况，尽量使用SimpleDraweeView，在特殊的场合，如果有需要，也可以直接控制Image Pipeline。</li><li>ImagePipeline加载图片流程</li></ul><blockquote><ol><li>检查内存缓存，如有，返回</li></ol></blockquote><ol><li>后台线程开始后续工作</li><li>检查是否在未解码内存缓存中。如有，解码，变换，返回，然后缓存到内存缓存中。</li><li>检查是否在磁盘缓存中，如果有，变换，返回。缓存到未解码缓存和内存缓存中。</li><li>从网络或者本地加载。加载完成后，解码，变换，返回。存到各个缓存中。</li></ol><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="480" height="342"></svg>)</p><h4 id="ImagePipeline的线程池"><a href="#ImagePipeline的线程池" class="headerlink" title="ImagePipeline的线程池"></a>ImagePipeline的线程池</h4><p>Image pipeline 默认有3个线程池:</p><blockquote><ol><li>3个线程用于网络下载</li></ol></blockquote><ol><li>2个线程用于磁盘操作: 本地文件的读取，磁盘缓存操作。</li><li>2个线程用于CPU相关的操作: 解码，转换，以及后处理等后台操作。</li></ol><h4 id="ImagePipeline的-缓存"><a href="#ImagePipeline的-缓存" class="headerlink" title="ImagePipeline的 缓存"></a>ImagePipeline的 缓存</h4><p>ImagePipeLine有三级缓存</p><blockquote><ol><li>解码后的Bitmap缓存</li><li>未解码图片的内存缓存</li><li>磁盘缓存</li></ol></blockquote><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a><a href="https://www.jianshu.com/p/6729dc17586b" target="_blank" rel="noopener">对比</a></h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>Fresco 相对于Glide/Picaso等拥有更多的功能，如图片的渐进式加载/动图/圆角等，</p><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>Fresco采用三级缓存：</p><blockquote><ol><li>解码后的Bitmap缓存</li><li>未解码图片的内存缓存</li><li>磁盘缓存</li></ol></blockquote><p>Glide两级缓存：</p><blockquote><ol><li>根据ImageView控件尺寸获得对应的大小的bitmap来展示，可以缓存原始数据或者resize后数据</li><li>磁盘缓存</li></ol></blockquote><h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><p>Fresco通过CloseableReference管理图片，通过图片控件DraweeView来显示图片和控制图片释放，虽然扩展性高，但是扩展起来麻烦；对项目有一定侵入性</p><h2 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h2><hr><p>EventBus使用了观察者模式，方便我们项目中进行数据传递和通信</p><h3 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a><a href="https://www.jianshu.com/p/acfe78296bb5" target="_blank" rel="noopener">使用</a></h3><ol><li>添加依赖</li></ol><pre><code>compile &#39;org.greenrobot:eventbus:3.0.0&#39;复制代码</code></pre><ol><li>注册和解绑</li></ol><pre><code>EventBus.getDefault().register(this);EventBus.getDefault().unregister(this);复制代码</code></pre><ol><li>添加订阅消息方法</li></ol><pre><code>@Subscribe(threadMode = ThreadMode.MAIN) public void onEvent(MessageEvent event) {    /* Do something */}复制代码</code></pre><ol><li>发送消息</li></ol><pre><code>EventBus.getDefault().post(new MessageEvent(&quot;Hello !.....&quot;));复制代码</code></pre><h4 id="Subscribe注解"><a href="#Subscribe注解" class="headerlink" title="@Subscribe注解"></a>@Subscribe注解</h4><p>该注解内部有三个成员，分别是threadMode、sticky、priority。</p><blockquote><ol><li>threadMode代表订阅方法所运行的线程</li><li>sticky代表是否是粘性事件</li><li>priority代表优先级</li></ol></blockquote><h4 id="threadMode"><a href="#threadMode" class="headerlink" title="threadMode"></a>threadMode</h4><blockquote><ol><li>POSTING:表示订阅方法运行在发送事件的线程。</li><li>MAIN：表示订阅方法运行在UI线程，由于UI线程不能阻塞，因此当使用MAIN的时候，订阅方法不应该耗时过长。</li><li>BACKGROUND：表示订阅方法运行在后台线程，如果发送的事件线程不是UI线程，那么就使用该线程；如果发送事件的线程是UI线程，那么新建一个后台线程来调用订阅方法。</li><li>ASYNC：订阅方法与发送事件始终不在同一个线程，即订阅方法始终会使用新的线程来运行。</li></ol></blockquote><h4 id="sticky-粘性事件"><a href="#sticky-粘性事件" class="headerlink" title="sticky 粘性事件"></a>sticky 粘性事件</h4><p>在注册之前便把事件发生出去，等到注册之后便会收到最近发送的粘性事件（必须匹配）。注意：只会接收到最近发送的一次粘性事件，之前的会接受不到,demo</p><h3 id="源码解析-1"><a href="#源码解析-1" class="headerlink" title="源码解析"></a><a href="https://www.jianshu.com/p/bda4ed3017ba" target="_blank" rel="noopener">源码解析</a></h3><p>参见链接</p><h3 id="性能-1"><a href="#性能-1" class="headerlink" title="性能"></a><a href="https://segmentfault.com/a/1190000005089229" target="_blank" rel="noopener">性能</a></h3><ol><li>EventBus通过反射的方式对@Subscribe方法进行解析。</li><li>默认情况下，解析是运行时进行的，但是我们也可以通过设置和加载依赖库，使其编译时形成索引，其性能会大大提升</li></ol>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
            <tag> 知识 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面试知识</title>
      <link href="/2020/03/19/java-interview/"/>
      <url>/2020/03/19/java-interview/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-面试基础知识"><a href="#Java-面试基础知识" class="headerlink" title="Java 面试基础知识"></a>Java 面试基础知识</h1><h2 id="Java设计思想"><a href="#Java设计思想" class="headerlink" title="Java设计思想"></a>Java设计思想</h2><h3 id="0-OOP是什么"><a href="#0-OOP是什么" class="headerlink" title="0. OOP是什么"></a>0. OOP是什么</h3><blockquote><p>面向对象编程（Object Oriented Programming）</p></blockquote><h3 id="1-面向对象的特征有哪些"><a href="#1-面向对象的特征有哪些" class="headerlink" title="1.面向对象的特征有哪些"></a>1.面向对象的特征有哪些</h3><p>面向对象的特征有：<strong>抽象</strong>、<strong>封装</strong>、<strong>继承</strong>、<strong>多态</strong></p><blockquote><ol><li>抽象：抽象是将<strong>一类对象的共同特征</strong>总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</li><li>封装：隐藏对象的实现细节，仅对外公开接口，是针对一个对象来说的</li><li>多态：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情</li><li>继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）</li></ol></blockquote><h3 id="2-java是值传递还是引用传递"><a href="#2-java是值传递还是引用传递" class="headerlink" title="2. java是值传递还是引用传递"></a>2. java是值传递还是引用传递</h3><blockquote><p>java是值传递。可以理解为传入的是一个引用的副本，指向统一地址。当值改变时，原引用和副本指向地址中的值都变了；当副本指向的地址改变，指向新值时，原引用指向的地址没有改变，原值也没有改变。</p></blockquote><p>基础类型如int long等，引用类型例如String</p><pre class=" language-Java"><code class="language-Java">第一个例子：基本类型void foo(int value) {    value = 100;}foo(num); // num 没有被改变第二个例子：没有提供改变自身方法的引用类型void foo(String text) {    text = "windows";}foo(str); // str 也没有被改变第三个例子：提供了改变自身方法的引用类型StringBuilder sb = new StringBuilder("iphone");void foo(StringBuilder builder) {    builder.append("4");}foo(sb); // sb 被改变了，变成了"iphone4"。第四个例子：提供了改变自身方法的引用类型，但是不使用，而是使用赋值运算符。StringBuilder sb = new StringBuilder("iphone");void foo(StringBuilder builder) {    builder = new StringBuilder("ipad");}foo(sb); // sb 没有被改变，还是 "iphone"。</code></pre><p>Java 堆(Heap) 和 栈(Stack) 。</p><h4 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h4><p><strong>从局部变量/方法参数开始讲起：</strong></p><p>局部变量和方法参数在jvm中的储存方法是相同的，都是在栈上开辟空间来储存的，随着进入方法开辟，退出方法回收。以32位JVM为例，boolean/byte/short/char/int/float以及引用都是分配4字节空间，long/double分配8字节空间。对于每个方法来说，最多占用多少空间是一定的，这在编译时就可以计算好。</p><p>我们都知道JVM内存模型中有，stack和heap的存在，但是更准确的说，是每个线程都分配一个独享的stack，所有线程共享一个heap。对于每个方法的局部变量来说，是绝对无法被其他方法，甚至其他线程的同一方法所访问到的，更遑论修改。</p><p>当我们在方法中声明一个 int i = 0，或者 Object obj = null 时，仅仅涉及stack，不影响到heap，当我们 new Object() 时，会在heap中开辟一段内存并初始化Object对象。当我们将这个对象赋予obj变量时，仅仅是stack中代表obj的那4个字节变更为这个对象的地址。</p><p><strong>数组类型引用和对象：</strong></p><p>当我们声明一个数组时，如int[] arr = new int[10]，因为数组也是对象，arr实际上是引用，stack上仅仅占用4字节空间，new int[10]会在heap中开辟一个数组对象，然后arr指向它。</p><p>当我们声明一个二维数组时，如 int[][] arr2 = new int[2][4]，arr2同样仅在stack中占用4个字节，会在内存中开辟一个长度为2的，类型为int[]的数组，然后arr2指向这个数组。这个数组内部有两个引用（大小为4字节），分别指向两个长度为4的类型为int的数组。</p><p><img src="v2-6590cb935ae8bf3b7241cb309fe041d7_hd.jpg" alt="v2-6590cb935ae8bf3b7241cb309fe041d7_hd"></p><p>所以当我们传递一个数组引用给一个方法时，数组的元素是可以被改变的，但是无法让数组引用指向新的数组。</p><p>你还可以这样声明：int[][] arr3 = new int[3][]，这时内存情况如下图</p><p><img src="v2-fdc86227021d56a02b559d6485983c71_hd.jpg" alt="img"></p><p>你还可以这样 arr3[0] = new int [5]; arr3[1] = arr2[0];</p><p><img src="v2-fdc5e737a95d625a47d66ab61e4a2f55_hd.jpg" alt="img"></p><p><strong>关于String：</strong></p><p>原本回答中关于String的图解是简化过的，实际上String对象内部仅需要维护三个变量，char[] chars, int startIndex, int length。而chars在某些情况下是可以共用的。但是因为String被设计成为了不可变类型，所以你思考时把String对象简化考虑也是可以的。</p><p>String str = new String(“hello”)</p><p><img src="v2-a143d0a3594d06f54c6853c46c429e08_hd.jpg" alt="img"></p><p>当然某些JVM实现会把”hello”字面量生成的String对象放到常量池中，而常量池中的对象可以实际分配在heap中，有些实现也许会分配在方法区，当然这对我们理解影响不大。</p><h3 id="3-设计模式之面向对象七大基本原则"><a href="#3-设计模式之面向对象七大基本原则" class="headerlink" title="3. 设计模式之面向对象七大基本原则"></a>3. 设计模式之面向对象七大基本原则</h3><h4 id="单一职责原则（Single-Responsibility-Principle）"><a href="#单一职责原则（Single-Responsibility-Principle）" class="headerlink" title="单一职责原则（Single Responsibility Principle）"></a>单一职责原则（Single Responsibility Principle）</h4><p>每一个类应该专注于做一件事情。</p><h4 id="里氏替换原则（Liskov-Substitution-Principle）"><a href="#里氏替换原则（Liskov-Substitution-Principle）" class="headerlink" title="里氏替换原则（Liskov Substitution Principle）"></a>里氏替换原则（Liskov Substitution Principle）</h4><p>超类存在的地方，子类是可以替换的。</p><h4 id="依赖倒置原则（Dependence-Inversion-Principle）"><a href="#依赖倒置原则（Dependence-Inversion-Principle）" class="headerlink" title="依赖倒置原则（Dependence Inversion Principle）"></a>依赖倒置原则（Dependence Inversion Principle）</h4><p>实现尽量依赖抽象，不依赖具体实现。</p><h4 id="接口隔离原则（Interface-Segregation-Principle）"><a href="#接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="接口隔离原则（Interface Segregation Principle）"></a>接口隔离原则（Interface Segregation Principle）</h4><p>应当为客户端提供尽可能小的单独的接口，而不是提供大的总的接口。</p><h4 id="迪米特法则（Law-Of-Demeter）"><a href="#迪米特法则（Law-Of-Demeter）" class="headerlink" title="迪米特法则（Law Of Demeter）"></a>迪米特法则（Law Of Demeter）</h4><p>又叫最少知识原则，一个软件实体应当尽可能少的与其他实体发生相互作用。</p><h4 id="开闭原则（Open-Close-Principle）"><a href="#开闭原则（Open-Close-Principle）" class="headerlink" title="开闭原则（Open Close Principle）"></a>开闭原则（Open Close Principle）</h4><p>面向扩展开放，面向修改关闭。</p><h4 id="组合-聚合复用原则（Composite-Aggregate-Reuse-Principle-CARP）"><a href="#组合-聚合复用原则（Composite-Aggregate-Reuse-Principle-CARP）" class="headerlink" title="组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）"></a>组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）</h4><p>尽量使用合成/聚合达到复用，尽量少用继承。原则： 一个类中有另一个类的对象。</p><h4 id="细则"><a href="#细则" class="headerlink" title="细则"></a>细则</h4><h5 id="单一职责原则（Single-Responsibility-Principle）-1"><a href="#单一职责原则（Single-Responsibility-Principle）-1" class="headerlink" title="单一职责原则（Single Responsibility Principle）"></a>单一职责原则（Single Responsibility Principle）</h5><p>因为：</p><p>可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；提高类的可读性，提高系统的可维护性；变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则。</p><p>所以：</p><p>从大局上看Android中的Paint和Canvas等类都遵守单一职责原则，Paint和Canvas各司其职。</p><h5 id="里氏替换原则（Liskov-Substitution-Principle）-1"><a href="#里氏替换原则（Liskov-Substitution-Principle）-1" class="headerlink" title="里氏替换原则（Liskov Substitution Principle）"></a>里氏替换原则（Liskov Substitution Principle）</h5><p>因为：</p><p>里氏替换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。里氏替换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</p><p>所以：</p><p>使用里氏替换原则时需要注意，子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。</p><p>从大局看Java的多态就属于这个原则。</p><h5 id="依赖倒置原则（Dependence-Inversion-Principle）-1"><a href="#依赖倒置原则（Dependence-Inversion-Principle）-1" class="headerlink" title="依赖倒置原则（Dependence Inversion Principle）"></a>依赖倒置原则（Dependence Inversion Principle）</h5><p>因为：</p><p>具体依赖抽象，上层依赖下层。假设B是较A低的模块，但B需要使用到A的功能，这个时候，B不应当直接使用A中的具体类；而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口；这样就达到了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能造成循环依赖。</p><p>所以：</p><p>采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，减少并行开发引起的风险，提高代码的可读性和可维护性。</p><p>从大局看Java的多态就属于这个原则。</p><h5 id="接口隔离原则（Interface-Segregation-Principle）-1"><a href="#接口隔离原则（Interface-Segregation-Principle）-1" class="headerlink" title="接口隔离原则（Interface Segregation Principle）"></a>接口隔离原则（Interface Segregation Principle）</h5><p>因为：</p><p>提供尽可能小的单独接口，而不要提供大的总接口。暴露行为让后面的实现类知道的越少越好。譬如类ProgramMonkey通过接口CodeInterface依赖类CodeC，类ProgramMaster通过接口CodeInterface依赖类CodeAndroid，如果接口CodeInterface对于类ProgramMonkey和类CodeC来说不是最小接口，则类CodeC和类CodeAndroid必须去实现他们不需要的方法。将臃肿的接口CodeInterface拆分为独立的几个接口，类ProgramMonkey和类ProgramMaster分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。</p><p>所以：</p><p>建立单一接口，不要建立庞大的接口，尽量细化接口，接口中的方法尽量少。也就是要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的约定，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</p><p>从大局来说Java的接口可以实现多继承就是接口隔离原则的基础保障。</p><h5 id="迪米特法则（Law-Of-Demeter）-1"><a href="#迪米特法则（Law-Of-Demeter）-1" class="headerlink" title="迪米特法则（Law Of Demeter）"></a>迪米特法则（Law Of Demeter）</h5><p>因为：</p><p>类与类之间的关系越密切，耦合度也就越来越大，只有尽量降低类与类之间的耦合才符合设计模式；对于被依赖的类来说，无论逻辑多复杂都要尽量封装在类的内部；每个对象都会与其他对象有耦合关系，我们称出现成员变量、方法参数、方法返回值中的类为直接的耦合依赖，而出现在局部变量中的类则不是直接耦合依赖，也就是说，不是直接耦合依赖的类最好不要作为局部变量的形式出现在类的内部。</p><p>所以：</p><p>一个对象对另一个对象知道的越少越好，即一个软件实体应当尽可能少的与其他实体发生相互作用，在一个类里能少用多少其他类就少用多少，尤其是局部变量的依赖类，能省略尽量省略。同时如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一方法的话，可以通过第三者转发这个调用。</p><p>从大局来说Android App开发中的多Fragment与依赖的Activity间交互通信遵守了这一法则。</p><h5 id="开闭原则（Open-Close-Principle）-1"><a href="#开闭原则（Open-Close-Principle）-1" class="headerlink" title="开闭原则（Open Close Principle）"></a>开闭原则（Open Close Principle）</h5><p>因为：</p><p>开放封闭原则主要体现在对扩展开放、对修改封闭，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。软件需求总是变化的，世界上没有一个软件的是不变的，因此对软件设计人员来说，必须在不需要对原有系统进行修改的情况下，实现灵活的系统扩展。</p><p>所以：</p><p>可以通过Template Method模式和Strategy模式进行重构，实现对修改封闭，对扩展开放的设计思路。<br>封装变化，是实现开放封闭原则的重要手段，对于经常发生变化的状态，一般将其封装为一个抽象，拒绝滥用抽象，只将经常变化的部分进行抽象。</p><h5 id="组合-聚合复用原则（Composite-Aggregate-Reuse-Principle-CARP）-1"><a href="#组合-聚合复用原则（Composite-Aggregate-Reuse-Principle-CARP）-1" class="headerlink" title="组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）"></a>组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）</h5><p>因为：</p><p>其实整个设计模式就是在讲如何类与类之间的组合/聚合。在一个新的对象里面通过关联关系（包括组合关系和聚合关系）使用一些已有的对象，使之成为新对象的一部分，新对象通过委派调用已有对象的方法达到复用其已有功能的目的。也就是，要尽量使用类的合成复用，尽量不要使用继承。</p><p>如果为了复用，便使用继承的方式将两个不相干的类联系在一起，违反里氏代换原则，哪是生搬硬套，忽略了继承了缺点。继承复用破坏数据封装性，将基类的实现细节全部暴露给了派生类，基类的内部细节常常对派生类是透明的，白箱复用；虽然简单，但不安全，不能在程序的运行过程中随便改变；基类的实现发生了改变，派生类的实现也不得不改变；从基类继承而来的派生类是静态的，不可能在运行时间内发生改变，因此没有足够的灵活性。</p><p>所以：</p><p>组合/聚合复用原则可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合/聚合来实现复用；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。</p><h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><h3 id="0-接口的意义"><a href="#0-接口的意义" class="headerlink" title="0. 接口的意义"></a>0. 接口的意义</h3><blockquote><ol><li>规范</li><li>扩展</li><li>回掉</li><li>java是单继承的</li></ol></blockquote><h3 id="1-抽象类的意义"><a href="#1-抽象类的意义" class="headerlink" title="1. 抽象类的意义"></a>1. 抽象类的意义</h3><blockquote><ol><li>为其他子类提供一个公共的类型</li><li>封装子类中重复定义的内容</li><li>定义抽象方法,子类可以有不同的实现</li></ol></blockquote><h3 id="2-抽象类和接口有什么不同"><a href="#2-抽象类和接口有什么不同" class="headerlink" title="2. 抽象类和接口有什么不同"></a>2. 抽象类和接口有什么不同</h3><blockquote><ol><li>单继承：java中只可以继承一个类，但是可以实现多个接口</li><li>成员变量：接口的成员变量都是public static final 的，抽象类可以有各种类型</li><li>方法：抽象类中可以有方法的具体实现，接口中方法都是抽象的</li><li>扩展：//jdk 7 : 只能声明全局常量(public static final)和抽象方法(public abstract) void method1(); // jdk 8 : 声明静态方法 和 默认方法 public static void method2(){ System.out.println(“method2”); } default void method3(){ System.out.println(“method3”); method4(); } //jdk 9 : 声明私有方法 private void method4(){ System.out.println(“私有方法”); }}</li></ol></blockquote><h3 id="3-接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete-class）？"><a href="#3-接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete-class）？" class="headerlink" title="3. 接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？"></a>3. 接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？</h3><blockquote><ol><li>接口可以继承接口,而且支持多重继承</li><li>抽象类可以实现(implements)接口</li><li>抽象类是可继承具体类,也可以继承抽象类</li></ol></blockquote><h3 id="4-Java标识符命名规范"><a href="#4-Java标识符命名规范" class="headerlink" title="4. Java标识符命名规范"></a>4. Java标识符命名规范</h3><h4 id="0-规范（强制）"><a href="#0-规范（强制）" class="headerlink" title="0. 规范（强制）"></a>0. 规范（强制）</h4><blockquote><ol><li>数字、字母、下划线、$（java中内部类编译后会生成包含$的类名） 组成</li><li>不能以数字开头</li><li>不能和关键字或保留关键字相同</li></ol></blockquote><h4 id="1-推荐的命名方式（非强制）"><a href="#1-推荐的命名方式（非强制）" class="headerlink" title="1. 推荐的命名方式（非强制）"></a>1. 推荐的命名方式（非强制）</h4><blockquote><ol><li>方法:java中通常用小驼峰命名法</li><li>常量：通常用大写字母，不同单词间用“_”分隔开，如MOBILE_NUM</li><li>类名：大驼峰命名法</li></ol></blockquote><h2 id="类和方法"><a href="#类和方法" class="headerlink" title="类和方法"></a>类和方法</h2><h3 id="0-一个”-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"><a href="#0-一个”-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？" class="headerlink" title="0. 一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"></a>0. 一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？</h3><blockquote><p>一个”.java”文件内可以有多个类，但只能有一个类是公开的</p></blockquote><h3 id="1-构造器（constructor）是否可被重写（override）"><a href="#1-构造器（constructor）是否可被重写（override）" class="headerlink" title="1. 构造器（constructor）是否可被重写（override）"></a>1. 构造器（constructor）是否可被重写（override）</h3><blockquote><p>构造器不能被继承，因此不能被重写，但可以被重载</p></blockquote><h3 id="2-静态变量和成员变量的区别"><a href="#2-静态变量和成员变量的区别" class="headerlink" title="2. 静态变量和成员变量的区别"></a>2. 静态变量和成员变量的区别</h3><blockquote><ol><li>静态变量属于类，被多个实例共享，成员变量属于实例</li><li>静态变量储存在方法区，成员变量在堆</li><li>静态变量在类加载时候存在，成员变量在实例加载之后存在</li><li>静态方法可以直接使用静态变量，不能直接使用成员变量</li></ol></blockquote><h3 id="3-Object-中定义了哪些方法"><a href="#3-Object-中定义了哪些方法" class="headerlink" title="3. Object 中定义了哪些方法"></a>3. Object 中定义了哪些方法</h3><blockquote><p>clone/toString/wait/notify/notifyAll/equals/hashcode/finalize/getClass</p></blockquote><h3 id="4-Cloneable-实现原理"><a href="#4-Cloneable-实现原理" class="headerlink" title="4. Cloneable 实现原理"></a>4. Cloneable 实现原理</h3><blockquote><ol><li>Cloneable是一个接口，没有具体方法</li><li>clone方法是Object类中方法，会检查当前实例是否实现Cloneable接口，没有实现则抛出异常，实现了就调用native方法进行clone（clone进行的是浅拷贝），源码如下</li></ol></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> Object <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> CloneNotSupportedException <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">Cloneable</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">CloneNotSupportedException</span><span class="token punctuation">(</span><span class="token string">"Class "</span> <span class="token operator">+</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>                                                 <span class="token string">" doesn't implement Cloneable"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">internalClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="5-两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？"><a href="#5-两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？" class="headerlink" title="5. 两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？"></a>5. 两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？</h3><blockquote><ol><li>不对。</li><li>java 规定，值相同，hashCode一定要相同；hashCode相同，值可能不同</li><li>如果值相同，hashCode不同，就会造成Hashset、HashMap等借助hashCode实现的数据结构出现错乱，相同的值或者key可能出现多次</li></ol></blockquote><h3 id="6-如何实现对象的克隆"><a href="#6-如何实现对象的克隆" class="headerlink" title="6. 如何实现对象的克隆"></a>6. 如何实现对象的克隆</h3><blockquote><ol><li>通过实现Cloneable接口实现clone：这里要注意深拷贝和浅拷贝问题，如果该类内部变量是引用类型的，并且内部变量类没有实现Cloneable接口，那么克隆出来的该变量是浅拷贝的（只是复制了引用，两个引用指向统一实例）</li><li>通过实现Serializable接口，通过对象的序列化和反序列化实现克隆。</li></ol></blockquote><pre><code>import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;public class MyUtil {private MyUtil() {throw new AssertionError();}@SuppressWarnings(&quot;unchecked&quot;)public static &lt;T extends Serializable&gt; T clone(T obj) throws Exception {ByteArrayOutputStream bout = new ByteArrayOutputStream();ObjectOutputStream oos = new ObjectOutputStream(bout);oos.writeObject(obj);ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray());ObjectInputStream ois = new ObjectInputStream(bin);return (T) ois.readObject();// 说明：调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义// 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，这一点不同于对外部资源（如文件流）的释放}}</code></pre><h3 id="7-谈一谈”-“与”equals-”的区别"><a href="#7-谈一谈”-“与”equals-”的区别" class="headerlink" title="7. 谈一谈”==“与”equals()”的区别"></a>7. 谈一谈”==“与”equals()”的区别</h3><blockquote><ol><li>== :对于基本类型，比较的是他们的值；对于引用类型，比较的是引用的值，也就是对象实例的地址</li><li>equals()方法是Object类中的方法，默认实现是public boolean equals(Object obj) {return (this == obj);}；我们可以重写该方法达到我们的目的，例如String重写了该方法要求每个字符都相等。</li></ol></blockquote><h3 id="8-类中方法调用顺序"><a href="#8-类中方法调用顺序" class="headerlink" title="8. 类中方法调用顺序"></a>8. 类中方法调用顺序</h3><p>指出下面程序的运行结果</p><pre><code>class A {static {System.out.print(&quot;1&quot;);}public A() {System.out.print(&quot;2&quot;);}}class B extends A{static {System.out.print(&quot;a&quot;);}public B() {System.out.print(&quot;b&quot;);}}public class Hello {public static void main(String[] args) {A ab = new B();ab = new B();}}复制代码</code></pre><blockquote><p>执行结果：1a2b2b。 创建对象时构造器的调用顺序是：  父类静态初始化块  -&gt; 子类静态初始化块 -&gt; 父类初始化块 -&gt;调用了父类构造器 -&gt; 子类初始化块 -&gt; 调用子类的构造器</p></blockquote><h3 id="9-重载（Overload）和重写（Override）的区别"><a href="#9-重载（Overload）和重写（Override）的区别" class="headerlink" title="9. 重载（Overload）和重写（Override）的区别"></a>9. 重载（Overload）和重写（Override）的区别</h3><blockquote><p>重写（Override）和重载（Overload）其实并无联系，可能是因为名称相似，容易引起混淆 &gt; <a href="https://www.runoob.com/java/java-override-overload.html" target="_blank" rel="noopener">重写发生在运行时，重载发生在编译期</a></p></blockquote><h4 id="重写（Override）"><a href="#重写（Override）" class="headerlink" title="重写（Override）"></a>重写（Override）</h4><p>重写是针对父类和子类来说的，是在子类中重写父类的方法。</p><blockquote><ol><li>要求方法名，参数个数和类型必须相同</li><li>返回的数据类型必须与父类相同或者是其子类</li><li>访问修饰符的限制一定要大于父类中该方法的访问修饰符（public&gt;protected&gt;default&gt;private）</li><li>重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常</li></ol></blockquote><h4 id="重载（Overload）"><a href="#重载（Overload）" class="headerlink" title="重载（Overload）"></a>重载（Overload）</h4><p>重载是针对一个类说的，是Java中多态性的一种表现</p><blockquote><ol><li>要求方法名相同</li><li>必须有不同的参数列表</li><li>可以有不同的返回类型</li><li>可以有不同的修饰符</li><li>可以抛出不同的异常。</li></ol></blockquote><pre><code>扩展：华为的面试题中曾经问过这样一个问题 - &quot;为什么不能根据返回类型来区分重载&quot;答：因为调用时不能指定类型信息，编译器不知道你要调用哪个函数。例如：float max(int a, int b);int max(int a, int b);当调用max(1, 2);时无法确定调用的是哪个。参考：https://www.zhihu.com/question/21455159/answer/59874307</code></pre><h3 id="10-阐述静态变量和实例变量的区别。"><a href="#10-阐述静态变量和实例变量的区别。" class="headerlink" title="10. 阐述静态变量和实例变量的区别。"></a>10. 阐述静态变量和实例变量的区别。</h3><blockquote><ol><li>静态变量（static 修饰的变量）属于类，被所有类的实例共享，没有实例时也可通过类直接访问</li><li>实例变量：必须通过实例来访问</li></ol></blockquote><h3 id="11-是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"><a href="#11-是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？" class="headerlink" title="11. 是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"></a>11. 是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？</h3><blockquote><p>不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，在调用静态方法时可能对象并没有被初始化</p></blockquote><h3 id="12-抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被synchronized修饰？"><a href="#12-抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被synchronized修饰？" class="headerlink" title="12. 抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰？"></a>12. 抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰？</h3><blockquote><ol><li>抽象方法不能是静态的：静态方法不能被子类重写，抽象方法必须被子类重写，冲突；</li><li>抽象方法不能是native的：本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的</li><li>抽象方法不能用sychronized：synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的</li></ol></blockquote><h3 id="13-Super与this表示什么"><a href="#13-Super与this表示什么" class="headerlink" title="13. Super与this表示什么"></a>13. Super与this表示什么</h3><blockquote><p>Super表示当前类的父类对象;This表示当前类的对象</p></blockquote><h3 id="14-hashcode-和equals-的关系"><a href="#14-hashcode-和equals-的关系" class="headerlink" title="14. hashcode()和equals()的关系"></a>14. hashcode()和equals()的关系</h3><blockquote><ol><li>equals 相等，hashcode一定相等</li><li>hashcode相等，equals不一定相等</li></ol></blockquote><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="1-内部类的作用"><a href="#1-内部类的作用" class="headerlink" title="1. 内部类的作用"></a>1. <a href="https://blog.csdn.net/mid120/article/details/53644539" target="_blank" rel="noopener">内部类的作用</a></h3><blockquote><ol><li>内部类可以很好的实现隐藏</li><li>内部类拥有外围类的所有元素的访问权限</li><li>可以间接实现多重继承</li><li>可以避免修改接口而实现同一个类中两种同名方法的调用</li></ol></blockquote><h3 id="2-静态嵌套类-Static-Nested-Class-或者叫静态内部类-和内部类（Inner-Class）的不同"><a href="#2-静态嵌套类-Static-Nested-Class-或者叫静态内部类-和内部类（Inner-Class）的不同" class="headerlink" title="2. 静态嵌套类(Static Nested Class,或者叫静态内部类)和内部类（Inner Class）的不同"></a>2. 静态嵌套类(Static Nested Class,或者叫静态内部类)和内部类（Inner Class）的不同</h3><blockquote><ol><li>内部类持有外部类的引用（this），静态内部类不持有</li><li>因为持有外部类的引用，所以new时需要先有外部类的实例，再用外部类实例new内部类实例，举例：new Outer().new Inner();</li><li>扩展：在Android中，因为内部类持用外部类引用，所以容易造成内存泄漏，一般推荐使用静态内部类</li></ol></blockquote><h3 id="3-Anonymous-Inner-Class-匿名内部类-是否可以继承其它类？是否可以实现接口？"><a href="#3-Anonymous-Inner-Class-匿名内部类-是否可以继承其它类？是否可以实现接口？" class="headerlink" title="3. Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？"></a>3. Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？</h3><blockquote><p>可以继承其他类，也可以实现接口</p></blockquote><pre><code>解析：btn.setOnClickListener(new View.OnClickListener(){@Overridepublic void onClick(View view){}})这里new的就是一个匿名内部类，这个匿名内部类实现了View.OnClickListener接口。所以匿名内部类本身一定会继承或实现一个且仅一个类或者接口。复制代码</code></pre><h3 id="4-内部类-非静态内部类-可以引用它的包含类（外部类）的成员吗？有没有什么限制？"><a href="#4-内部类-非静态内部类-可以引用它的包含类（外部类）的成员吗？有没有什么限制？" class="headerlink" title="4. 内部类(非静态内部类)可以引用它的包含类（外部类）的成员吗？有没有什么限制？"></a>4. 内部类(非静态内部类)可以引用它的包含类（外部类）的成员吗？有没有什么限制？</h3><blockquote><ol><li>一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。</li><li>应用局部变量，局部变量前要加final修饰</li></ol></blockquote><h3 id="5"><a href="#5" class="headerlink" title="5. "></a>5. <a href="/2020/03/21/java-android-final/" title="内部类访问局部变量的时候，为什么要加final">内部类访问局部变量的时候，为什么要加final</a></h3><blockquote><ol><li>内部类和局部变量生命周期不同（方法结束后局部变量的生命周期就结束了，而内部类只要有引用就不结束，内部类的生命周期&gt;=局部变量）</li><li>Java为了解决这一问题，会在编译时在内部类的构造方法里边，将局部变量作为参数传入内部类</li><li>这就造成了局部变量如果改变，内部类不知情的场景，所以要加final，保证引用不可改变</li></ol></blockquote><blockquote><p>扩展：在java8中，可以不使用final关键字，但是如果我们改变局部变量的引用，编译会发生错误，从而保证了局部变量的引用不变。</p></blockquote><h3 id="6-为什么内部类会持有外部类的引用？持有的引用是this？还是其它？"><a href="#6-为什么内部类会持有外部类的引用？持有的引用是this？还是其它？" class="headerlink" title="6. 为什么内部类会持有外部类的引用？持有的引用是this？还是其它？"></a>6. 为什么内部类会持有外部类的引用？持有的引用是this？还是其它？</h3><blockquote><p>内部类虽然和外部类写在同一个文件中， 但是编译完成后， 还是生成各自的class文件，内部类通过this访问外部类的成员。</p><ol><li>编译器自动为内部类添加一个成员变量， 这个成员变量的类型和外部类的类型相同， 这个成员变量就是指向外部类对象</li><li>编译器自动为内部类的构造方法添加一个参数， 参数的类型是外部类的类型， 在构造方法内部使用这个参数为内部类中添加的成员变量赋值；</li><li>在调用内部类的构造函数初始化内部类对象时，会默认传入外部类的引用。</li></ol></blockquote><h2 id="错误和异常"><a href="#错误和异常" class="headerlink" title="错误和异常"></a>错误和异常</h2><h3 id="1-java中的异常"><a href="#1-java中的异常" class="headerlink" title="1. java中的异常"></a>1. java中的异常</h3><blockquote><ol><li>基类是Throwable，Error和Exception继承自Throwable</li><li>Error通常是系统抛出来的，也可以catch到，但一般不可恢复，开发是也不做处理</li><li>Exception分为受检查异常和不受检查异常，受检查异常会在编译时强制要求我们try/catch</li></ol></blockquote><h3 id="2-throw-和-throws"><a href="#2-throw-和-throws" class="headerlink" title="2. throw 和 throws"></a>2. throw 和 throws</h3><blockquote><ol><li>throw:抛出异常</li><li>throws：在方法声明处使用，表示此方法可能抛出的异常，调用此方法处需要处理这些异常。</li></ol></blockquote><h3 id="3-Error和Exception有什么区别？"><a href="#3-Error和Exception有什么区别？" class="headerlink" title="3. Error和Exception有什么区别？"></a>3. Error和Exception有什么区别？</h3><blockquote><ol><li>Error是系统抛出的，不能在运行时捕获，比如内存溢出</li><li>Exception 是需要我们捕捉并处理的异常，如类型转换错误等，我们可以通过捕捉异常，使程序发生异常时仍可正常运行</li></ol></blockquote><h3 id="4-运行时异常与受检异常有何异同？"><a href="#4-运行时异常与受检异常有何异同？" class="headerlink" title="4. 运行时异常与受检异常有何异同？"></a>4. 运行时异常与受检异常有何异同？</h3><blockquote><ol><li>checked exception:这种异常，JAVA编译器强制要求我们必需对出现的这些异常进行try/catch或者继续上抛</li><li>runtime exception:出现运行时异常后，系统会把异常一直往上层抛，一直遇到处理代码。如果没有处理块，到最上层，如果是多线程就由Thread.run()抛出，如果是单线程就被main()抛出。抛出之后，如果是线程，这个线程也就退出了。如果是主程序抛出的异常，那么这整个程序也就退出了</li></ol></blockquote><h3 id="5-列出一些你常见的运行时异常"><a href="#5-列出一些你常见的运行时异常" class="headerlink" title="5.  列出一些你常见的运行时异常"></a>5.  列出一些你常见的运行时异常</h3><blockquote><p>NullPointerException （空指针异常） ClassCastException （类转换异常） IndexOutOfBoundsException （下标越界异常） IllegalArgumentException （非法参数异常）</p></blockquote><h3 id="6-Exception继承相关考题"><a href="#6-Exception继承相关考题" class="headerlink" title="6. Exception继承相关考题"></a>6. Exception继承相关考题</h3><pre><code>题目1:类ExampleA继承Exception，类ExampleB继承ExampleA。有如下代码片断,请问执行此段代码的输出是什么？try {throw new ExampleB(&quot;b&quot;)} catch（ExampleA e）{System.out.println(&quot;ExampleA&quot;);} catch（Exception e）{System.out.println(&quot;Exception&quot;);}解析：ExampleA。（根据里氏代换原则[能使用父类型的地方一定能使用子类型]，抓取ExampleA类型异常的catch块能够抓住try块中抛出的ExampleB类型的异常）题目2:class Annoyance extends Exception {}class Sneeze extends Annoyance {}class Human {public static void main(String[] args)throws Exception {try {try {throw new Sneeze();}catch ( Annoyance a ) {System.out.println(&quot;Caught Annoyance&quot;);throw a;}}catch ( Sneeze s ) {System.out.println(&quot;Caught Sneeze&quot;);return ;}finally {System.out.println(&quot;Hello World!&quot;);}}}解析：输出Caught AnnoyanceCaught SneezeHello World!</code></pre><h2 id="关键字和运算符"><a href="#关键字和运算符" class="headerlink" title="关键字和运算符"></a>关键字和运算符</h2><h3 id="1-amp-和-amp-amp-的区别；-和-的区别？"><a href="#1-amp-和-amp-amp-的区别；-和-的区别？" class="headerlink" title="1. &amp;和&amp;&amp;的区别；|和||的区别？"></a>1. &amp;和&amp;&amp;的区别；|和||的区别？</h3><blockquote><ol><li>&amp;有两种用法：(1)按位与；(2)逻辑与，我们这里说的是逻辑与。</li><li>与运算要求左右两端的布尔值都是true整个表达式的值才是true</li><li>&amp;&amp;运算符是短路逻辑与运算，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算</li><li>&amp;左右两边的表达式都会计算，我们常用&amp;&amp;，比如if(username != null &amp;&amp;!username.equals(“hahaha”)){}</li></ol></blockquote><h3 id="2-transient关键字"><a href="#2-transient关键字" class="headerlink" title="2, transient关键字"></a>2, transient关键字</h3><blockquote><p>如果用transient声明一个实例变量，当对象存储时，它的值不需要维持。换句话来说就是，用transient关键字标记的成员变量不参与序列化过程</p></blockquote><h3 id="3-修饰符的区别"><a href="#3-修饰符的区别" class="headerlink" title="3. 修饰符的区别"></a>3. 修饰符的区别</h3><p>修饰符一共有四个：private、protected、public和default（也有人管默认叫friendly）</p><blockquote><ol><li>private：私有的，除自己外任何类不能使用</li><li>protected：同包可以使用，其他包子类可以使用</li><li>public：任何类可以使用</li><li>default：同包可以使用，其他包不能使用</li></ol></blockquote><table><thead><tr><th>修饰符</th><th align="center">当前类</th><th align="center">同 包</th><th align="center">子 类</th><th align="right">其他包</th></tr></thead><tbody><tr><td>public</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="right">√</td></tr><tr><td>protected</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="right">×</td></tr><tr><td>default</td><td align="center">√</td><td align="center">√</td><td align="center">×</td><td align="right">×</td></tr><tr><td>private</td><td align="center">√</td><td align="center">×</td><td align="center">×</td><td align="right">×</td></tr></tbody></table><h3 id="4-Java有没有goto？"><a href="#4-Java有没有goto？" class="headerlink" title="4. Java有没有goto？"></a>4. Java有没有goto？</h3><blockquote><p>goto 和 const 是Java中的保留字，在目前版本的Java中没有使用。</p></blockquote><h3 id="5-在Java中，如何跳出当前的多重嵌套循环"><a href="#5-在Java中，如何跳出当前的多重嵌套循环" class="headerlink" title="5. 在Java中，如何跳出当前的多重嵌套循环"></a>5. 在Java中，如何跳出当前的多重嵌套循环</h3><blockquote><p>在最外层循环前加一个标记如A，然后用break A;可以跳出多重循环 (应该避免使用带标签的break和continue，因为它不会让你的程序变得更优雅)。</p></blockquote><h3 id="6-switch-是否能作用在byte-上，是否能作用在long-上，是否能作用在String上？"><a href="#6-switch-是否能作用在byte-上，是否能作用在long-上，是否能作用在String上？" class="headerlink" title="6. switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？"></a>6. switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？</h3><blockquote><ol><li>在Java 5以前，switch(expr)中，expr只能是byte、short、char、int</li><li>Java 5开始，Java中引入了枚举类型，expr也可以是enum类型</li><li>从Java 7开始，expr还可以是字符串（String）</li><li>long类型不支持</li></ol></blockquote><h3 id="7-static"><a href="#7-static" class="headerlink" title="7. static"></a>7. static</h3><blockquote><ol><li>可以修饰内部类（静态内部类）</li><li>可以修饰成员变量，该变量属于类，被所有实例共享</li><li>可以修饰方法，该方法属于类，被所有实例共享</li><li>可以修饰代码块（静态代码块），该代码块在第一次被加载时被调用</li></ol></blockquote><h3 id="8-Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？"><a href="#8-Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？" class="headerlink" title="8. Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？"></a>8. Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？</h3><blockquote><ol><li>Java通过面向对象的方法进行异常处理，把各种不同的异常进行分类在Java中，每个异常都是一个对象，它是Throwable类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。</li><li>Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果系统会抛出（throw）一个异常对象，可以通过它的类型来捕获（catch）它，或通过总是执行代码块（finally）来处理；try用来指定一块预防所有异常的程序；catch子句紧跟在try块后面，用来指定你想要捕获的异常的类型；throw语句用来明确地抛出一个异常；throws用来声明一个方法可能抛出的各种异常（当然声明异常时允许无病呻吟）；finally为确保一段代码不管发生什么异常状况都要被执行；t</li><li>try语句可以嵌套，每当遇到一个try语句，异常的结构就会被放入异常栈中，直到所有的try语句都完成。如果下一级的try语句没有对某种异常进行处理，异常栈就会执行出栈操作，直到遇到有处理这种异常的try语句或者最终将异常抛给JVM。</li></ol></blockquote><h3 id="9-阐述final、finally、finalize的区别。"><a href="#9-阐述final、finally、finalize的区别。" class="headerlink" title="9. 阐述final、finally、finalize的区别。"></a>9. 阐述final、finally、finalize的区别。</h3><blockquote><p>这是三个不同的概念，只是因为长得较像而被出成了一道题</p></blockquote><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>final是一个修饰符，用来修饰类，变量，方法</p><blockquote><ol><li>final修饰的类不能被继承</li><li>final修饰的方法不能被重写</li><li>final修饰的成员变量是不可变的，如果成员变量是基本数据类型，初始化之后成员变量的值不能被改变，如果成员变量是引用类型，那么它只能指向初始化时指向的那个对象，不能再指向别的对象，但是对象当中的内容是允许改变的</li></ol></blockquote><h4 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h4><blockquote><p>finally与try，catch一起搭配使用，不论是否catch到异常，finally中的内容都会执行</p></blockquote><h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h4><blockquote><p>finalize是Object类中的方法，垃圾回收器在垃圾回收时会调用该方法，我们可以在子类中重写该方法来做一些清理工作</p></blockquote><h3 id="10-finally-语句一定会执行吗"><a href="#10-finally-语句一定会执行吗" class="headerlink" title="10. finally 语句一定会执行吗"></a>10. finally 语句一定会执行吗</h3><p>在极特殊的情况下可能不执行</p><blockquote><ol><li>调用了System.exit()方法</li><li>JVM崩溃了</li></ol></blockquote><h2 id="基本类型和常用类"><a href="#基本类型和常用类" class="headerlink" title="基本类型和常用类"></a>基本类型和常用类</h2><h3 id="0-int和Integer有什么区别？"><a href="#0-int和Integer有什么区别？" class="headerlink" title="0. int和Integer有什么区别？"></a>0. int和Integer有什么区别？</h3><blockquote><ol><li>int是基本类型，Integer是int的包装类型</li><li>包装类型可以有一些自己的方法，引入包装类型可以使java更好的面向对象</li><li>每个基本类型都有其包装类：</li></ol><ul><li>原始类型: boolean，char，byte，short，int，long，float，double</li><li>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</li></ul></blockquote><pre><code>扩展1：java5中引入了自动拆装箱功能，例如在比较时可以自动拆装箱class AutoUnboxingTest {    public static void main(String[] args) {        Integer a = new Integer(3);        Integer b = 3;                  // 将3自动装箱成Integer类型        int c = 3;        System.out.println(a == b);     // false 两个引用没有引用同一对象        System.out.println(a == c);     // true a自动拆箱成int类型再和c比较    }}复制代码扩展2：一道和装箱有关的面试题public class Test03 {    public static void main(String[] args) {        Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150;        System.out.println(f1 == f2); //true        System.out.println(f3 == f4); //false    }}分析：自动装箱时，使用的时Integer的valueof方法，当int在-128到127之间时，并不会new一个新的对象，而是直接使用常量池中的Integer具体分析： public static Integer valueOf(int i) {        if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)            return IntegerCache.cache[i + (-IntegerCache.low)];        return new Integer(i);    }IntegerCache是Integer的内部类，其代码如下所示：/**     * Cache to support the object identity semantics of autoboxing for values between     * -128 and 127 (inclusive) as required by JLS.     *     * The cache is initialized on first usage.  The size of the cache     * may be controlled by the {@code -XX:AutoBoxCacheMax=&lt;size&gt;} option.     * During VM initialization, java.lang.Integer.IntegerCache.high property     * may be set and saved in the private system properties in the     * sun.misc.VM class.     */    private static class IntegerCache {        static final int low = -128;        static final int high;        static final Integer cache[];        static {            // high value may be configured by property            int h = 127;            String integerCacheHighPropValue =                sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);            if (integerCacheHighPropValue != null) {                try {                    int i = parseInt(integerCacheHighPropValue);                    i = Math.max(i, 127);                    // Maximum array size is Integer.MAX_VALUE                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);                } catch( NumberFormatException nfe) {                    // If the property cannot be parsed into an int, ignore it.                }            }            high = h;            cache = new Integer[(high - low) + 1];            int j = low;            for(int k = 0; k &lt; cache.length; k++)                cache[k] = new Integer(j++);            // range [-128, 127] must be interned (JLS7 5.1.7)            assert IntegerCache.high &gt;= 127;        }        private IntegerCache() {}    }    简单的说，如果整型字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象，    所以上面的面试题中f1==f2的结果是true，而f3==f4的结果是false。复制代码</code></pre><h3 id="1-float-f-3-4-是否正确？"><a href="#1-float-f-3-4-是否正确？" class="headerlink" title="1. float f=3.4;是否正确？"></a>1. float f=3.4;是否正确？</h3><blockquote><p>答:不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F;。</p></blockquote><h3 id="2-short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗？"><a href="#2-short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗？" class="headerlink" title="2. short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？"></a>2. short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？</h3><blockquote><ol><li>对于short s1 = 1; s1 = s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。</li><li>short s1 = 1; s1 += 1;可以正确编译，因为s1+= 1;相当于s1 = (short)(s1 + 1);其中有隐含的强制类型转换。</li></ol></blockquote><h3 id="3-Java中char-型变量中能不能存贮一个中文汉字，为什么"><a href="#3-Java中char-型变量中能不能存贮一个中文汉字，为什么" class="headerlink" title="3. Java中char 型变量中能不能存贮一个中文汉字，为什么?"></a>3. Java中char 型变量中能不能存贮一个中文汉字，为什么?</h3><blockquote><p>Java中 char型变量用来存储Unicode编码的字符，unicode编码字符集中包含了汉字，所以char类型可以储存汉字 char类型占两个字节</p></blockquote><h3 id="4-数组有没有length-方法？String有没有length-方法？"><a href="#4-数组有没有length-方法？String有没有length-方法？" class="headerlink" title="4. 数组有没有length()方法？String有没有length()方法？"></a>4. 数组有没有length()方法？String有没有length()方法？</h3><blockquote><p>数组有length属性，String有length()方法</p></blockquote><h3 id="5-String是基本数据类型嘛"><a href="#5-String是基本数据类型嘛" class="headerlink" title="5. String是基本数据类型嘛"></a>5. String是基本数据类型嘛</h3><blockquote><ol><li>不是。</li><li>java中8个基本类型为：byte、short、char、int、float、long、double、boolean。</li><li>java中除基本类型外，都是引用类型（枚举是java5以后引入的特殊引用类型）</li><li>String类型比较特殊，不可变。但它不是基本类型</li></ol></blockquote><h3 id="6-是否可以继承String类"><a href="#6-是否可以继承String类" class="headerlink" title="6. 是否可以继承String类"></a>6. 是否可以继承String类</h3><blockquote><p>String 类是final的，不能被继承</p></blockquote><h3 id="7-String和StringBuilder、StringBuffer的区别"><a href="#7-String和StringBuilder、StringBuffer的区别" class="headerlink" title="7. String和StringBuilder、StringBuffer的区别"></a>7. String和StringBuilder、StringBuffer的区别</h3><blockquote><p>String 是只读字符串，StringBuilder和StringBuffer可以改变，StringBuilder效率高，线程不安全，StringBuffer线程安全。 在拼接String时，使用+编译器会帮我们进行优化，使用StringBuilder进行拼接，这时+和StringBuilder没有多大区别。但当循环中使用+时，我们应该显示的使用StringBuilder，以防止多次调用new StringBuilder，造成不必要的性能浪费。</p></blockquote><pre><code>循环中使用+举例：String str = &quot;hello,world!&quot;;        String result = &quot;&quot;;        for (int i = 0; i &lt; loopCount; i++) {            result += str;        }这个时候编译器会优化成String str = &quot;hello,world!&quot;;        String result = &quot;&quot;;        for (int i = 0; i &lt; loopCount; i++) {            result = new StringBuilder(result).append(str).toString();        }多次new StringBuilder造成了性能浪费。复制代码扩展例题class StringEqualTest {    public static void main(String[] args) {        String s1 = &quot;Programming&quot;;        String s2 = new String(&quot;Programming&quot;);        String s3 = &quot;Program&quot;;        String s4 = &quot;ming&quot;;        String s5 = &quot;Program&quot; + &quot;ming&quot;;        String s6 = s3 + s4;        System.out.println(s1 == s2); // false        System.out.println(s1 == s5); //true        System.out.println(s1 == s6); //false        System.out.println(s1 == s6.intern()); //true        System.out.println(s2 == s2.intern()); //false    }}解析：1. String是引用类型，这里 == 比较的是引用是否相同，即是否指向相同的地址     2. 在new String对象时，会产生一个新的对象，并不会使用常量池中的字符串     3. intern会在常量池中寻找该字符串（如果没有责新建），并返回他的地址复制代码</code></pre><h3 id="8-String-s-new-String-“xyz”-创建了几个字符串对象？"><a href="#8-String-s-new-String-“xyz”-创建了几个字符串对象？" class="headerlink" title="8. String s = new String(“xyz”);创建了几个字符串对象？"></a>8. String s = new String(“xyz”);创建了几个字符串对象？</h3><blockquote><p>两个对象，一个是静态区的”xyz”;一个是用new创建在堆上的对象。</p></blockquote><h3 id="9-String-和基本数据类型之间的转换"><a href="#9-String-和基本数据类型之间的转换" class="headerlink" title="9. String 和基本数据类型之间的转换"></a>9. String 和基本数据类型之间的转换</h3><blockquote><ol><li>String 转基本数据类型：调用基本数据类型对应包装类的parseXXX(String)或valueOf(String)方法</li><li>基本数据类型转String：基本数据类型+“”；String.valueof(12)</li></ol></blockquote><h3 id="10-实现字符串的反转"><a href="#10-实现字符串的反转" class="headerlink" title="10. 实现字符串的反转"></a>10. 实现字符串的反转</h3><blockquote><ol><li>方法有很多，可以用StringBuffer/StringBuilder的reverse方法，这里reverse是通过位移实现的</li><li>再举例一种递归方法：</li></ol></blockquote><pre><code>public String reverse(String originString){if(originString == null || originString.length &lt;= 1)return originString;return reverse(originString.subString(1)) + originString.charAt(0);}复制代码</code></pre><h3 id="11-String-为什么要设计成不可变的"><a href="#11-String-为什么要设计成不可变的" class="headerlink" title="11. String 为什么要设计成不可变的"></a>11. <a href="https://juejin.im/post/5aa1ee0c51882555677e2109" target="_blank" rel="noopener">String 为什么要设计成不可变的</a></h3><h4 id="1-安全性"><a href="#1-安全性" class="headerlink" title="1. 安全性"></a>1. 安全性</h4><blockquote><ol><li>线程安全，不可变天生线程安全</li><li>String常被用作HashMap的key，如果可变会引有安全问题，如两个key相同</li><li>String常被用作数据库或接口的参数，可变的话也会有安全问题</li></ol></blockquote><h4 id="2-效率"><a href="#2-效率" class="headerlink" title="2. 效率"></a>2. 效率</h4><blockquote><ol><li>通过字符串池可以节省很多空间</li><li>每个String对应一个hashcode，再次使用的话不用重新计算</li></ol></blockquote><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="0-讲一下Java的编码方式"><a href="#0-讲一下Java的编码方式" class="headerlink" title="0. 讲一下Java的编码方式"></a>0. 讲一下Java的编码方式</h3><h4 id="为什么需要编码"><a href="#为什么需要编码" class="headerlink" title="为什么需要编码"></a>为什么需要编码</h4><blockquote><p>计算机存储信息的最小单元是一个字节即8bit，所以能表示的范围是0~255，这个范围无法保存所有的字符，所以需要一个新的数据结构char来表示这些字符，从char到byte需要编码。</p></blockquote><h4 id="常见的编码方式有以下几种："><a href="#常见的编码方式有以下几种：" class="headerlink" title="常见的编码方式有以下几种："></a>常见的编码方式有以下几种：</h4><blockquote><ol><li>ASCII：总共有 128 个，用一个字节的低 7 位表示，031 是控制字符如换行回车删除等；32126 是打印字符，可以通过键盘输入并且能够显示出来。</li><li>GBK：码范围是 8140~FEFE（去掉 XX7F）总共有 23940 个码位，它能表示 21003 个汉字，它的编码是和 GB2312 兼容的，也就是说用 GB2312 编码的汉字可以用 GBK 来解码，并且不会有乱码。</li><li>UTF-16：UTF-16 具体定义了 Unicode 字符在计算机中存取方法。UTF-16 用两个字节来表示 Unicode 转化格式，这个是定长的表示方法，不论什么字符都可以用两个字节表示，两个字节是 16 个 bit，所以叫 UTF-16。UTF-16 表示字符非常方便，每两个字节表示一个字符，这个在字符串操作时就大大简化了操作，这也是 Java 以 UTF-16 作为内存的字符存储格式的一个很重要的原因。</li><li>UTF-8：统一采用两个字节表示一个字符，虽然在表示上非常简单方便，但是也有其缺点，有很大一部分字符用一个字节就可以表示的现在要两个字节表示，存储空间放大了一倍，在现在的网络带宽还非常有限的今天，这样会增大网络传输的流量，而且也没必要。而 UTF-8 采用了一种变长技术，每个编码区域有不同的字码长度。不同类型的字符可以是由 1~6 个字节组成。</li></ol></blockquote><h4 id="Java中需要编码的地方一般都在字符到字节的转换上，这个一般包括磁盘IO和网络IO。"><a href="#Java中需要编码的地方一般都在字符到字节的转换上，这个一般包括磁盘IO和网络IO。" class="headerlink" title="Java中需要编码的地方一般都在字符到字节的转换上，这个一般包括磁盘IO和网络IO。"></a>Java中需要编码的地方一般都在字符到字节的转换上，这个一般包括磁盘IO和网络IO。</h4><blockquote><p>Reader 类是 Java 的 I/O 中读字符的父类，而 InputStream 类是读字节的父类，InputStreamReader 类就是关联字节到字符的桥梁，它负责在 I/O 过程中处理读取字节到字符的转换，而具体字节到字符的解码实现它由 StreamDecoder 去实现，在 StreamDecoder 解码过程中必须由用户指定 Charset 编码格式。</p></blockquote><h3 id="1-Unicode与UTF-8的关系"><a href="#1-Unicode与UTF-8的关系" class="headerlink" title="1. Unicode与UTF-8的关系"></a>1. <a href="https://www.zhihu.com/question/23374078" target="_blank" rel="noopener">Unicode与UTF-8的关系</a></h3><blockquote><p>Unicode是字符集 UTF-8是一种编码方式，达到了对数据流压缩的目的</p></blockquote><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="0-List和Set的区别"><a href="#0-List和Set的区别" class="headerlink" title="0. List和Set的区别"></a>0. List和Set的区别</h3><blockquote><ol><li>它们都是接口，都实现了Collection接口</li><li>List元素可以重复，元素顺序与插入顺序相同，其子类有LinkedList和ArrayList</li><li>Set元素不能重复，元素顺序与插入顺序不同，子类有HashSet（通过HashMap实现），LinkedHashSet，TreeSet（红黑树实现，排序的）</li></ol></blockquote><h3 id="1-List、Map、Set三个接口存取元素时，各有什么特点？"><a href="#1-List、Map、Set三个接口存取元素时，各有什么特点？" class="headerlink" title="1. List、Map、Set三个接口存取元素时，各有什么特点？"></a>1. List、Map、Set三个接口存取元素时，各有什么特点？</h3><blockquote><ol><li>List继承了Collection，储存值,可以有重复值</li><li>Set继承了Collection，储存值,不能有重复值</li><li>Map储存健值对，可以一对一或一对多</li></ol></blockquote><h3 id="2-List、Set、Map是否继承自Collection接口"><a href="#2-List、Set、Map是否继承自Collection接口" class="headerlink" title="2. List、Set、Map是否继承自Collection接口"></a>2. List、Set、Map是否继承自Collection接口</h3><blockquote><p>List、Set 是，Map 不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形</p></blockquote><h3 id="3-HashMap实现原理"><a href="#3-HashMap实现原理" class="headerlink" title="3. HashMap实现原理"></a>3. <a href="http://blog.csdn.net/carson_ho/article/details/79373026" target="_blank" rel="noopener">HashMap实现原理</a></h3><blockquote><ol><li>在1.7中，HashMap采用数组+单链表的结构；1.8中，采用数组+单链表或红黑树的结构（当链表size &gt; 8时，转换成红黑树）</li><li>HaspMap中有两个关键的构造函数，一个是初始容量，另一个是负载因子。</li><li>初始容量即数组的初始大小，当map中元素个数 &gt; 初始容量*负载因子时，HashMap调用resize（）方法扩容</li><li>在存入数据时，对key的hashCode再次进行hash（），目的是让hash值分布均匀</li><li>对hash() 返回的值与容量进行与运算，确定在数组中的位置</li><li>key可以为null，null的hash值是0</li></ol></blockquote><h3 id="4-HashMap是怎么解决hash冲突的"><a href="#4-HashMap是怎么解决hash冲突的" class="headerlink" title="4. HashMap是怎么解决hash冲突的"></a>4. HashMap是怎么解决hash冲突的</h3><blockquote><ol><li>对hashCode在调用hash（）方法进行计算</li><li>当超过阈值时进行扩容</li><li>当发生冲突时使用链表或者红黑树解决冲突</li></ol></blockquote><h3 id="5-为什么不直接采用经过hashCode（）处理的哈希码作为存储数组table的下标位置"><a href="#5-为什么不直接采用经过hashCode（）处理的哈希码作为存储数组table的下标位置" class="headerlink" title="5. 为什么不直接采用经过hashCode（）处理的哈希码作为存储数组table的下标位置"></a>5. 为什么不直接采用经过hashCode（）处理的哈希码作为存储数组table的下标位置</h3><blockquote><ol><li>hashCode可能很大，数组初始容量可能很小，不匹配，所以需要： hash码 &amp; （数组长度-1）作为数组下标</li><li>hashCode可能分布的不均匀</li></ol></blockquote><h3 id="6-为什么在计算数组下标前，需对哈希码进行二次处理：扰动处理？"><a href="#6-为什么在计算数组下标前，需对哈希码进行二次处理：扰动处理？" class="headerlink" title="6. 为什么在计算数组下标前，需对哈希码进行二次处理：扰动处理？"></a>6. 为什么在计算数组下标前，需对哈希码进行二次处理：扰动处理？</h3><blockquote><p>加大哈希码低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性 &amp; 均匀性，最终减少Hash冲突</p></blockquote><h3 id="7-为什么说HashMap不保证有序，储存位置会随时间变化"><a href="#7-为什么说HashMap不保证有序，储存位置会随时间变化" class="headerlink" title="7. 为什么说HashMap不保证有序，储存位置会随时间变化"></a>7. 为什么说HashMap不保证有序，储存位置会随时间变化</h3><blockquote><ol><li>通过hash值确定位置，与用户插入顺序不同</li><li>在达到阈值后，HashMap会调用resize方法扩容，扩容后位置发生变化</li></ol></blockquote><h3 id="8-HashMap的时间复杂度"><a href="#8-HashMap的时间复杂度" class="headerlink" title="8. HashMap的时间复杂度"></a>8. HashMap的时间复杂度</h3><blockquote><p>HashMap通过数组和链表实现，数组查找的时间复杂度是O(1)，链表的时间复杂度是O（n），所以要让HashMap尽可能的块，就需要链表的长度尽可能的小，当链表长度是1是，HashMap的时间复杂度就变成了O(1)；根据HashMap的实现原理，要想让链表长度尽可能的短，需要hash算法尽量减少冲突。</p></blockquote><h3 id="9-HashMap-中的-key若-Object类型，-则需实现哪些方法"><a href="#9-HashMap-中的-key若-Object类型，-则需实现哪些方法" class="headerlink" title="9. HashMap 中的 key若 Object类型， 则需实现哪些方法"></a>9. HashMap 中的 key若 Object类型， 则需实现哪些方法</h3><blockquote><p>hashCode和equals</p></blockquote><h3 id="10-为什么-HashMap-中-String、Integer-这样的包装类适合作为-key-键"><a href="#10-为什么-HashMap-中-String、Integer-这样的包装类适合作为-key-键" class="headerlink" title="10. 为什么 HashMap 中 String、Integer 这样的包装类适合作为 key 键"></a>10. 为什么 HashMap 中 String、Integer 这样的包装类适合作为 key 键</h3><blockquote><ol><li>它们是final的，不可变，保证了安全性</li><li>均已经实现了hashCode和equals方法，计算准确</li></ol></blockquote><h3 id="11-HashMap线程安全吗"><a href="#11-HashMap线程安全吗" class="headerlink" title="11. HashMap线程安全吗"></a>11. HashMap线程安全吗</h3><blockquote><ol><li>HashMap线程不安全</li><li>HashMap没有同步锁，举例：比如A、B两个线程同时触发扩容，HashMap容量增加2倍，并将原数据重新分配到新的位置，这个时候可能出现原链表转移到新链表时生成了环形链表，出现死循环。</li></ol></blockquote><h3 id="12-HashMap线程安全的解决方案"><a href="#12-HashMap线程安全的解决方案" class="headerlink" title="12. HashMap线程安全的解决方案"></a>12. HashMap线程安全的解决方案</h3><blockquote><ol><li>使用Collections.synchronizedMap()方法，该方法的实现方式是使用synchronized关键字</li><li>使用ConcurrentHashMap，性能比Collections.synchronizedMap()更好</li></ol></blockquote><h3 id="13-HashMap-如何删除元素"><a href="#13-HashMap-如何删除元素" class="headerlink" title="13. HashMap 如何删除元素"></a>13. HashMap 如何删除元素</h3><blockquote><ol><li>计算key的Hash值，找到数组中的位置，得到链表的头指针</li><li>遍历链表，通过equals比较key，确定是不是要找的元素</li><li>找到后调整链表，将该元素从链表中删除</li></ol></blockquote><pre><code>//源码 java8 @Override public V remove(Object key) {        if (key == null) {            return removeNullKey();        }        int hash = Collections.secondaryHash(key);        HashMapEntry&lt;K, V&gt;[] tab = table;        int index = hash &amp; (tab.length - 1);        for (HashMapEntry&lt;K, V&gt; e = tab[index], prev = null;                e != null; prev = e, e = e.next) {            if (e.hash == hash &amp;&amp; key.equals(e.key)) {                if (prev == null) {                    tab[index] = e.next;                } else {                    prev.next = e.next;                }                modCount++;                size--;                postRemove(e);                return e.value;            }        }        return null;    }复制代码</code></pre><h3 id="14-HashMap的扩容过程"><a href="#14-HashMap的扩容过程" class="headerlink" title="14. HashMap的扩容过程"></a>14. HashMap的扩容过程</h3><blockquote><ol><li>在初次加载时，会调用resize（）进行初始化</li><li>当put（）时，会查看当前元素个数是否大于阈值（阈值=数组长度*负载因子），当大于时，调用resize方法扩容</li><li>新建一个数组，扩容后的容量是原来的两倍</li><li>将原来的数据重新计算位置，拷贝到新的table上</li></ol></blockquote><h3 id="15-java8-中HashMap的优化"><a href="#15-java8-中HashMap的优化" class="headerlink" title="15. java8 中HashMap的优化"></a>15. java8 中HashMap的优化</h3><blockquote><p>最大变化是当链表超过一定的长度后，将链表转换成红黑树存储，在存储很多数据时，效率提升了。链表的查找复杂度是O（n），红黑树是O（log（n））</p></blockquote><h3 id="16-HashMap和HashTable的区别"><a href="#16-HashMap和HashTable的区别" class="headerlink" title="16. HashMap和HashTable的区别"></a>16. HashMap和HashTable的区别</h3><blockquote><ol><li>HashTable是线程安全的，而HashMap不是</li><li>HashMap中允许存在null键和null值，而HashTable中不允许</li><li>HashTable已经弃用，我们可以用ConcurrentHashMap等替代</li></ol></blockquote><h3 id="17-ConcurrentHashMap实现原理"><a href="#17-ConcurrentHashMap实现原理" class="headerlink" title="17. ConcurrentHashMap实现原理"></a>17. ConcurrentHashMap实现原理</h3><blockquote><ol><li>ConcurrentHashMap是线程安全的HashMap，效率比直接加cynchronized要好</li><li>1.7中通过分段锁实现，读不枷锁（通过volatile保证可见性），写时给对应的分段加锁。（1.8实现原理变了）</li></ol></blockquote><h3 id="18-ConcurrentHashMap的并发度是什么"><a href="#18-ConcurrentHashMap的并发度是什么" class="headerlink" title="18. ConcurrentHashMap的并发度是什么"></a>18. ConcurrentHashMap的并发度是什么</h3><blockquote><ol><li>ConcurrentHashMap通过分段锁来实现，并发度即为段数</li><li>段数是ConcurrentHashMap类构造函数的一个可选参数，默认值为16</li></ol></blockquote><h3 id="19-LinkedHashMap原理"><a href="#19-LinkedHashMap原理" class="headerlink" title="19. LinkedHashMap原理"></a>19. LinkedHashMap原理</h3><blockquote><ol><li>LinkedHashMap通过继承HashMap实现，既保留了HashMap快速查找能力，又保存了存入顺序</li><li>LinkedHashMap重写了HashMap的Entry，通过LinkedEntry保存了存入顺序，可以理解为通过双向链表和HashMap共同实现</li></ol></blockquote><h3 id="20-HashMap和Arraylist都是线程不安全的，怎么让他们线程安全"><a href="#20-HashMap和Arraylist都是线程不安全的，怎么让他们线程安全" class="headerlink" title="20. HashMap和Arraylist都是线程不安全的，怎么让他们线程安全"></a>20. HashMap和Arraylist都是线程不安全的，怎么让他们线程安全</h3><blockquote><ol><li>借助Collections工具类synchronizedMap和synchronizedList将其转为线程安全的</li><li>使用安全的类替代，如HashTable（不建议使用）或者ConcurrentHashMap替代Hashmap，用CopyOnWriteArrayList替代ArrayList</li></ol></blockquote><h3 id="21-HashSet-是如何保证不重复的"><a href="#21-HashSet-是如何保证不重复的" class="headerlink" title="21. HashSet 是如何保证不重复的"></a>21. HashSet 是如何保证不重复的</h3><blockquote><ol><li>HashSet 是通过HashMap来实现的，内部持有一个HashMap实例</li><li>HashSet存入的值即为HashMap的key，hashMap的value是HashSet中new 的一个Object实例，所有的value都相同</li></ol></blockquote><h3 id="22-TreeSet-两种排序方式"><a href="#22-TreeSet-两种排序方式" class="headerlink" title="22. TreeSet 两种排序方式"></a>22. <a href="https://www.cnblogs.com/alhh/p/5507909.html" target="_blank" rel="noopener">TreeSet 两种排序方式</a></h3><blockquote><ol><li>自然排序：调用无参构造函数，添加的元素必须实现Comparable接口</li><li>定制排序：使用有参构造函数，传入一个Comparator实例</li></ol></blockquote><h3 id="23-Array-和-ArrayList对比"><a href="#23-Array-和-ArrayList对比" class="headerlink" title="23. Array 和 ArrayList对比"></a>23. Array 和 ArrayList对比</h3><blockquote><ol><li>Array可以是基本类型和引用类型，ArrayList只能是引用类型</li><li>Array固定大小，ArrayList长度可以动态改变</li><li>ArrayList有很多方法可以调用，如addAll（）</li></ol></blockquote><h3 id="24-List和数组的互相转换-String转换成数组"><a href="#24-List和数组的互相转换-String转换成数组" class="headerlink" title="24. List和数组的互相转换/String转换成数组"></a>24. List和数组的互相转换/String转换成数组</h3><blockquote><ol><li>String[] a = list.toArray(new String[size]));</li><li>List list = Arrays.asList(array);</li><li>char[] char = string.toCharArray();</li></ol></blockquote><h3 id="25-数组在内存中是如何分配的"><a href="#25-数组在内存中是如何分配的" class="headerlink" title="25.  数组在内存中是如何分配的"></a>25.  数组在内存中是如何分配的</h3><blockquote><p>和引用类型一样，在栈中保存一个引用，指向堆地址</p></blockquote><h3 id="26-TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort-方法如何比较元素？"><a href="#26-TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort-方法如何比较元素？" class="headerlink" title="26. TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？"></a>26. TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？</h3><blockquote><ol><li>TreeMap和TreeSet都是通过<a href="http://www.sohu.com/a/201923614_466939" target="_blank" rel="noopener">红黑树</a>实现的，因此要求元素都是可比较的，元素必须实现Comparable接口，该接口中有compareTo（）方法。</li><li>Collections的sort方法有两种重载形式，一种只有一个参数，要求传入的待排序元素必须实现Comparable接口；第二种有两个参数，要求传入待排序容器即Comparator实例</li></ol></blockquote><h3 id="27-阐述ArrayList、Vector、LinkedList的存储性能和特性。"><a href="#27-阐述ArrayList、Vector、LinkedList的存储性能和特性。" class="headerlink" title="27. 阐述ArrayList、Vector、LinkedList的存储性能和特性。"></a>27. 阐述ArrayList、Vector、LinkedList的存储性能和特性。</h3><blockquote><ol><li>ArrayList 和Vector都是使用数组方式存储数据,数组方式节省空间，便与读取；但插入删除涉及数组移动，性能较差。</li><li>Vector中的方法由于添加了synchronized修饰，因此Vector是线程安全的容器。</li><li>LinkedList使用双向链表实现存储,占用空间大，读取慢；插入删除快</li><li>Vector已经被遗弃，不推荐使用。为了实现线程安全的list，可以使用Collections中的synchronizedList方法将其转换成线程安全的容器后再使用</li></ol></blockquote><h3 id="28-什么是Java优先级队列-Priority-Queue"><a href="#28-什么是Java优先级队列-Priority-Queue" class="headerlink" title="28. 什么是Java优先级队列(Priority Queue)"></a>28. <a href="https://blog.csdn.net/qq_35326718/article/details/72866180" target="_blank" rel="noopener">什么是Java优先级队列(Priority Queue)</a></h3><blockquote><p>PriorityQueue是一个基于优先级堆的无界队列，它的元素是按照自然顺序(natural order)排序的。在创建的时候，我们可以给它提供一个负责给元素排序的比较器。PriorityQueue不允许null值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。PriorityQueue的逻辑结构为堆（完全二叉树），物理结构为数组。最后，PriorityQueue不是线程安全的，入队和出队的时间复杂度是O(log(n))</p></blockquote><h3 id="29-List、Set、Map的遍历方式"><a href="#29-List、Set、Map的遍历方式" class="headerlink" title="29. List、Set、Map的遍历方式"></a>29. List、Set、Map的遍历方式</h3><blockquote><ol><li><a href="https://blog.csdn.net/angus_17/article/details/7521639" target="_blank" rel="noopener">List、Set</a>都继承了Collection接口，可以使用for each遍历或者Iterator</li><li><a href="https://blog.csdn.net/u010127245/article/details/50937384" target="_blank" rel="noopener">HashMap</a>可以拿到KeySet或者entrySet，然后用iterator或者 for each 方式遍历</li></ol></blockquote><h3 id="30-什么是Iterator-迭代器"><a href="#30-什么是Iterator-迭代器" class="headerlink" title="30. 什么是Iterator(迭代器)"></a>30. 什么是Iterator(迭代器)</h3><blockquote><p>迭代器是一个接口，我们可以借助这个接口实现对集合的遍历，删除 <a href="https://www.jianshu.com/p/a16ca1560551" target="_blank" rel="noopener">扩展（迭代器实现原理）</a>：Collection继承了Iterable接口，iterable接口中有iterator方法，返回一个Iterator迭代器 -&gt; Collection的实现类通过在内部实现自定义Iterator，在iterator时返回这个实例。</p></blockquote><h3 id="31-Iterator和ListIterator的区别是什么"><a href="#31-Iterator和ListIterator的区别是什么" class="headerlink" title="31. Iterator和ListIterator的区别是什么"></a>31. Iterator和ListIterator的区别是什么</h3><blockquote><ol><li>ListIterator 继承自 Iterator</li><li>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List</li><li>ListIterator比Iterator增加了更多功能，例如可以双向遍历，增加元素等</li></ol></blockquote><h3 id="32-如何权衡是使用无序的数组还是有序的数组"><a href="#32-如何权衡是使用无序的数组还是有序的数组" class="headerlink" title="32. 如何权衡是使用无序的数组还是有序的数组"></a>32. 如何权衡是使用无序的数组还是有序的数组</h3><blockquote><ol><li>查找多用有序数组，插入删除多用无序数组</li><li>解释：有序数组最大的好处在于查找的时间复杂度是O(log n)，而无序数组是O(n)。有序数组的缺点是插入操作的时间复杂度是O(n)，因为值大的元素需要往后移动来给新元素腾位置。相反，无序数组的插入时间复杂度是常量O(1)</li></ol></blockquote><h3 id="33-Arrays-sort-实现原理和-Collections-sort-实现原理"><a href="#33-Arrays-sort-实现原理和-Collections-sort-实现原理" class="headerlink" title="33. Arrays.sort 实现原理和 Collections.sort 实现原理"></a>33. Arrays.sort 实现原理和 Collections.sort 实现原理</h3><blockquote><ol><li>Collections.sort是通过Arrays.sort实现的。当list不为ArrayList时，先转成数组，再调用Arrays.sort</li><li>java 8 中Array.Sort()是通过timsort（一种优化的归并排序）来实现的</li></ol></blockquote><h3 id="34-Collection和Collections的区别"><a href="#34-Collection和Collections的区别" class="headerlink" title="34. Collection和Collections的区别"></a>34. Collection和Collections的区别</h3><blockquote><ol><li>Collection 是一个接口，Set、List都继承了该接口</li><li>Collections 是一个工具类，该工具类可以帮我们完成对容器的判空，排序，线程安全化等。</li></ol></blockquote><h3 id="35-快速失败（fail-fast）和安全失败（fail-safe）"><a href="#35-快速失败（fail-fast）和安全失败（fail-safe）" class="headerlink" title="35. 快速失败（fail-fast）和安全失败（fail-safe）"></a>35. 快速失败（fail-fast）和安全失败（fail-safe）</h3><blockquote><ol><li>快速失败：在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception</li><li>安全失败：操作是对象的副本，这个时候原对象改变并不会对当前迭代器遍历产生影响。java.util.concurrent类下边容器都是安全失败<br> 扩展：快速失败原理：容器内部有一个modCount，记录变化的次数，当进行遍历时，如果mocount值发生改变，责快速失败</li></ol></blockquote><h3 id="36-当一个集合被作为参数传递给一个函数时，如何才可以确保函数不能修改它"><a href="#36-当一个集合被作为参数传递给一个函数时，如何才可以确保函数不能修改它" class="headerlink" title="36. 当一个集合被作为参数传递给一个函数时，如何才可以确保函数不能修改它"></a>36. 当一个集合被作为参数传递给一个函数时，如何才可以确保函数不能修改它</h3><blockquote><p>在作为参数传递之前，我们可以使用Collections.unmodifiableCollection(Collection c)方法创建一个只读集合，这将确保改变集合的任何操作都会抛出UnsupportedOperationException。</p></blockquote><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><hr><h3 id="0-内存中的栈-stack-、堆-heap-和方法区-method-area-？"><a href="#0-内存中的栈-stack-、堆-heap-和方法区-method-area-？" class="headerlink" title="0. 内存中的栈(stack)、堆(heap)和方法区(method area)？"></a>0. 内存中的栈(stack)、堆(heap)和方法区(method area)？</h3><blockquote><ol><li>栈：线程独有，每个线程一个栈区。保存基本数据类型，对象的引用，函数调用的现场（栈可以分为三个部分：基本类型，执行环境上下文，操作指令区(存放操作指令)）；优点是速度快，缺点是大小和生存周期必须是确定的</li><li>堆：线程共享，jvm一共一个堆区。保存对象的实例，垃圾回收器回收的是堆区的内存</li><li>方法区（静态区）：线程共享。保存类信息、常量、静态变量、JIT编译器编译后的代码等数据，常量池是方法区的一部分。</li></ol></blockquote><h3 id="1-Jvm内存模型"><a href="#1-Jvm内存模型" class="headerlink" title="1. Jvm内存模型"></a>1. Jvm内存模型</h3><p><img src="https://user-gold-cdn.xitu.io/2018/3/28/1626d1c69abf5b0f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><blockquote><ol><li>堆：线程共享，存放对象实例，所有的对象的内存都在这里分配。垃圾回收主要就是作用于这里的。</li><li>java虚拟机栈：线程私有，生命周期与线程相同。每个方法执行的时候都会创建一个栈帧（stack frame）用于存放 局部变量表、操作栈、动态链接、方法出口</li><li>native方法栈</li><li>程序计数器：这里记录了线程执行的字节码的行号，在分支、循环、跳转、异常、线程恢复等都依赖这个计数器。</li><li>方法区：线程共享的存储了每个类对象的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。</li></ol></blockquote><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><hr><h3 id="0-java中存在内存泄漏吗"><a href="#0-java中存在内存泄漏吗" class="headerlink" title="0. java中存在内存泄漏吗"></a>0. java中存在内存泄漏吗</h3><blockquote><ol><li>java中存在内存泄漏</li><li>java中虽然有GC帮我们自动回收内存，但是只有当实例没有引用指向它时才会被回收，若我们错误的持有了引用，没有在应当释放时释放，就会造成内存泄漏，例如在长生命周期对象持有短生命周期对象。</li></ol></blockquote><pre><code>举例：import java.util.Arrays;import java.util.EmptyStackException;public class MyStack&lt;T&gt; {private T[] elements;private int size = 0;private static final int INIT_CAPACITY = 16;public MyStack() {   elements = (T[]) new Object[INIT_CAPACITY]; }public void push(T elem) {   ensureCapacity();   elements[size++] = elem; }public T pop() {if(size == 0)   throw new EmptyStackException();   return elements[--size];   }private void ensureCapacity() { if(elements.length == size) {   elements = Arrays.copyOf(elements, 2 * size + 1);  } }}分析：这里用数组实现了一个栈，但是当数据pop之后，数组里内容并没有被清空。复制代码</code></pre><h3 id="1-GC是什么？为什么要有GC？"><a href="#1-GC是什么？为什么要有GC？" class="headerlink" title="1. GC是什么？为什么要有GC？"></a>1. GC是什么？为什么要有GC？</h3><blockquote><ol><li>GC是垃圾收集器（Garbage Collection）的缩写，是面试中常考的点。了解GC的运行方式，对防止内存泄漏，提高运行效率等都有好处</li><li>垃圾收集器会自动进行内存回收，不需要程序员进行操作，System.gc() 或Runtime.getRuntime().gc() 时并不是马上进行内存回收，甚至不会进行内存回收</li><li>详细参见JVM的内存回收机制</li></ol></blockquote><h3 id="2-如何定义垃圾"><a href="#2-如何定义垃圾" class="headerlink" title="2. 如何定义垃圾"></a>2. 如何定义垃圾</h3><blockquote><ol><li>引用计数（无法解决循环引用的问题）</li><li>可达性分析</li></ol></blockquote><h3 id="3-什么变量能作为GCRoot"><a href="#3-什么变量能作为GCRoot" class="headerlink" title="3. 什么变量能作为GCRoot"></a>3. 什么变量能作为GCRoot</h3><blockquote><ol><li>虚拟机栈(栈帧中的本地变量表)中引用的对象；</li><li>方法区中的类静态属性引用的对象</li><li>方法区中的常量引用的对象</li><li>原生方法栈（Native Method Stack）中 JNI 中引用的对象。</li></ol></blockquote><h3 id="4-垃圾回收的方法"><a href="#4-垃圾回收的方法" class="headerlink" title="4. 垃圾回收的方法"></a>4. 垃圾回收的方法</h3><blockquote><ol><li>标记-清除（Mark-Sweep）法：减少停顿时间，但会造成内存碎片</li><li>标记-整理（Mark-Compact）法：可以解决内存碎片问题，但是会增加停顿时间</li><li>复制（copying）法：从一个地方拷贝到另一个地方，适合有大量回收的场景，比如新生代回收</li><li>分代收集：把内存区域分成不同代，根据代不同采取不同的策略<br> 新生代（Yong Generation）：存放新创建的对象，采用复制回收方法；年老代（old Generation）：这些对象垃圾回收的频率较低，采用的标记整理方法，这里的垃圾回收叫做 major GC；永久代（permanent Generation）：存放Java本身的一些数据，当类不再使用时，也会被回收。</li></ol></blockquote><h3 id="5-JVM垃圾回收何时触发MinorGC等操作"><a href="#5-JVM垃圾回收何时触发MinorGC等操作" class="headerlink" title="5. JVM垃圾回收何时触发MinorGC等操作"></a>5. JVM垃圾回收何时触发MinorGC等操作</h3><blockquote><ol><li>minorGc发生在年轻代，是复制回收</li><li>年轻代可以分为三个区域：Eden、from Survivor和to Survivor；当Eden满了的时候，触发minorGc</li><li>Gc过程：Eden区复制到to区；from区年龄大的被移到年老区，年龄小的复制到to区；to区变成from区；</li></ol></blockquote><h3 id="6-JVM-年轻代到年老代的晋升过程的判断条件是什么"><a href="#6-JVM-年轻代到年老代的晋升过程的判断条件是什么" class="headerlink" title="6. JVM 年轻代到年老代的晋升过程的判断条件是什么"></a>6. JVM 年轻代到年老代的晋升过程的判断条件是什么</h3><blockquote><ol><li>在年轻代gc过程中存活的次数超过阈值</li><li>或者太大了直接放入年老代</li><li>to Survivor满了，新对象直接放入老年代</li><li>还有一种情况，如果在From空间中，相同年龄所有对象的大小总和大于From和To空间总和的一半，那么年龄大于等于该年龄的对象就会被移动到老年代，而不用等到15岁(默认)</li></ol></blockquote><h3 id="7-Full-GC-触发的条件"><a href="#7-Full-GC-触发的条件" class="headerlink" title="7. Full GC 触发的条件"></a>7. Full GC 触发的条件</h3><blockquote><ol><li>调用System.gc时，系统建议执行Full GC，但是不必然执行</li><li>老年代或者永久代空间不足</li><li>其他（=-=）</li></ol></blockquote><h3 id="8-OOM错误，stackoverflow错误，permgen-space错误"><a href="#8-OOM错误，stackoverflow错误，permgen-space错误" class="headerlink" title="8. OOM错误，stackoverflow错误，permgen space错误"></a>8. OOM错误，stackoverflow错误，permgen space错误</h3><blockquote><ol><li>OOM 是堆内存溢出</li><li>stackoverflow是栈内存溢出</li><li>permgen space说的是溢出的区域在永久代</li></ol></blockquote><h3 id="9-内存溢出的种类"><a href="#9-内存溢出的种类" class="headerlink" title="9. 内存溢出的种类"></a>9. <a href="http://www.importnew.com/19946.html" target="_blank" rel="noopener">内存溢出的种类</a></h3><blockquote><ol><li>stackoverflow：；当线程调用一个方法是，jvm压入一个新的栈帧到这个线程的栈中，只要这个方法还没返回，这个栈帧就存在。如果方法的嵌套调用层次太多(如递归调用),随着java栈中的帧的增多，最终导致这个线程的栈中的所有栈帧的大小的总和大于-Xss设置的值，而产生生StackOverflowError溢出异常</li><li>outofmemory:<ol><li>java程序启动一个新线程时，没有足够的空间为改线程分配java栈，一个线程java栈的大小由-Xss设置决定；JVM则抛出OutOfMemoryError异常;</li><li>java堆用于存放对象的实例，当需要为对象的实例分配内存时，而堆的占用已经达到了设置的最大值(通过-Xmx)设置最大值，则抛出OutOfMemoryError异常;</li><li>方法区用于存放java类的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。在类加载器加载class文件到内存中的时候，JVM会提取其中的类信息，并将这些类信息放到方法区中。当需要存储这些类信息，而方法区的内存占用又已经达到最大值（通过-XX:MaxPermSize）；将会抛出OutOfMemoryError异常</li></ol></li></ol></blockquote><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><hr><h3 id="1-什么是线程"><a href="#1-什么是线程" class="headerlink" title="1. 什么是线程"></a>1. 什么是线程</h3><blockquote><p>线程是操作系统能够进行调度的最小单位，它被包含在进程之中，是进程中的实际运作单位，可以使用多线程对进行运算提速。</p></blockquote><h3 id="2-编写多线程的几种方式"><a href="#2-编写多线程的几种方式" class="headerlink" title="2. 编写多线程的几种方式"></a>2. <a href="https://juejin.im/post/5aa12936f265da238d504b7c" target="_blank" rel="noopener">编写多线程的几种方式</a></h3><blockquote><ol><li>一种是继承Thread类；</li><li>另一种是实现Runnable接口。两种方式都要通过重写run()方法来定义线程的行为，推荐使用后者，因为Java中的继承是单继承，一个类有一个父类，如果继承了Thread类就无法再继承其他类了，显然使用Runnable接口更为灵活。</li><li>实现Callable接口，该接口中的call方法可以在线程执行结束时产生一个返回值</li></ol></blockquote><h3 id="3-什么是FutureTask"><a href="#3-什么是FutureTask" class="headerlink" title="3.  什么是FutureTask"></a>3.  <a href="http://www.importnew.com/25286.html" target="_blank" rel="noopener">什么是FutureTask</a></h3><blockquote><p>FutureTask实现了Future接口和Runnable接口，可以对任务进行取消和获取返回值等操作。</p></blockquote><h3 id="4-如何强制启动一个线程"><a href="#4-如何强制启动一个线程" class="headerlink" title="4. 如何强制启动一个线程"></a>4. 如何强制启动一个线程</h3><blockquote><p>做不到，和gc一样，只能通知系统，具体何时启动有系统控制</p></blockquote><h3 id="5-启用一个线程是调用run-还是start-方法"><a href="#5-启用一个线程是调用run-还是start-方法" class="headerlink" title="5. 启用一个线程是调用run()还是start()方法"></a>5. 启用一个线程是调用run()还是start()方法</h3><blockquote><p>启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM 调度并执行，这并不意味着线程就会立即运行</p></blockquote><h3 id="6-说出线程调度和线程同步的方法"><a href="#6-说出线程调度和线程同步的方法" class="headerlink" title="6. 说出线程调度和线程同步的方法"></a>6. 说出线程调度和线程同步的方法</h3><h4 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h4><blockquote><ol><li>wait( ):Object方法，必须在同步代码块或同步方法中使用，使当前线程处于等待状态，释放锁</li><li>notify ( ):Object方法，和wait方法联合使用，通知一个线程，具体通知哪个由jvm决定，使用不当可能发生死锁</li><li>notifyAll ( ):Object方法，和wait方法联合使用，通知所有线程，具体哪个线程获得运行权jvm决定</li><li>sleep( ):使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常</li></ol></blockquote><h4 id="7-线程同步"><a href="#7-线程同步" class="headerlink" title="7. 线程同步"></a>7. 线程同步</h4><blockquote><ol><li>Synchronized修饰方法</li><li>Synchronized修饰代码块</li><li>Lock/ReadWriteLock</li><li>ThreadLocal：每个线程都有一个局部变量的副本，互不干扰。一种以空间换时间的方式</li><li>java中有很多线程安全的容器和方法，可以帮助我们实现线程同步：如Collections.synchronizedList()方法将List转为线程同步；用ConurrentHashMap 实现hashmap的线程同步。BlockingQueue阻塞队列也是线程同步的，非常适用于生产者消费者模式</li><li>扩展：volatile（volatile修饰的变量不会缓存在寄存器中，每次使用都会从主存中读取）：保证可见性，不保证原子性，因此不是线程安全。<a href="https://zhuanlan.zhihu.com/p/27266281" target="_blank" rel="noopener">在一写多读/状态标志的场景中使用</a></li></ol></blockquote><h3 id="8-什么是可重入锁"><a href="#8-什么是可重入锁" class="headerlink" title="8. 什么是可重入锁"></a>8. <a href="https://blog.csdn.net/johnking123/article/details/50043961" target="_blank" rel="noopener">什么是可重入锁</a></h3><blockquote><p>所谓重入锁，指的是以线程为单位，当一个线程获取对象锁之后，这个线程可以再次获取本对象上的锁，而其他的线程是不可以的</p></blockquote><h3 id="9-Java中如何停止一个线程"><a href="#9-Java中如何停止一个线程" class="headerlink" title="9. Java中如何停止一个线程"></a>9. Java中如何停止一个线程</h3><blockquote><ol><li>Java提供了很丰富的API但没有为停止线程提供API</li><li>可以用volatile 布尔变量来退出run()方法的循环或者是取消任务来中断线程</li></ol></blockquote><h3 id="10-一个线程运行时发生异常会怎样"><a href="#10-一个线程运行时发生异常会怎样" class="headerlink" title="10. 一个线程运行时发生异常会怎样"></a>10. 一个线程运行时发生异常会怎样</h3><blockquote><ol><li>如果异常没有被捕获该线程将会停止执行</li><li>可以用UncaughtExceptionHandler来捕获这种异常</li></ol></blockquote><h3 id="11-多线程共享数据"><a href="#11-多线程共享数据" class="headerlink" title="11. 多线程共享数据"></a>11. 多线程共享数据</h3><blockquote><ol><li>使用同一个runnable对象</li><li>使用不同的runnable对象,将同一共享数据实例传给不同的runnable</li><li>使用不同的runnable对象,将这些Runnable对象作为一个内部类,将共享数据作为成员变量</li></ol></blockquote><h3 id="12-多线程的最佳实践-好习惯"><a href="#12-多线程的最佳实践-好习惯" class="headerlink" title="12. 多线程的最佳实践/好习惯"></a>12. 多线程的最佳实践/好习惯</h3><blockquote><ol><li>给线程起个有意义的名字</li><li>避免使用锁和缩小锁的范围</li><li>多用同步辅助类（CountDownLatch、CyclicBarrier、Semaphore）少用wait、notify</li><li>多用并发集合少用同步集合</li></ol></blockquote><h3 id="13-ThreadLocal的设计理念与作用"><a href="#13-ThreadLocal的设计理念与作用" class="headerlink" title="13. ThreadLocal的设计理念与作用"></a>13. ThreadLocal的设计理念与作用</h3><blockquote><ol><li>供线程内的局部变量，线程独有，不与其他线程共享</li><li>适用场景：多线程情况下某一变量不需要线程间共享，需要各个线程间相互独立</li></ol></blockquote><h3 id="14-ThreadLocal原理，用的时候需要注意什么"><a href="#14-ThreadLocal原理，用的时候需要注意什么" class="headerlink" title="14. ThreadLocal原理，用的时候需要注意什么"></a>14. <a href="http://www.jb51.net/article/105491.htm" target="_blank" rel="noopener">ThreadLocal原理</a>，用的时候需要注意什么</h3><blockquote><ol><li>ThreadLocal通过获得Thread实例内部的ThreadLocalMap来存取数据</li><li>ThreadLocal实例本身作为key值</li><li>如果使用线程池，Threadlocal可能是上一个线程的值，需要我们显示的控制</li><li>ThreadLocal的key虽然采用弱引用，但是仍然可能造成内存泄漏（key为null，value还有值）<br> 扩展：Android中的ThreadLocal实现略有不同，使用Thread实例中的是数组存值，通过ThreadLocal实例计算一个唯一的hash确定下标。</li></ol></blockquote><h3 id="15-线程的基本状态及状态之间的关系"><a href="#15-线程的基本状态及状态之间的关系" class="headerlink" title="15. 线程的基本状态及状态之间的关系"></a>15. 线程的基本状态及状态之间的关系</h3><p><img src="https://user-gold-cdn.xitu.io/2018/3/14/1622504230e62e0f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="16-如果同步块内的线程抛出异常会发生什么"><a href="#16-如果同步块内的线程抛出异常会发生什么" class="headerlink" title="16. 如果同步块内的线程抛出异常会发生什么"></a>16. 如果同步块内的线程抛出异常会发生什么</h3><blockquote><ol><li>线程内的异常可以捕获，如果没有捕获，该线程会停止运行退出</li><li>不论是正常退出还是异常退出，同步块中的锁都会释放</li></ol></blockquote><h3 id="17-什么是死锁-deadlock"><a href="#17-什么是死锁-deadlock" class="headerlink" title="17. 什么是死锁(deadlock)"></a>17. 什么是死锁(deadlock)</h3><blockquote><p>两个线程互相等待对方释放资源才能继续执行下去，这个时候就形成了死锁，谁都无法继续执行（或者多个线程循环等待）</p></blockquote><h3 id="18-N个线程访问N个资源，如何避免死锁"><a href="#18-N个线程访问N个资源，如何避免死锁" class="headerlink" title="18. N个线程访问N个资源，如何避免死锁"></a>18. N个线程访问N个资源，如何避免死锁</h3><blockquote><p>以同样的顺序加锁和释放锁</p></blockquote><h3 id="19-为什么应该在循环中检查等待条件"><a href="#19-为什么应该在循环中检查等待条件" class="headerlink" title="19. 为什么应该在循环中检查等待条件"></a>19. 为什么应该在循环中检查等待条件</h3><blockquote><p>处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出</p></blockquote><h3 id="20-Java中的同步集合与并发集合有什么区别"><a href="#20-Java中的同步集合与并发集合有什么区别" class="headerlink" title="20. Java中的同步集合与并发集合有什么区别"></a>20. <a href="http://youyu4.iteye.com/blog/2352846" target="_blank" rel="noopener">Java中的同步集合与并发集合有什么区别</a></h3><blockquote><ol><li>同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合</li><li>并发集合性能更高</li></ol></blockquote><h3 id="21-Java中活锁和死锁有什么区别"><a href="#21-Java中活锁和死锁有什么区别" class="headerlink" title="21. Java中活锁和死锁有什么区别"></a>21. Java中活锁和死锁有什么区别</h3><blockquote><p>这是上题的扩展，活锁和死锁类似，不同之处在于处于活锁的线程或进程的状态是不断改变的，活锁可以认为是一种特殊的饥饿。一个现实的活锁例子是两个 人在狭小的走廊碰到，两个人都试着避让对方好让彼此通过，但是因为避让的方向都一样导致最后谁都不能通过走廊。简单的说就是，活锁和死锁的主要区别是前者进程的状态可以改变但是却不能继续执行</p></blockquote><h3 id="22-怎么检测一个线程是否拥有锁"><a href="#22-怎么检测一个线程是否拥有锁" class="headerlink" title="22. 怎么检测一个线程是否拥有锁"></a>22. <a href="https://blog.csdn.net/w410589502/article/details/54949506" target="_blank" rel="noopener">怎么检测一个线程是否拥有锁</a></h3><blockquote><p>java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁</p></blockquote><h3 id="23-Java中ConcurrentHashMap的并发度是什么"><a href="#23-Java中ConcurrentHashMap的并发度是什么" class="headerlink" title="23. Java中ConcurrentHashMap的并发度是什么"></a>23. Java中ConcurrentHashMap的并发度是什么</h3><blockquote><p>ConcurrentHashMap把实际map划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是 ConcurrentHashMap类构造函数的一个可选参数，默认值为16，这样在多线程情况下就能避免争用</p></blockquote><h3 id="24-什么是阻塞式方法"><a href="#24-什么是阻塞式方法" class="headerlink" title="24. 什么是阻塞式方法"></a>24. 什么是阻塞式方法</h3><blockquote><p>阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket的accept()方法就是一直等待客户端连接。这里的阻塞是 指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。</p></blockquote><h3 id="25-多线程中的忙循环是什么"><a href="#25-多线程中的忙循环是什么" class="headerlink" title="25. 多线程中的忙循环是什么"></a>25. 多线程中的忙循环是什么</h3><blockquote><p>忙循环就是程序员用循环让一个线程等待，不像传统方法wait(), sleep() 或 yield() 它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存，在多核系统中，一个等待线程醒来的时候可 能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。</p></blockquote><h3 id="26-如何保证多线程下-i-结果正确"><a href="#26-如何保证多线程下-i-结果正确" class="headerlink" title="26. 如何保证多线程下 i++ 结果正确"></a>26. 如何保证多线程下 i++ 结果正确</h3><blockquote><p>可以使用synchronized保证原子性，也可以使用AtomicInteger类<br> 扩展：volatile只能保证可见性，不能保证原子性，因此不行</p></blockquote><h3 id="27-简述Java中具有哪几种粒度的锁"><a href="#27-简述Java中具有哪几种粒度的锁" class="headerlink" title="27. 简述Java中具有哪几种粒度的锁"></a>27. 简述Java中具有哪几种粒度的锁</h3><blockquote><p>Java中可以对类、对象、方法或是代码块上锁</p></blockquote><h3 id="同步方法和同步代码块的对比"><a href="#同步方法和同步代码块的对比" class="headerlink" title="同步方法和同步代码块的对比"></a>同步方法和同步代码块的对比</h3><blockquote><ol><li>同步代码块可以指定更小的粒度</li><li>同步代码块可以给指定实例加锁</li></ol></blockquote><h3 id="28-类锁和对象锁"><a href="#28-类锁和对象锁" class="headerlink" title="28. 类锁和对象锁"></a>28. <a href="https://blog.csdn.net/crazylzxlzx/article/details/52200865" target="_blank" rel="noopener">类锁和对象锁</a></h3><blockquote><p>类锁其实时一种特殊的对象锁，它锁的其实时类对应的class对象</p></blockquote><h2 id="线程中的关键字和类"><a href="#线程中的关键字和类" class="headerlink" title="线程中的关键字和类"></a>线程中的关键字和类</h2><hr><h3 id="0-sleep和wait方法的对比"><a href="#0-sleep和wait方法的对比" class="headerlink" title="0. sleep和wait方法的对比"></a>0. sleep和wait方法的对比</h3><blockquote><ol><li>两个方法都是暂停线程,释放cpu资源给其他线程</li><li>sleep是Thread的静态方法，wait是Object的方法。</li><li>sleep使线程进入阻塞状态；wait使线程进入等待状态，靠其他线程notify或者notifyAll来改变状态</li><li>sleep可以在任何地方使用，必须捕获异常；而wait必须在同步方法或者同步块中使用，否则会抛出运行时异常</li><li>最重要的：sleep继续持用锁，wait释放锁 扩展：yield停止当前线程，让同优先级或者优先级高的线程先执行（但不会释放锁）；join方法在某一个线程的执行过程中调用另一个线程执行，等到被调用的线程执行结束后，再继续执行当前线程</li></ol></blockquote><h3 id="1-线程的sleep-方法和yield-方法有什么区别"><a href="#1-线程的sleep-方法和yield-方法有什么区别" class="headerlink" title="1. 线程的sleep()方法和yield()方法有什么区别"></a>1. 线程的sleep()方法和yield()方法有什么区别</h3><blockquote><ol><li>sleep方法使当前线程阻塞指定时间，随后进入就绪状态</li><li>yield方法使当前线程进入就绪状态，让同优先级或者更高优先级的线程先执行</li><li>sleep方法会抛出interruptedException</li></ol></blockquote><h3 id="2-为什么wait-notify-和-notifyAll这些方法不在thread类里面"><a href="#2-为什么wait-notify-和-notifyAll这些方法不在thread类里面" class="headerlink" title="2. 为什么wait, notify 和 notifyAll这些方法不在thread类里面"></a>2. 为什么wait, notify 和 notifyAll这些方法不在thread类里面</h3><blockquote><p>JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通 过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁 就不明显了</p></blockquote><h3 id="3-为什么wait和notify方法要在同步块中调用"><a href="#3-为什么wait和notify方法要在同步块中调用" class="headerlink" title="3. 为什么wait和notify方法要在同步块中调用"></a>3. <a href="https://blog.csdn.net/haluoluo211/article/details/49558155" target="_blank" rel="noopener">为什么wait和notify方法要在同步块中调用</a></h3><blockquote><ol><li>java规定必须在同步块中，不在同步块中会抛出异常</li><li>如果不在同步块中，有可能notify在执行的时候，wait没有收到陷入死锁</li></ol></blockquote><h3 id="4-synchronized关键字的用法"><a href="#4-synchronized关键字的用法" class="headerlink" title="4. synchronized关键字的用法"></a>4. synchronized关键字的用法</h3><blockquote><p>synchronized 用于线程同步</p><ol><li>可以修饰方法</li><li>可以修饰代码块</li><li>当持有的锁是类时，那么所有实例对象调用该方法或者代码块都会被锁</li></ol></blockquote><h3 id="5-synchronized-在静态方法和普通方法的区别"><a href="#5-synchronized-在静态方法和普通方法的区别" class="headerlink" title="5. synchronized 在静态方法和普通方法的区别"></a>5. synchronized 在静态方法和普通方法的区别</h3><blockquote><ol><li>synchronized修饰静态方法时，锁是类，所有的对象实例用同一把锁</li><li>修饰普通方法时，锁是类的实例</li></ol></blockquote><h3 id="6-当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？"><a href="#6-当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？" class="headerlink" title="6. 当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？"></a>6. 当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？</h3><blockquote><p>不能。其它线程只能访问该对象的非同步方法。第一个线程持有了对象锁，第二个线程的同步方法也需要该对象的锁才能运行，只能在锁池中等待了。</p></blockquote><h3 id="7-Java中的volatile-变量是什么"><a href="#7-Java中的volatile-变量是什么" class="headerlink" title="7. Java中的volatile 变量是什么"></a>7. Java中的volatile 变量是什么</h3><blockquote><ol><li>volatile是一个修饰符，只能修饰成员变量</li><li>volatile保证了变量的可见性（A线程的改变，B线程马上可以获取到）</li><li>volatile禁止进行指令重排序</li></ol></blockquote><h3 id="8-写一个双检锁的单例"><a href="#8-写一个双检锁的单例" class="headerlink" title="8. 写一个双检锁的单例"></a>8. 写一个双检锁的单例</h3><pre><code>private static volatile Singleton instance;  private Singleton(){}  public Singleton getInstance(if(singleton == null){  synchronized(Singleton.class){  if(singleton == null){  singleton = new Singleton();  }  }}return sinlgeton;)复制代码</code></pre><h3 id="9-单例的DCL方式下，那个单例的私有变量要不要加volatile关键字，这个关键字有什么用"><a href="#9-单例的DCL方式下，那个单例的私有变量要不要加volatile关键字，这个关键字有什么用" class="headerlink" title="9. 单例的DCL方式下，那个单例的私有变量要不要加volatile关键字，这个关键字有什么用"></a>9. <a href="https://blog.csdn.net/glory1234work2115/article/details/50814419" target="_blank" rel="noopener">单例的DCL方式下，那个单例的私有变量要不要加volatile关键字</a>，这个关键字有什么用</h3><blockquote><ol><li>要加</li><li>两个线程同时访问双检锁，有可能指令重排序，线程1初始化一半，切换到线程2；因为初始化不是一个原子操作，此时线程2读到不为null直接使用，但是因为还没有初始化完成引起崩溃</li></ol></blockquote><h4 id="10-Synchronized-和Lock-ReadWriteLock的区别"><a href="#10-Synchronized-和Lock-ReadWriteLock的区别" class="headerlink" title="10. Synchronized 和Lock\ReadWriteLock的区别"></a>10. Synchronized 和Lock\ReadWriteLock的区别</h4><blockquote><ol><li>Synchronized时java关键字，Lock/ReadWriteLock接口，它们都是可重入锁</li><li>Synchronized由虚拟机控制，不需要用户去手动释放锁，执行完毕后自动释放；而Lock是用户显示控制的，要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。</li><li>Lock可以用更多的方法，比如tryLock（）拿到锁返回true，否则false；tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间;Lock有lockInterruptibly（）方法，是可中断锁</li><li>ReentrantLock可以实现公平锁（等得久的先执行）</li><li>ReadWriteLock是一个接口，ReentrantReadWriteLock是它的一个实现，将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁，提高了读写效率。</li></ol></blockquote><h3 id="11-LockSupport"><a href="#11-LockSupport" class="headerlink" title="11. LockSupport"></a>11. LockSupport</h3><p>LockSupport是JDK中比较底层的类，用来创建锁和其他同步工具类的基本线程阻塞原语</p><blockquote><p>park 方法获取许可。许可默认是被占用的，调用park()时获取不到许可，所以进入阻塞状态 unpark 方法颁发许可</p></blockquote><h3 id="12-ReadWriteLock"><a href="#12-ReadWriteLock" class="headerlink" title="12. ReadWriteLock"></a>12. ReadWriteLock</h3><blockquote><ol><li>读写分离的锁，可以提升效率</li><li>读读能共存，读写、写写不能共存</li></ol></blockquote><h3 id="13-可重入锁（RetrantLock）实现原理"><a href="#13-可重入锁（RetrantLock）实现原理" class="headerlink" title="13. 可重入锁（RetrantLock）实现原理"></a>13. <a href="http://blog.jobbole.com/108571/" target="_blank" rel="noopener">可重入锁（RetrantLock）实现原理</a></h3><blockquote><ol><li>RetrantLock 是通过CAS和AQS实现的</li><li><a href="https://www.jianshu.com/p/fb6e91b013cc" target="_blank" rel="noopener">CAS（Compare And Swap）</a>：三个参数，一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。原子性操作</li><li>RetrantLock内部有一个AbstractQueuedSynchronizer实例，AbstractQueuedSynchronizer是一个抽象类，RetrantLock中有两种对他的实现，一种是公平锁，一种是非公平锁</li><li>在lock时，调用一个CAS的方法compareAndSet来将state设置为1，state是一个volitale的变量，并将当前线程和锁绑定</li><li>当compareAndSet失败时，尝试获取锁：如果和锁绑定的线程时当前线程，state+1</li><li>如果获取锁失败，将其加入到队列中等待，从而保证了并发执行的操作变成了串行</li><li>扩展：公平锁和非公平锁的区别：非公平锁无视队列，直接查看当前可不可以拿到锁；公平锁会先查看队列，队列非空的话会加入队列</li></ol></blockquote><h3 id="14-Others"><a href="#14-Others" class="headerlink" title="14. Others"></a>14. Others</h3><blockquote><p>synchronized 的实现原理以及锁优化？:Monitor<br> volatile 的实现原理？：内存屏障<br> CAS？CAS 有什么缺陷，如何解决？CompareAndSwap，通过cpu指令实现的<br> AQS ：AbstractQueueSynchronizer，是ReentrantLock一个内部类<br> 如何检测死锁？怎么预防死锁？：死锁必须满足四个条件，破坏任意一个条件都可以解除死锁<br> <a href="http://ifeve.com/talk-concurrency-forkjoin/" target="_blank" rel="noopener">Fork/Join框架</a></p></blockquote><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><hr><h3 id="0-什么是线程池（thread-pool）"><a href="#0-什么是线程池（thread-pool）" class="headerlink" title="0. 什么是线程池（thread pool）"></a>0. 什么是线程池（thread pool）</h3><blockquote><ol><li>频繁的创建和销毁对象很耗费资源，所以java引入了线程池。Java 5+中的Executor接口定义一个执行线程的工具。它的子类型即线程池接口是ExecutorService。</li><li>Executors 是一个工具类，可以帮我们生成一些特性的线程池</li></ol></blockquote><pre><code>newSingleThreadExecutor：创建一个单线程化的Executor，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。newFixedThreadPool：创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。newScheduleThreadPool：创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。复制代码</code></pre><blockquote><ol><li>我们常用的ThreadPoolExecutor实现了ExecutorService接口,以下是原理和参数说明</li></ol></blockquote><pre><code>原理：step1.调用ThreadPoolExecutor的execute提交线程，首先检查CorePool，如果CorePool内的线程小于CorePoolSize，新创建线程执行任务。step2.如果当前CorePool内的线程大于等于CorePoolSize，那么将线程加入到BlockingQueue。step3.如果不能加入BlockingQueue，在小于MaxPoolSize的情况下创建线程执行任务。step4.如果线程数大于等于MaxPoolSize，那么执行拒绝策略。参数说明：ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)corePoolSize 核心线程池大小maximumPoolSize 线程池最大容量大小keepAliveTime 线程池空闲时，线程存活的时间TimeUnit 时间单位ThreadFactory 线程工厂BlockingQueue任务队列RejectedExecutionHandler 线程拒绝策略扩展：ThreadPoolExecutor 的submit和excute方法都能执行任务，有什么区别？1. 入参不同：excute只能接受Runnable，submit可以接受Runnable和Callable2. submit有返回值3. 在异常处理时，submit可以通过Future.get捕获抛出的异常复制代码</code></pre><h3 id="1-线程池如何调优，最大数目如何确认"><a href="#1-线程池如何调优，最大数目如何确认" class="headerlink" title="1. 线程池如何调优，最大数目如何确认"></a>1. 线程池如何调优，最大数目如何确认</h3><blockquote><ol><li>线程池的调优优根据具体情况具体分析，尽量使系统资源利用率最大</li><li>例如如果cpu效率明显高于IO，那么就应该创建更多线程提高cpu利用率，避免io等待（<a href="https://www.cnblogs.com/jianzh5/p/6437315.html" target="_blank" rel="noopener">参考1</a>，<a href="https://www.zhihu.com/question/37804956" target="_blank" rel="noopener">参考2</a>）</li><li>Android中最大数目可以是：cpu数目*2+1，但也要根据具体场景，例如picaso会根据网络状况调整最大数目（<a href="https://www.aliyun.com/jiaocheng/14845.html" target="_blank" rel="noopener">参考</a>）</li></ol></blockquote><h3 id="2-如果你提交给ThreadPoolExcuter任务时，线程池队列已满，这时会发生什么"><a href="#2-如果你提交给ThreadPoolExcuter任务时，线程池队列已满，这时会发生什么" class="headerlink" title="2. 如果你提交给ThreadPoolExcuter任务时，线程池队列已满，这时会发生什么"></a>2. 如果你提交给ThreadPoolExcuter任务时，线程池队列已满，这时会发生什么</h3><blockquote><p>1.如果还没达到最大线程数，则新建线程 2.如果已经达到最大线程数，交给RejectExecutionHandler处理。 3.如果没有设置自定义RejectExecutionHandler，则抛出RejectExecutionExcuption</p></blockquote><h3 id="3-线程池的用法与优势"><a href="#3-线程池的用法与优势" class="headerlink" title="3. 线程池的用法与优势"></a>3. 线程池的用法与优势</h3><blockquote><p>优势: 实现对线程的复用，避免了反复创建及销毁线程的开销；使用线程池统一管理线程可以减少并发线程的数目，而线程数过多往往会在线程上下文切换上以及线程同步上浪费过多时间。</p></blockquote><blockquote><p>用法: 我们可以调用ThreadPoolExecutor的某个构造方法来自己创建一个线程池。但通常情况下我们可以使用Executors类提供给我们的静态工厂方法来更方便的创建一个线程池对象。创建了线程池对象后，我们就可以调用submit或者excute方法提交任务到线程池中去执行了；线程池使用完毕后我们要记得调用shutdown方法来关闭它。</p></blockquote><h2 id="多线程中的工具类"><a href="#多线程中的工具类" class="headerlink" title="多线程中的工具类"></a>多线程中的工具类</h2><hr><h3 id="0-Java并发编程：CountDownLatch、CyclicBarrier（栅栏）和Semaphore（信号量）"><a href="#0-Java并发编程：CountDownLatch、CyclicBarrier（栅栏）和Semaphore（信号量）" class="headerlink" title="0. Java并发编程：CountDownLatch、CyclicBarrier（栅栏）和Semaphore（信号量）"></a>0. Java并发编程：<a href="https://www.cnblogs.com/dolphin0520/p/3920397.html" target="_blank" rel="noopener">CountDownLatch、CyclicBarrier（栅栏）和Semaphore（信号量）</a></h3><blockquote><ol><li>CountDownLatch:利用它可以实现类似计数器的功能。比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了</li></ol></blockquote><pre><code>public class Test {     public static void main(String[] args) {            final CountDownLatch latch = new CountDownLatch(2);         new Thread(){             public void run() {                 try {                     System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;正在执行&quot;);                    Thread.sleep(3000);                    System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;执行完毕&quot;);                    latch.countDown();                } catch (InterruptedException e) {                    e.printStackTrace();                }             };         }.start();         new Thread(){             public void run() {                 try {                     System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;正在执行&quot;);                     Thread.sleep(3000);                     System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;执行完毕&quot;);                     latch.countDown();                } catch (InterruptedException e) {                    e.printStackTrace();                }             };         }.start();         try {             System.out.println(&quot;等待2个子线程执行完毕...&quot;);            latch.await();            System.out.println(&quot;2个子线程已经执行完毕&quot;);            System.out.println(&quot;继续执行主线程&quot;);        } catch (InterruptedException e) {            e.printStackTrace();        }     }}复制代码</code></pre><blockquote><ol><li>CyclicBarrier: 实现让一组线程等待至某个状态之后再全部同时执行</li></ol></blockquote><pre><code>public class Test {    public static void main(String[] args) {        int N = 4;        CyclicBarrier barrier  = new CyclicBarrier(N);        for(int i=0;i&lt;N;i++)            new Writer(barrier).start();    }    static class Writer extends Thread{        private CyclicBarrier cyclicBarrier;        public Writer(CyclicBarrier cyclicBarrier) {            this.cyclicBarrier = cyclicBarrier;        }        @Override        public void run() {            System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;正在写入数据...&quot;);            try {                Thread.sleep(5000);      //以睡眠来模拟写入数据操作                System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;写入数据完毕，等待其他线程写入完毕&quot;);                cyclicBarrier.await();            } catch (InterruptedException e) {                e.printStackTrace();            }catch(BrokenBarrierException e){                e.printStackTrace();            }            System.out.println(&quot;所有线程写入完毕，继续处理其他任务...&quot;);        }    }}扩展（CyclicBarrier和CountdownLatch的区别）：1.CountdownLatch等待几个任务执行完毕，CyclicBarrier等待达到某个状态；2.CyclicBarrier可以调用reset，循环使用；3.CyclicBarrier可以有含Runnable的构造方法，当达到某一状态时执行某一任务。复制代码</code></pre><blockquote><ol><li>Semaphore：Semaphore可以控同时访问的某个资源的线程个数</li></ol></blockquote><pre><code>public class Test {    public static void main(String[] args) {        int N = 8;            //工人数        Semaphore semaphore = new Semaphore(5); //机器数目        for(int i=0;i&lt;N;i++)            new Worker(i,semaphore).start();    }    static class Worker extends Thread{        private int num;        private Semaphore semaphore;        public Worker(int num,Semaphore semaphore){            this.num = num;            this.semaphore = semaphore;        }        @Override        public void run() {            try {                semaphore.acquire();                System.out.println(&quot;工人&quot;+this.num+&quot;占用一个机器在生产...&quot;);                Thread.sleep(2000);                System.out.println(&quot;工人&quot;+this.num+&quot;释放出机器&quot;);                semaphore.release();                       } catch (InterruptedException e) {                e.printStackTrace();            }        }    }}复制代码</code></pre><h3 id="1-java中的信号量（Semaphore）"><a href="#1-java中的信号量（Semaphore）" class="headerlink" title="1. java中的信号量（Semaphore）"></a>1. <a href="https://blog.csdn.net/zzp_403184692/article/details/8017173" target="_blank" rel="noopener">java中的信号量（Semaphore）</a></h3><blockquote><ol><li>Semaphore可以控制当前资源被访问的线程个数，超过最大个数后线程处于阻塞等待状态</li><li>当线程个数指定为1时，可以当锁使用</li></ol></blockquote><h3 id="2-怎么实现所有线程在等待某个事件的发生才会去执行"><a href="#2-怎么实现所有线程在等待某个事件的发生才会去执行" class="headerlink" title="2. 怎么实现所有线程在等待某个事件的发生才会去执行"></a>2. <a href="https://blog.csdn.net/jiyiqinlovexx/article/details/51236323" target="_blank" rel="noopener">怎么实现所有线程在等待某个事件的发生才会去执行</a></h3><blockquote><p>所有线程需要阻塞等待，并且观察到事件状态改变满足条件时自动执行，可以用以下方法实现</p><ol><li>闭锁CountDownLatch：闭锁是典型的等待事件发生的同步工具类，将闭锁的初始值设置1，所有线程调用await方法等待，当事件发生时调用countDown将闭锁值减为0，则所有await等待闭锁的线程得以继续执行。</li><li>阻塞队列BlockingQueue：所有等待事件的线程尝试从空的阻塞队列获取元素，将阻塞，当事件发生时，向阻塞队列中同时放入N个元素(N的值与等待的线程数相同)，则所有等待的线程从阻塞队列中取出元素后得以继续执行。</li><li>信号量Semaphore：设置信号量的初始值为等待的线程数N，一开始将信号量申请完，让剩余的信号量为0，待事件发生时，同时释放N个占用的信号量，则等待信号量的所有线程将获取信号量得以继续执行。</li></ol></blockquote><h3 id="3-生产者-消费者实现之阻塞队列"><a href="#3-生产者-消费者实现之阻塞队列" class="headerlink" title="3. 生产者-消费者实现之阻塞队列"></a>3. 生产者-消费者实现之<a href="http://ifeve.com/java-blocking-queue/" target="_blank" rel="noopener">阻塞队列</a></h3><blockquote><ol><li>扩展：<a href="https://github.com/francistao/LearningNotes/blob/master/Part2/JavaConcurrent/生产者和消费者问题.md" target="_blank" rel="noopener">通过sychronized关键字实现</a></li><li>阻塞队列的特征是当取或放元素是，队列不满足条件（比如队列为空时进行取操作）可以阻塞等待，知道满足条件</li></ol></blockquote><pre><code>public class BlockingQueueTest { private int size = 20; private ArrayBlockingQueue&lt;Integer&gt; queue = new ArrayBlockingQueue&lt;&gt;(size);  public static void main(String[] args) {  BlockingQueueTest test = new BlockingQueueTest(); Producer producer = test.new Producer(); Consumer consumer = test.new Consumer();  producer.start(); consumer.start();  } class Consumer extends Thread{  @Override public void run() { while(true){ try {       //从阻塞队列中取出一个元素       queue.take();       System.out.println(&quot;队列剩余&quot; + queue.size() + &quot;个元素&quot;);       } catch (InterruptedException e) {       } } } }  class Producer extends Thread{       @Override public void run() {        while (true) {         try {          //向阻塞队列中插入一个元素          queue.put(1);          System.out.println(&quot;队列剩余空间：&quot; + (size - queue.size()));          } catch (InterruptedException e) {} }} }}复制代码</code></pre><h3 id="4-ArrayBlockingQueue-CountDownLatch类的作用"><a href="#4-ArrayBlockingQueue-CountDownLatch类的作用" class="headerlink" title="4. ArrayBlockingQueue, CountDownLatch类的作用"></a>4. ArrayBlockingQueue, CountDownLatch类的作用</h3><blockquote><ol><li>ArrayBlockingQueue:一个基于数组实现的阻塞队列，它在构造时需要指定容量。当试图向满队列中添加元素或者从空队列中移除元素时，当前线程会被阻塞。</li><li><a href="http://blog.csdn.net/coderinchina/article/details/53160290" target="_blank" rel="noopener">CountDownLatch</a>：同步计数器,是一个线程工具类，可以让一个或几个线程等待其他线程</li></ol></blockquote><h3 id="5-Condition"><a href="#5-Condition" class="headerlink" title="5. Condition"></a>5. <a href="https://www.jianshu.com/p/b476df2f6d08" target="_blank" rel="noopener">Condition</a></h3><blockquote><p>Condition是一个接口,有await和signal方法，和Object的wait、notify类似 Condition 通过lock获得：Condition condition = lock.newCondition(); 相对于Object的wait、notify，Condition的控制更加灵活，可以满足唤起某一线程的目的</p></blockquote><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><hr><h3 id="0-进程的三个状态"><a href="#0-进程的三个状态" class="headerlink" title="0. 进程的三个状态"></a>0. 进程的三个状态</h3><blockquote><ol><li>就绪状态：获得CPU调度时由 就绪状态 转换为 运行状态</li><li>运行状态：CPU时间片用完了由 运行状态 转换为 就绪状态 运行状态</li><li>阻塞状态：因等待某个事件发生而进入 阻塞状态，事件发生后由 阻塞状态 转换为 就绪状态</li></ol></blockquote><h3 id="1-进程的同步和互斥"><a href="#1-进程的同步和互斥" class="headerlink" title="1. 进程的同步和互斥"></a>1. 进程的同步和互斥</h3><blockquote><ol><li>互斥：两个进程由于不能同时使用同一临界资源，只能在一个进程使用完了，另一进程才能使用，这种现象称为进程间的互斥。</li><li>对于互斥的资源，A进程到达了该点后，若此时B进程正在对此资源进行操作，则A停下来，等待这些操作的完成再继续操作。这就是进程间的同步</li></ol></blockquote><h3 id="2-死锁产生的必要条件"><a href="#2-死锁产生的必要条件" class="headerlink" title="2. 死锁产生的必要条件"></a>2. <a href="http://www.runoob.com/java/thread-deadlock.html" target="_blank" rel="noopener">死锁产生的必要条件</a></h3><blockquote><ol><li>互斥：一个资源一次只能被一个进程所使用，即是排它性使用</li><li>不剥夺条件：一个资源仅能被占有它的进程所释放，而不能被别的进程强占</li><li>请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源要求，而该资源又已被其它进程占有，此时请求进程阻塞，但又对已经获得的其它资源保持不放</li><li>环路等待条件：当每类资源只有一个时，在发生死锁时，必然存在一个进程—资源的环形链</li></ol></blockquote><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><hr><h3 id="0-描述一下JVM加载class文件的原理机制"><a href="#0-描述一下JVM加载class文件的原理机制" class="headerlink" title="0. 描述一下JVM加载class文件的原理机制"></a>0. 描述一下JVM加载class文件的原理机制</h3><p>类加载器的作用是根据指定全限定名称将class文件加载到JVM内存中，并转为Class对象。</p><h4 id="加载器的种类"><a href="#加载器的种类" class="headerlink" title="加载器的种类"></a>加载器的种类</h4><blockquote><ol><li>启动类加载器（根加载器 Bootstrap ClassLoader）：由native代码实现，负责将存放在<JAVA_HOME>\lib目录或-Xbootclasspath参数指定的路径中的类库加载到内存中</li><li>扩展加载器（Extension ClassLoader）：java语言实现，父加载器是Bootstrap，：负责加载<JAVA_HOME>\lib\ext目录或java.ext.dirs系统变量指定的路径中的所有类库。</li><li>应用程序类加载器（Application ClassLoader）:java实现，负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</li><li><a href="https://www.cnblogs.com/wxd0108/p/6681618.html" target="_blank" rel="noopener">自定义类加载器</a>：有时为了安全会将类加密，或者从远程（服务器）加载类 ，这个时候就需要自定义类加载器。自定义通过继承ClassLoader类实现，loadClass方法已经实现了双亲委派模式，当父类没有加载成功时，调用当前类的findclass方法，所以我们一般重写该方法。</li></ol></blockquote><h4 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h4><blockquote><ol><li>类加载器采用双亲委派模型进行加载：每次通过先委托父类加载器加载，当父类加载器无法加载时，再自己加载。</li><li>类的生命周期可以分为七个阶段：加载 -&gt; 连接（验证 -&gt; 准备<em>（为静态变量分配内存并设置默认的初始值）</em> -&gt; 解析<em>（将符号引用替换为直接引用）</em>）-&gt; 初始化 -&gt; 使用 -&gt; 卸载</li></ol></blockquote><h3 id="1-类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式"><a href="#1-类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式" class="headerlink" title="1. 类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式"></a>1. 类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式</h3><blockquote><ol><li>使用双亲委派模式，保证只加载一次该类</li><li>我们可以使用自定义的类加载器加载同名类，这样就阻止了系统双亲委派模式的加载</li></ol></blockquote><h3 id="2-ClassLoader的隔离问题"><a href="#2-ClassLoader的隔离问题" class="headerlink" title="2. ClassLoader的隔离问题"></a>2. <a href="http://www.trinea.cn/android/java-loader-common-class/" target="_blank" rel="noopener">ClassLoader的隔离问题</a></h3><blockquote><ol><li>JVM 及 Dalvik 对类唯一的识别是 ClassLoader id + PackageName + ClassName</li><li>两个相同的类可能因为两个ClassLoader加载而不兼容</li></ol></blockquote><h2 id="反射和范型"><a href="#反射和范型" class="headerlink" title="反射和范型"></a>反射和范型</h2><hr><h3 id="0-反射的原理和作用"><a href="#0-反射的原理和作用" class="headerlink" title="0. 反射的原理和作用"></a>0. 反射的原理和作用</h3><blockquote><ol><li>通过类的class对象类获得类的各种信息，创建对应的对象或者调用方法</li><li>App的动态加载或者Android中调用其他对象private方法，都需要反射</li></ol></blockquote><h3 id="1-类对象的获取方式"><a href="#1-类对象的获取方式" class="headerlink" title="1. 类对象的获取方式"></a>1. 类对象的获取方式</h3><blockquote><ol><li>String.class：不执行静态块和动态构造块</li><li>“hello”.getClass();：执行静态块和动态构造块</li><li>Class.forName(“java.lang.String”);：执行静态块，不执行动态构造块</li></ol></blockquote><h3 id="2-如何通过反射创建对象"><a href="#2-如何通过反射创建对象" class="headerlink" title="2. 如何通过反射创建对象"></a>2. 如何通过反射创建对象</h3><blockquote><ol><li>String.class.newInstance();</li><li>String.class.getConstrutor(Stirng.class).newInstance(“hello word”);</li></ol></blockquote><h3 id="3-如何通过反射获取和设置对象私有字段的值"><a href="#3-如何通过反射获取和设置对象私有字段的值" class="headerlink" title="3. 如何通过反射获取和设置对象私有字段的值"></a>3. 如何通过反射获取和设置对象私有字段的值</h3><blockquote><ol><li>通过类对象的getDeclaredField()方法获得（Field）对象</li><li>调用Field对象的setAccessible(true)方法将其设置为可访问</li><li>通过get/set方法来获取/设置字段的值</li></ol></blockquote><h3 id="4-通过反射调用对象的方法"><a href="#4-通过反射调用对象的方法" class="headerlink" title="4. 通过反射调用对象的方法"></a>4. 通过反射调用对象的方法</h3><blockquote><ol><li>通过类对象的getMethod方法获得Method对象</li><li>调用对象的invoke（）方法</li></ol></blockquote><h3 id="5-范型"><a href="#5-范型" class="headerlink" title="5. 范型"></a>5. 范型</h3><blockquote><ol><li>范型可以用于类定义和方法定义</li><li>范型的实现是通过擦除实现的，也就是说编译之后范型信息会被擦出</li></ol></blockquote><h3 id="6-通配符"><a href="#6-通配符" class="headerlink" title="6. 通配符"></a>6. <a href="https://blog.csdn.net/fw0124/article/details/42296283" target="_blank" rel="noopener">通配符</a></h3><blockquote><ol><li>通配符有两种用法：？extends A  和 ？ super A</li><li>？extends A 表示？的上界是A，具体什么类型并不清楚，适合于获取，获取到的一定是A类型</li><li>？ super A 表示？的下界是A，具体什么类型并不清楚，适合于插入，一定可以插入A类型</li></ol></blockquote><h3 id="7-注解（Annotation）"><a href="#7-注解（Annotation）" class="headerlink" title="7. 注解（Annotation）"></a>7. 注解（Annotation）</h3><blockquote><p>注解分为三种：源码级别（source），类文件级别（class）或者运行时级别（runtime）；butternife是类文件级别 参考：<a href="https://blog.csdn.net/javazejian/article/details/71860633" target="_blank" rel="noopener">https://blog.csdn.net/javazejian/article/details/71860633</a> <a href="https://blog.csdn.net/u013045971/article/details/53509237" target="_blank" rel="noopener">https://blog.csdn.net/u013045971/article/details/53509237</a><br> <a href="https://www.cnblogs.com/likeshu/p/5526187.html" target="_blank" rel="noopener">https://www.cnblogs.com/likeshu/p/5526187.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 知识 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rsync 使用</title>
      <link href="/2020/03/17/rsync/"/>
      <url>/2020/03/17/rsync/</url>
      
        <content type="html"><![CDATA[<h1 id="rsync-使用"><a href="#rsync-使用" class="headerlink" title="rsync 使用"></a>rsync 使用</h1><ul><li>h： human-readable, 输出友好</li><li>a： 合并模式；等于-rlptgoD（不含 -H -A -X）。</li><li>b： 制作备份。</li><li>C： 使用与CVS相同的方式来忽略文件。</li><li>u： 跳过比较新的文件。</li><li>v： 处理过程中，显示较多的信息。</li><li>z： 在传输过程中压缩文件。</li><li>–exclude： 排除通配模式匹配到的文件及文件夹。</li><li>a：合并了多个选项，其中每一项的含义如下：<ul><li>r： 递归的方式拷贝文件（recursive）。</li><li>l： 拷贝符号链接为符号链接（symlinks）。</li><li>p： 保留文件的权限信息（permissions）。</li><li>t： 保留文件的修改时间（times）。</li><li>g： 保留用户组信息（group）。</li><li>o： 保留所有者信息（owner）。</li><li>D： 等同于（–devices –specials）再次展开含义如下：<ul><li>–devices： 允许rsync传输字符设备和块设备</li><li>–specials： 允许rsync传输sockets文件和管道（fifos）文件。</li></ul></li></ul></li></ul><h4 id="增量备份"><a href="#增量备份" class="headerlink" title="增量备份"></a>增量备份</h4><pre class=" language-shell"><code class="language-shell">rsync -abCuvz /home/data/ /your/backup/</code></pre><p>会将<code>data</code>文件夹 备份到<code>/your/backup/</code>下</p><h4 id="增量备份并删除额外的文件"><a href="#增量备份并删除额外的文件" class="headerlink" title="增量备份并删除额外的文件"></a>增量备份并删除额外的文件</h4><pre class=" language-shell"><code class="language-shell">rsync -abCuvz  --delete /home/data/ /your/backup/</code></pre><h4 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h4><pre class=" language-shell"><code class="language-shell">rsync -abuvz --exclude '*~' /your/backup/data/ /home/data/</code></pre><h4 id="远程"><a href="#远程" class="headerlink" title="远程"></a>远程</h4><p>在服务器上，通常需要备份多个目录，如备份/home 、/etc、/opt目录， 则可以用以下的参数：</p><pre class=" language-shell"><code class="language-shell">rsync -av root@serverhost:/home/ root@serverhost:/etc/ root@serverhost:/opt/ /local/backup/media/</code></pre><p>也可以省略后面的主机：</p><pre class=" language-shell"><code class="language-shell">rsync -av root@serverhost:/home/ :/etc/ :/opt/ /local/backup/media/</code></pre><p><a href="https://www.cnblogs.com/kevingrace/p/6601088.html" target="_blank" rel="noopener">linux下rsync和tar增量备份梳理</a></p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> macOS </tag>
            
            <tag> rsync </tag>
            
            <tag> 备份 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Custom Build Bilibili ijkplayer</title>
      <link href="/2020/03/05/ijkplayer-build/"/>
      <url>/2020/03/05/ijkplayer-build/</url>
      
        <content type="html"><![CDATA[<h1 id="Build-Bilibili-ijkplayer"><a href="#Build-Bilibili-ijkplayer" class="headerlink" title="Build Bilibili ijkplayer"></a>Build Bilibili ijkplayer</h1><h3 id="MacOS-环境"><a href="#MacOS-环境" class="headerlink" title="MacOS 环境"></a>MacOS 环境</h3><p>Homebrew<br>git、yasm</p><h4 id="NDK"><a href="#NDK" class="headerlink" title="NDK"></a>NDK</h4><p>必需 Android NDK 10-14</p><p><a href="https://developer.android.google.cn/ndk/downloads/older_releases.html" target="_blank" rel="noopener">https://developer.android.google.cn/ndk/downloads/older_releases.html</a></p><h3 id="Build"><a href="#Build" class="headerlink" title="Build"></a>Build</h3><pre><code>export ANDROID_NDK=~/workspace/android/ndk-r10eexport PATH=$PATH:$ANDROID_NDK</code></pre><h4 id="配置编解码器格式支持"><a href="#配置编解码器格式支持" class="headerlink" title="配置编解码器格式支持"></a>配置编解码器格式支持</h4><p>默认为最少支持，如果足够你使用，可以跳过这一步，否则可以改为以下配置:</p><ul><li>module-default.sh 更多的编解码器/格式</li><li>module-lite-hevc.sh 较少的编解码器/格式(包括 hevc)</li><li>module-lite.sh 较少的编解码器/格式(默认情况)</li></ul><pre><code>git clone https://github.com/bilibili/ijkplayer.git// 这步会下载 FFmpeg 源码，并自动执行 init-config.sh 和 ./init-android-libyuv.sh./init-android.sh// 如果需要启用 ssl、https 支持，执行这步./init-android-openssl.sh// 其他文件有待探索// ./init-android-j4a.sh// ./init-android-prof.sh// ./init-android-libsoxr.sh// ./init-android-exo.sh//build extracd android/contrib./compile-ffmpeg.sh clean./compile-ffmpeg.sh allcd .../compile-ijk.sh all</code></pre><h4 id="NDK-1"><a href="#NDK-1" class="headerlink" title="NDK"></a>NDK</h4><p>注意申明<code>ANDROID_NDK</code>为指定版本的</p><pre><code># export ANDROID_SDK=&lt;your sdk path&gt;# export ANDROID_NDK=&lt;your ndk path&gt;</code></pre><h4 id="0-8-8-Build"><a href="#0-8-8-Build" class="headerlink" title="0.8.8 Build"></a>0.8.8 Build</h4><p><code>module.sh</code> add this </p><pre><code>export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --disable-linux-perf&quot;export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --disable-bzlib&quot;</code></pre><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.jianshu.com/p/11493731ea2c" target="_blank" rel="noopener">https://www.jianshu.com/p/11493731ea2c</a></p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><pre><code>// 添加格式、rtsp(tcp)支持export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --enable-decoder=mpeg4&quot;export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --enable-decoder=mp2*&quot;export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --enable-decoder=ac3&quot;export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --enable-decoder=mjpeg&quot;export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --enable-demuxer=rtsp&quot;export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --enable-demuxer=mjpeg&quot;export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --enable-protocol=rtp&quot;export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --enable-protocol=tcp&quot;</code></pre><p>注释掉</p><pre><code>export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --disable-protocol=rtp&quot;</code></pre><h3 id="Gradlew"><a href="#Gradlew" class="headerlink" title="Gradlew"></a>Gradlew</h3><pre><code>#强制清除 gradle 依赖缓存./gradlew build --refresh-dependencies  </code></pre><h3 id="问题集合"><a href="#问题集合" class="headerlink" title="问题集合"></a>问题集合</h3><p>1、IJKPlayer 不像系统播放器会给你旋转视频角度，所以你需要通过<code>onInfo</code>的<code>what == IMediaPlayer.MEDIA_INFO_VIDEO_ROTATION_CHANGED</code>去获取角度，自己旋转画面；或者开启硬解硬解码，不过硬解码容易造成黑屏无声</p><pre><code>mediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, &quot;mediacodec&quot;, 1);mediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, &quot;mediacodec-auto-rotate&quot;, 1);mediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, &quot;mediacodec-handle-resolution-change&quot;, 1);</code></pre><p>2、 IJKPlayer 出现黑色有声音没图像，看看你的视频编码是不是H264，pixel format是否存在，音频编码是不是AAC？默认IJKPlayer是不支持3pg（支持它干啥(・-・)？），不支持mepg（比如这个库RecordVideoDemo ）,不支持AMR。所以如果你真的想要支持，那么参考这个#1961，打开mpeg支持，重新编ffmpeg，然后通过硬解码播放mpeg；或者通过系统的录制VideoRecord；或者选另外的JAVACV录制封装FFmpegRecorder。</p><pre><code>ijkMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, &quot;mediacodec&quot;, 1);ijkMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, &quot;mediacodec_mpeg4&quot;, 1);</code></pre><p>3、 **快进和慢放接口，已经支持全版本，如果遇到声调问题，可以设置：</p><pre><code>ijkMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, &quot;soundtouch&quot;, 1);</code></pre><p>4、暂停的时候，退到后台再回到前台，画面黑了？</p><p>1、<br>这时候个人处理方式是，可以在暂停的时候，通过TextureView.getBitmap(point.x, point.y);获取到暂停的画面，用ImageView显示它，在onSurfaceTextureUpdated的时候隐藏ImageView，来实现画面的衔接。</p><p>2、暂停时绘制静态画面多TextureView的Surface上，详细参考GSYVideoPlayer。</p><p>5、一些视频返回码</p><pre><code>int MEDIA_INFO_VIDEO_RENDERING_START = 3;//视频准备渲染int MEDIA_INFO_BUFFERING_START = 701;//开始缓冲int MEDIA_INFO_BUFFERING_END = 702;//缓冲结束int MEDIA_INFO_VIDEO_ROTATION_CHANGED = 10001;//视频选择信息int MEDIA_ERROR_SERVER_DIED = 100;//视频中断，一般是视频源异常或者不支持的视频类型。int MEDIA_ERROR_IJK_PLAYER = -10000,//一般是视频源有问题或者数据格式不支持，比如音频不是AAC之类的int MEDIA_ERROR_NOT_VALID_FOR_PROGRESSIVE_PLAYBACK = 200;//数据错误没有有效的回收</code></pre><p>6、某些视频在SeekTo的时候，会跳回到拖动前的位置，这是因为视频的关键帧的问题，通俗一点就是FFMPEG不兼容，视频压缩过于厉害，seek只支持关键帧，出现这个情况就是原始的视频文件中i 帧比较少，可开启以下来解决：</p><pre><code>setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, &quot;enable-accurate-seek&quot;, 1);</code></pre><p>7、下载速度可以通过IjkMediaPlayer的getTcpSpeed获取。</p><p>8、高分辨率开启硬解码，不支持的话会自动切换到软解，就算开启mediacodec，如果设备不支持，显示的解码器也是avcodec软解。</p><p>9、ijkMediaPlayer.setOption可配置的对应头文件参考：ff_ffplay_options。</p><p>10、缓冲进度条不到100，官方表示我就不保证都100，所以一般我都是：</p><pre><code>//95这个数值可能不准确，有些时候可能还需要低一些if (secProgress &gt; 95) secProgress = 100;</code></pre><p>11、上面1、2、6的问题，在IJK封装的EXOPlayer和MediaPlayer都不会有问题，兼容上确实强过IJKPlayer，但是它们在细节上，却没有IJK处理的好，如EXOPlayer：退到后再回到前台、切换渲染控件的黑屏一段时间问题，除了用seekto之外目前没发现其他办法，这样的体验让我最后还是选择IJKPlayer。</p><p>12、设置cookie 可以通过ijkPlayer的public void setDataSource(String path, Map&lt;String, String&gt; headers) 的header实现设置，参考ijkPlayer的issues-1150，headers也是在内部被转化为何issuses一样的setOption方法</p><p>13、多个分片播放的功能，请查阅:</p><p><a href="https://github.com/CarGuo/GSYVideoPlayer/issues/64" target="_blank" rel="noopener">issues64-一个视频，多个视频片段问题</a><br><a href="https://github.com/Bilibili/ijkplayer/issues/490" target="_blank" rel="noopener">issues490分段视频</a><br><a href="https://www.jianshu.com/p/ea794a357b48" target="_blank" rel="noopener">ijkplayer-ffmpeg之concat</a></p><p>14、硬解码黑屏相关issuse以及建议<br><a href="https://github.com/Bilibili/ijkplayer/issues/1324" target="_blank" rel="noopener">android用硬解码播放器切后台恢复问题</a></p><p>14、硬解码黑屏相关issuse以及建议</p><p><a href="https://github.com/Bilibili/ijkplayer/issues/1324" target="_blank" rel="noopener">bilibili-issuse-1324</a></p><p>15、出现声音画面不同步</p><p>1、关了硬解码。</p><p>2、参考如下：</p><p><a href="http://www.jianshu.com/p/a5cf04181f3d" target="_blank" rel="noopener">http://www.jianshu.com/p/a5cf04181f3d</a><br>设置视频的倍速：<br>[options setPlayerOptionIntValue:10 forKey:@”framedrop”];<br>mediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, “framedrop”, 60);</p><p>16、rtsp播放失败问题</p><p><a href="https://github.com/CarGuo/GSYVideoPlayer/issues/232" target="_blank" rel="noopener">https://github.com/CarGuo/GSYVideoPlayer/issues/232</a></p><p><a href="https://github.com/CarGuo/GSYVideoPlayer/issues/207" target="_blank" rel="noopener">https://github.com/CarGuo/GSYVideoPlayer/issues/207</a></p><p>17、m3u8拖动seek之后，加载很长时间</p><p><a href="https://github.com/Bilibili/ijkplayer/issues/2874" target="_blank" rel="noopener">https://github.com/Bilibili/ijkplayer/issues/2874</a></p><p><a href="https://github.com/CarGuo/GSYVideoPlayer/issues/252" target="_blank" rel="noopener">https://github.com/CarGuo/GSYVideoPlayer/issues/252</a></p><p>18、m3u8本地播放问题</p><pre><code>ijkplayer.setOption(IjkMediaPlayer.OPT_CATEGORY_FORMAT, &quot;protocol_whitelist&quot;, &quot;crypto,file,http,https,tcp,tls,udp&quot;); </code></pre><p>19、断网自动重新连接<br>url前接上ijkhttphook:，如</p><p>String url = “ijkhttphook:<a href="http://baobab.wdjcdn.com/14564977406580.mp4&quot;" target="_blank" rel="noopener">http://baobab.wdjcdn.com/14564977406580.mp4&quot;</a>;<br>然后设置</p><pre class=" language-((IjkMediaPlayer)mediaPlayer).setOnNativeInvokeListener(new"><code class="language-((IjkMediaPlayer)mediaPlayer).setOnNativeInvokeListener(new">            @Override            public boolean onNativeInvoke(int i, Bundle bundle) {                return true;            }        })</code></pre><p>20、url切换400（http与https域名共用）</p><pre><code>ijkplayer.setOption(IjkMediaPlayer.OPT_CATEGORY_FORMAT, &quot;dns_cache_clear&quot;, 1);</code></pre><p>21、Rtsp优化</p><pre><code>//硬解码：1、打开，0、关闭//mMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, &quot;mediacodec&quot;, 1);//软解码：1、打开，0、关闭//mMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, &quot;videotoolbox&quot;, 0);//rtsp设置 https://ffmpeg.org/ffmpeg-protocols.html#rtspmMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_FORMAT, &quot;rtsp_transport&quot;, &quot;tcp&quot;);mMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_FORMAT, &quot;rtsp_flags&quot;, &quot;prefer_tcp&quot;);mMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_FORMAT, &quot;allowed_media_types&quot;, &quot;video&quot;); //根据媒体类型来配置mMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_FORMAT, &quot;timeout&quot;, 20000);mMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_FORMAT, &quot;buffer_size&quot;, 1316);mMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_FORMAT, &quot;infbuf&quot;, 1);  // 无限读mMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_FORMAT, &quot;analyzemaxduration&quot;, 100L);mMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_FORMAT, &quot;probesize&quot;, 10240L);mMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_FORMAT, &quot;flush_packets&quot;, 1L);//  关闭播放器缓冲，这个必须关闭，否则会出现播放一段时间后，一直卡主，控制台打印 FFP_MSG_BUFFERING_START mMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, &quot;packet-buffering&quot;, 0L);mMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, &quot;framedrop&quot;, 1L);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> ffmpeg </tag>
            
            <tag> ijkplayer </tag>
            
            <tag> 编译 </tag>
            
            <tag> 多媒体 </tag>
            
            <tag> 视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 总结</title>
      <link href="/2020/02/26/git-summary/"/>
      <url>/2020/02/26/git-summary/</url>
      
        <content type="html"><![CDATA[<h1 id="Git整理"><a href="#Git整理" class="headerlink" title="Git整理"></a>Git整理</h1><hr><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="初始化git"><a href="#初始化git" class="headerlink" title="初始化git"></a>初始化git</h3><h4 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h4><p>可以通过命令行<code>ssh-keygen</code>[Windows没有需要安装cmder类似软件支持]，或者<code>PuTTYgen</code>软件生成</p><pre><code>$ ssh-keygen -t rsa -C &quot;497633959@qq.com&quot;Generating public/private rsa key pair.Enter file in which to save the key (/Users/xuhaoyang/.ssh/id_rsa):Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /Users/xuhaoyang/.ssh/id_rsa.Your public key has been saved in /Users/xuhaoyang/.ssh/id_rsa.pub.The key fingerprint is:SHA256:LGVPxsHQKFHyMjwcfVNRIZCNpro4ORUHTW6NYhbplSk 497633959@qq.comThe key&#39;s randomart image is:+---[RSA 2048]----+|      =B+Bo*+oo. ||     oE*B+O...   ||     .X=B+=.     ||     ooXo+       ||      .+S .      ||      o.         ||     + .         ||    = .          ||     o           |+----[SHA256]-----+</code></pre><p>默认生成密钥，公钥<code>id_rsa.pub</code>和私钥<code>id_rsa</code>，注意私钥必须自己保存不能外泄。</p><h4 id="初始化git-信息"><a href="#初始化git-信息" class="headerlink" title="初始化git 信息"></a>初始化git 信息</h4><pre><code>$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot;</code></pre><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><p>版本库又名仓库，英文名<code>repository</code>。你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。<br>创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：</p><pre><code>$ mkdir learngit$ cd learngit$ pwd/Users/michael/learngit</code></pre><p><code>pwd</code>命令用于显示当前目录。在我的Mac上，这个仓库位于/Users/michael/learngit。<br>第二步，通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：</p><pre><code>$ git initInitialized empty Git repository in /Users/michael/learngit/.git/</code></pre><p>一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。<br>如果你没有看到<code>.git</code>目录，那是因为这个目录默认是隐藏的，用<code>ls -ah</code>命令就可以看见。</p><p>添加文件到Git仓库，分两步：</p><ul><li><p>第一步，使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；</p></li><li><p>第二步，使用命令<code>git commit</code>，完成。</p><h3 id="状态命令"><a href="#状态命令" class="headerlink" title="状态命令"></a>状态命令</h3></li><li><p>要随时掌握工作区的状态，使用<code>git status</code>命令。</p></li><li><p>如果git status告诉你有文件被修改过，用git diff可以查看修改内容。git diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式。</p></li></ul><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><ul><li>可以通过命令<code>git log</code>查看Git的历史记录。如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数。</li><li>Git的<code>commit id</code>是一个SHA1计算出来的一个非常大的数字，用十六进制表示。</li><li>在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>3628164...882e1e0</code>，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个^比较容易数不过来，所以写成<code>HEAD~100</code>。</li><li>回退到上一版本的操作</li></ul><pre><code>$ git reset --hard HEAD^HEAD is now at ea34578 add distributed</code></pre><p>当回退完成之后，如果返回到回退之前的状态的话，可以通过<code>git reflog</code>命令查看git的记录，然后找到想要回退的<code>commit id</code>，就可以使用下面的命令返回到指定的commit。</p><pre><code>git reset --hard commit id</code></pre><h3 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h3><p>在本地中，一个项目的目录就是一个工作区。<br>版本库，工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。Git的版本库里存了很多东西，其中最重要的就是称为<code>stage</code>（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向master的一个指针叫<code>HEAD</code>。</p><p><img src="1458722977422.png" alt="1458722977422"></p><p>我们把文件往Git版本库里添加的时候，是分两步执行的：</p><ol><li>用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</li><li>用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</li></ol><p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，<code>git commit</code>就是往<code>master</code>分支上提交更改。可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p><h3 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h3><p>Git管理的是修改，当你用<code>git add</code>命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p><h4 id="修改commit时间"><a href="#修改commit时间" class="headerlink" title="修改commit时间"></a>修改commit时间</h4><pre class=" language-shell"><code class="language-shell">git commit --amend --date="$(date -R)"</code></pre><p>修改当前本地提交的 commit 时间</p><pre class=" language-shell"><code class="language-shell">git commit --amend --date="2019-01-01T00:00:00+0800" -am "chore(md): 更新 README.md"</code></pre><p>修改之前提交的某次 commit 时间，使用之前commit的Id</p><pre class=" language-shell"><code class="language-shell">git commit --amend --date="2019-01-01T00:00:00+0800" -C d2b75280f11894c4c44dd80f9fd0982df461958a</code></pre><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><p>使用命令git checkout – file可以丢弃工作的的修改。这里存在两种情况：</p><ol><li>一种是file自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</li><li>一种是file已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。总之，就是让这个文件回到最近一次git commit或git add时的状态。</li></ol><p><code>git checkout -- file</code>命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令。</p><p>撤销修改有以下几个场景：</p><ol><li>当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</li><li>当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD file</code>，就回到了场景1，第二步按场景1操作。</li><li>已经提交了不合适的修改到版本库时，想要撤销本次提交，可以使用版本回退。</li></ol><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>一般情况下，可以直接在文件管理器中把没用的文件删了，或者用rm命令删除。</p><pre class=" language-shell"><code class="language-shell">$ rm test.txt</code></pre><p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，<code>git status</code>命令会立刻告诉你哪些文件被删除了。<br>现在有两种情况，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且<code>git commit</code>。<br>另一种情况是删错了，因为版本库里还有，所以可以通过命令<code>git checkout --file</code>来进行“一键还原”。</p><h3 id="撤出暂存区（或从暂存区删除）"><a href="#撤出暂存区（或从暂存区删除）" class="headerlink" title="撤出暂存区（或从暂存区删除）"></a>撤出暂存区（或从暂存区删除）</h3><p>使用 <code>git rm --cached &lt;file&gt;...</code> 撤出暂存区</p><h3 id="查看日志log"><a href="#查看日志log" class="headerlink" title="查看日志log"></a>查看日志log</h3><h4 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h4><p><code>-p</code> 选项展开显示每次提交的内容差异</p><p><code>--word-diff</code> 从而获取单词层面上的对比<br>git log –word-diff -U1<br><img src="15275755278746.jpg" alt="-w480"></p><p><code>--stat</code> 仅显示简要的增改行数统计<br><img src="15275754061918.jpg" alt="-w480"></p><p><code>--graph</code> 一些 ASCII 字符串表示的简单图形</p><pre><code> git log --oneline --stat --decorate --pretty=format:&quot;%h - %an, %ar : %s&quot;</code></pre><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>%H</td><td>提交对象（commit）的完整哈希字串</td></tr><tr><td>%h</td><td>提交对象的简短哈希字串</td></tr><tr><td>%T</td><td>树对象（tree）的完整哈希字串</td></tr><tr><td>%t</td><td>树对象的简短哈希字串</td></tr><tr><td>%P</td><td>父对象（parent）的完整哈希字串</td></tr><tr><td>%p</td><td>父对象的简短哈希字串</td></tr><tr><td>%an</td><td>作者（author）的名字</td></tr><tr><td>%ae</td><td>作者的电子邮件地址</td></tr><tr><td>%ad</td><td>作者修订日期（可以用 -date= 选项定制格式）</td></tr><tr><td>%ar</td><td>作者修订日期，按多久以前的方式显示</td></tr><tr><td>%cn</td><td>提交者(committer)的名字</td></tr><tr><td>%ce</td><td>提交者的电子邮件地址</td></tr><tr><td>%cd</td><td>提交日期</td></tr><tr><td>%cr</td><td>提交日期，按多久以前的方式显示</td></tr><tr><td>%s</td><td>提交说明</td></tr></tbody></table><pre><code>git config --global alias.lm  &quot;log --no-merges --color --date=format:&#39;%Y-%m-%d %H:%M:%S&#39; --author=&#39;XHY&#39; --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;git config --global alias.lms  &quot;log --no-merges --color --stat --date=format:&#39;%Y-%m-%d %H:%M:%S&#39; --author=&#39;XHY&#39; --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;git config --global alias.ls &quot;log --no-merges --color --graph --date=format:&#39;%Y-%m-%d %H:%M:%S&#39; --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;git config --global alias.lss &quot;log --no-merges --color --stat --graph --date=format:&#39;%Y-%m-%d %H:%M:%S&#39; --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;</code></pre><p><img src="15275769609397.jpg" alt="-w480"></p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><h3 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h3><p>Git鼓励大量使用分支：<br>查看分支：<code>git branch</code><br>创建分支：<code>git branch &lt;name&gt;</code><br>切换分支：<code>git checkout &lt;name&gt;</code><br>创建+切换分支：<code>git checkout -b &lt;name&gt;</code><br>合并某分支到当前分支：<code>git merge &lt;name&gt;</code><br>删除分支：<code>git branch -d &lt;name&gt;</code><br>参考文章：<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840038939c291467cc7c747b1810aab2fb8863508000" target="_blank" rel="noopener">创建和合并分支</a></p><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>合并分支时出现冲突的情况：</p><pre><code>$ git merge feature1Auto-merging readme.txtCONFLICT (content): Merge conflict in readme.txtAutomatic merge failed; fix conflicts and then commit the result.</code></pre><p>通过使用命令<code>git status</code>可以查看冲突的文件。Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容。用<code>git log --graph</code>命令可以看到分支合并图。</p><h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h3><p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，就是使用命令<code>git merge --no-ff -m &quot;message&quot; branch</code>，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用<code>Fast forward</code>模式，Git就会在<code>merge</code>时生成一个新的<code>commit</code>，这样，从分支历史上就可以看出分支信息。</p><h3 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h3><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；<br>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场。</p><h3 id="feature分支"><a href="#feature分支" class="headerlink" title="feature分支"></a>feature分支</h3><p>开发一个新<code>feature</code>，最好新建一个分支；<br>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p><h3 id="多人协助"><a href="#多人协助" class="headerlink" title="多人协助"></a>多人协助</h3><h5 id="查看远程库"><a href="#查看远程库" class="headerlink" title="查看远程库"></a>查看远程库</h5><p>要查看远程库的信息，用<code>git remote</code></p><pre><code>$ git remoteorigin</code></pre><p>或者，用<code>git remote -v</code>显示更详细的信息：</p><pre><code>$ git remote -vorigin  git@github.com:michaelliao/learngit.git (fetch)origin  git@github.com:michaelliao/learngit.git (push)</code></pre><h5 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h5><p>远程仓库还为空时，或推送到新的一个远程仓库，与本地关联，使用<code>git remote add [origin名字] [git@github.com:michaelliao/learngit.git]</code></p><p>添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p><p>下一步，就可以把本地库的所有内容推送到远程库上：</p><pre><code>$ git push -u origin masterCounting objects: 19, done.Delta compression using up to 4 threads.Compressing objects: 100% (19/19), done.Writing objects: 100% (1a9/19), 13.73 KiB, done.Total 23 (delta 6), reused 0 (delta 0)To git@github.com:michaelliao/learngit.git * [new branch]      master -&gt; masterBranch master set up to track remote branch master from origin.</code></pre><h5 id="取消远程与本地库关联"><a href="#取消远程与本地库关联" class="headerlink" title="取消远程与本地库关联"></a>取消远程与本地库关联</h5><pre><code>git remote remove [origin/名字]</code></pre><h5 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h5><p>多人协作时，大家都会往<code>master</code>和<code>dev</code>分支上推送各自的修改。<br>当你的小伙伴从远程库<code>clone</code>时，默认情况下，你的小伙伴只能看到本地的<code>master</code>分支。<br>现在，你的小伙伴要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地，于是他用这个命令创建本地<code>dev</code>分支：</p><pre><code>$ git checkout -b dev origin/dev</code></pre><p>如果克隆指定分支</p><pre><code>$ git clone -b dev [地址]</code></pre><p>现在，他就可以在<code>dev</code>上继续修改，然后，时不时地把<code>dev</code>分支<code>push</code>到远程。<br>你的小伙伴已经向<code>origin/dev</code>分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送。这时就会推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送。有时<code>git pull</code>也会失败，原因是没有指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接，根据提示，设置<code>dev</code>和origin/dev的链接（建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>）：</p><pre><code>$ git branch --set-upstream dev origin/devBranch dev set up to track remote branch dev from origin.</code></pre><p>再pull：</p><pre><code>$ git pullAuto-merging hello.pyCONFLICT (content): Merge conflict in hello.pyAutomatic merge failed; fix conflicts and then commit the result.</code></pre><p>这回git pull成功。</p><h3 id="推送本地分支到远程新分支"><a href="#推送本地分支到远程新分支" class="headerlink" title="推送本地分支到远程新分支"></a>推送本地分支到远程新分支</h3><p>命令<code>git push origin &lt;本地分支name&gt;:&lt;远程分支name&gt;</code>，将本地推送的远程新分支，注意推送成功后，再次用<code>git push</code>是无法直接推送成功，</p><pre><code>git push origin dev:dev</code></pre><h3 id="强制覆盖本地文件"><a href="#强制覆盖本地文件" class="headerlink" title="强制覆盖本地文件"></a>强制覆盖本地文件</h3><pre><code>git fetch --all  git reset --hard origin/master git pull</code></pre><h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><p>如果不再需要某个远程分支了，比如搞定了某个特性并把它合并进了远程的 <code>master</code> 分支（或任何其他存放稳定代码的分支），可以用这个非常无厘头的语法来删除它：<code>git push [远程名] :[分支名]</code>。如果想在服务器上删除 <code>serverfix</code> 分支，运行下面的命令：</p><pre><code>$ git push origin :serverfixTo git@github.com:schacon/simplegit.git - [deleted]         serverfix</code></pre><h3 id="Git合并指定commit到当前分支-cherry-pick-rebase"><a href="#Git合并指定commit到当前分支-cherry-pick-rebase" class="headerlink" title="Git合并指定commit到当前分支(cherry-pick/rebase)"></a>Git合并指定commit到当前分支(cherry-pick/rebase)</h3><p>有时我们需要将指定的某一次commit合并到当前分支，比如线上的一次bugfix，只合并需要的commits。</p><p>首先，用git log或GitX工具查看一下你想选择哪些commits进行合并，例如：</p><pre><code>dd2e86 - 946992 -9143a9 - a6fd86 - 5a6057 [master]           \            76cada - 62ecb3 - b886a0 [feature]</code></pre><p>比如，feature 分支上的commit <code>62ecb3</code> 非常重要，它含有一个bug的修改。你现在只需要将62ecb3 合并到master，而不合并feature上的其他commits，所以我们用<code>git cherry-pick</code>命令来做：</p><pre><code>&gt; git checkout master&gt; git cherry-pick 62ecb3</code></pre><p>这样就好啦。现在62ecb3 就被合并到master分支，并在master中添加了commit（作为一个新的commit）。cherry-pick 和merge比较类似，如果git不能合并代码改动（比如遇到合并冲突），git需要你自己来解决冲突并手动添加commit。</p><p><strong>合并某个分支上的一系列commits</strong><br>在一些特性情况下，合并单个commit并不够，你需要合并一系列相连的commits。这种情况下就不要选择<code>cherry-pick</code>了，rebase 更适合。还以上例为例，假设你需要合并feature分支的commit76cada ~62ecb3 到master分支。</p><p>首先需要基于feature创建一个新的分支，并指明新分支的最后一个commit：</p><pre><code>git checkout -bnewbranch 62ecb3</code></pre><p>然后，rebase这个新分支的commit到master（–ontomaster）。76cada^ 指明你想从哪个特定的commit开始。</p><pre><code>&gt; git rebase --ontomaster 76cada^</code></pre><p>得到的结果就是feature分支的commit 76cada ~62ecb3 都被合并到了master分支。</p><h3 id="通过Git-rebase-i-修订历史commit"><a href="#通过Git-rebase-i-修订历史commit" class="headerlink" title="通过Git rebase -i 修订历史commit"></a>通过Git rebase -i 修订历史commit</h3><p>建议在<code>git rebase -i &lt;ref&gt;</code> 目标commit id加上<code>^</code>。</p><p>重置commit 时间到当前时间</p><pre class=" language-shell"><code class="language-shell">git commit --amend --reset-author --no-edit</code></pre><h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><p>发布一个版本时，我们通常先在版本库中打一个标签，这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。<br>Git的标签虽然是版本库的快照，但其实它就是指向某个<code>commit</code>的指针，<br>所以，创建和删除标签都是瞬间完成的。</p><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><ol><li>命令<code>git tag &lt;name&gt;</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个<code>commit id</code>；</li><li><code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息；</li><li><code>git tag -s &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以用PGP签名标签；</li><li>命令<code>git tag</code>可以查看所有标签。</li></ol><h3 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h3><ol><li>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</li><li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</li><li>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</li><li>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</li></ol><h3 id="优雅的删除子模块"><a href="#优雅的删除子模块" class="headerlink" title="优雅的删除子模块"></a>优雅的删除子模块</h3><pre class=" language-shell"><code class="language-shell"># 逆初始化模块，其中{MOD_NAME}为模块目录，执行后可发现模块目录被清空git submodule deinit {MOD_NAME} # 删除.gitmodules中记录的模块信息（--cached选项清除.git/modules中的缓存）git rm --cached {MOD_NAME} # 提交更改到代码库，可观察到'.gitmodules'内容发生变更git commit -am "Remove a submodule." </code></pre><h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><p>要push代码到git时，出现提示：</p><pre><code>error:failed to push some refs to ...Dealing with “non-fast-forward” errorsFrom time to time you may encounter this error while pushing:$ git push origin masterTo ../remote/! [rejected]        master -&gt; master (non-fast forward)error: failed to push some refs to &#39;../remote/&#39;To prevent you from losing history, non-fast-forward updates were rejectedMerge the remote changes before pushing again.  See the &#39;non-fast forward&#39;section of &#39;git push --help&#39; for details.</code></pre><p>问题<code>（Non-fast-forward）</code>的出现原因在于：git仓库中已经有一部分代码，所以它不允许你直接把你的代码覆盖上去。可以有两种解决方法:</p><ul><li>使用命令<code>git push -f</code>强推，利用强覆盖方式用你本地的代码替代git仓库内的内容。</li><li>先把<code>git</code>的东西<code>fetch</code>到你本地然后<code>merge</code>后再<code>push</code></li></ul><pre><code>$ git fetch$ git merge</code></pre><p>这2句命令等价于</p><pre><code>$ git pull</code></pre><p>可是，这时候又出现了如下的问题：<br>上面出现的 <code>[branch “master”]</code>是需要明确<code>(.git/config)</code>如下的内容</p><pre><code>[branch &quot;master&quot;]    remote = origin    merge = refs/heads/master</code></pre><p>这等于告诉<code>git</code> 2件事:<br>1，当你处于<code>master branch</code>, 默认的<code>remote</code>就是<code>origin</code>。<br>2，当你在<code>master branch</code>上使用<code>git pull</code>时，没有指定<code>remote</code>和<code>branch</code>，那么<code>git</code>就会采用默认的<code>remote</code>（也就是<code>origin</code>）来<code>merge</code>在master <code>branch</code>上所有的改变<br>如果不想或者不会编辑<code>config</code>文件的话，可以在<code>bush</code>上输入如下命令行：</p><pre><code>$ git config branch.master.remote origin$ git config branch.master.merge refs/heads/master</code></pre><p>之后再重新<code>git pull</code>。最后<code>git push</code>代码吧。</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Clash 使用教程</title>
      <link href="/2020/02/17/clash-tutorial/"/>
      <url>/2020/02/17/clash-tutorial/</url>
      
        <content type="html"><![CDATA[<p>Clash 是支持Windows、Linux、macOS、Android等多平台的代理软件。支持协议shadowsocks/V2ray。是主要以规则导向型软件。</p><h2 id="Clash-设置介绍"><a href="#Clash-设置介绍" class="headerlink" title="Clash 设置介绍"></a>Clash 设置介绍</h2><p>这里的设置，主要是指Clash软件当前Proxy运行模式。<br>有<code>Global-全局</code>、<code>Rule-规则</code>、<code>Direct-直连</code>。</p><p><code>Global</code> 指全部数据通过选择的节点进行网络访问<br><code>Rule</code> 请求根据根据配置决定是走翻墙还是不翻墙(往下会进行说明)<br><code>Direct</code> 请求不进行代理(翻墙)</p><p>Clash for Windows 相关设置如图<br><img src="clashl1.jpg" alt=""></p><p>Clash for Android 暂无此类设置</p><p>ClashX(Mac OS) 相关设置如图<br><img src="clashl2.jpg" alt=""></p><h3 id="Clash-代理组介绍"><a href="#Clash-代理组介绍" class="headerlink" title="Clash 代理组介绍"></a>Clash 代理组介绍</h3><p>这里以ClashX的图进行介绍，其他系统的Clash可以参考</p><p>默认情况下什么都不改动，是可以自动翻墙。<br>图中的分组，是来自DlerCloud。</p><p><img src="clashl3.jpg" alt=""></p><p><code>Auto - UrlTest</code> 自动根据网络延迟选择节点，会选择延迟最低的服务器。但延迟低不代表速度快。<br><code>Proxy</code> 代理组，主要的外国网站会走这个代理组，如图选择了<code>Auto - UrlTest</code>，则是根据<code>Auto - UrlTest</code>组自动选择节点进行翻墙。<br><code>Domestic</code> 代理组，主要国内重点网站/国内IP会走这个代理组，如图改代理组选择了<code>DIRECT</code>，则是直连<br><code>Others</code> 代理组，部分特殊外国网站走这个代理组。<br><code>Adblock</code> 代理组，部分广告网址 会走这个代理组，如图选择了<code>REJECT</code>(阻断)，匹配中的广告将无法显示。<br><code>Apple</code> 代理组，Apple 有关服务会走这个代理组。<br><code>AsinTV</code> 代理组，如 youku，爱奇艺，bilibil等中国大陆视频网站走这个代理组。<br><code>GlobalTV</code> 代理组，如Youtube等国外视频网站走这个代理组。<br><code>Telegram</code> 代理组，Telegram 聊天软件走这个代理组<br><code>Speedtest</code> 代理组，speedtest.net测速走这个代理组<br><code>Mircrosoft</code> 代理组，微软相关网络服务走这个代理组。</p><p>每个代理组中，所选择的节点，则为该代理组所匹配到的网站，会从哪个节点进行访问。</p><p>但有一些共有参数：</p><ul><li><code>DIRECT</code> 直连</li><li><code>REJECT</code> 阻断</li></ul><p>节点中如果包含<code>back</code>，则为外国用户访问国内服务使用。</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Clash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ClashX</title>
      <link href="/2020/02/17/clashx/"/>
      <url>/2020/02/17/clashx/</url>
      
        <content type="html"><![CDATA[<ul><li><p>系统要求: Mac OS 10.5 及以上</p><blockquote><p>ClashX 不兼容SSR 协议</p></blockquote><blockquote><p>首次使用 ClashX 时，macOS 会提醒你此应用来自未知开发者，请允许打开此应用。<br><br>ClashX 首次运行会提示是否安装帮助程序（Helper）。此帮助程序用于设置系统代理，否则每次你通过 ClashX 变更系统系统状态（打开或关闭）时都需要输入密码，请点击「Install」，之后 macOS 会提示输入用户密码。</p></blockquote><p><img src="clashx1.png" alt="clashx1"></p></li></ul><ol><li>从右上角的状态栏找到 ClashX 图标并进行鼠标右键</li><li>通过 配置 - 托管配置 - 管理 点击，等待窗口弹出</li></ol><p><img src="clashx2.jpg" alt="clashx2"></p><ol start="3"><li>点击 添加 ，等待窗口弹出</li><li><code>Url</code> 输入 对应的订阅地址，<code>Config Name</code> 可以随意填，点击确定。</li></ol><p><img src="clashx3.jpg" alt="clashx3"></p><ol start="5"><li>等待出现配置列表 如图</li></ol><p><img src="clashx4.jpg" alt="clashx4"></p><p>6.点击 [设置为系统代理] 即可<br><img src="clashx5.png" alt="clashx5"></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Clash </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
